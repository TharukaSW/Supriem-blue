
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SalaryRange
 * 
 */
export type SalaryRange = $Result.DefaultSelection<Prisma.$SalaryRangePayload>
/**
 * Model EmployeeProfile
 * 
 */
export type EmployeeProfile = $Result.DefaultSelection<Prisma.$EmployeeProfilePayload>
/**
 * Model AttendanceDaily
 * 
 */
export type AttendanceDaily = $Result.DefaultSelection<Prisma.$AttendanceDailyPayload>
/**
 * Model SalaryPeriod
 * 
 */
export type SalaryPeriod = $Result.DefaultSelection<Prisma.$SalaryPeriodPayload>
/**
 * Model SalaryRecord
 * 
 */
export type SalaryRecord = $Result.DefaultSelection<Prisma.$SalaryRecordPayload>
/**
 * Model SalaryPayment
 * 
 */
export type SalaryPayment = $Result.DefaultSelection<Prisma.$SalaryPaymentPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = $Result.DefaultSelection<Prisma.$ItemCategoryPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model SupplierItemPrice
 * 
 */
export type SupplierItemPrice = $Result.DefaultSelection<Prisma.$SupplierItemPricePayload>
/**
 * Model CustomerItemPrice
 * 
 */
export type CustomerItemPrice = $Result.DefaultSelection<Prisma.$CustomerItemPricePayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderLine
 * 
 */
export type PurchaseOrderLine = $Result.DefaultSelection<Prisma.$PurchaseOrderLinePayload>
/**
 * Model SalesOrder
 * 
 */
export type SalesOrder = $Result.DefaultSelection<Prisma.$SalesOrderPayload>
/**
 * Model SalesOrderLine
 * 
 */
export type SalesOrderLine = $Result.DefaultSelection<Prisma.$SalesOrderLinePayload>
/**
 * Model Dispatch
 * 
 */
export type Dispatch = $Result.DefaultSelection<Prisma.$DispatchPayload>
/**
 * Model ProductionDay
 * 
 */
export type ProductionDay = $Result.DefaultSelection<Prisma.$ProductionDayPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model StockBalance
 * 
 */
export type StockBalance = $Result.DefaultSelection<Prisma.$StockBalancePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLine
 * 
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model CashTransaction
 * 
 */
export type CashTransaction = $Result.DefaultSelection<Prisma.$CashTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoleName: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const PayMethod: {
  CASH: 'CASH',
  BANK: 'BANK',
  CHEQUE: 'CHEQUE',
  CARD: 'CARD',
  OTHER: 'OTHER'
};

export type PayMethod = (typeof PayMethod)[keyof typeof PayMethod]


export const ItemType: {
  RAW: 'RAW',
  PRODUCT: 'PRODUCT',
  SERVICE: 'SERVICE'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const DocStatus: {
  DRAFT: 'DRAFT',
  CONFIRMED: 'CONFIRMED',
  RECEIVED: 'RECEIVED',
  DISPATCHED: 'DISPATCHED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  ISSUED: 'ISSUED',
  PAID: 'PAID'
};

export type DocStatus = (typeof DocStatus)[keyof typeof DocStatus]


export const MovementType: {
  PURCHASE_RECEIPT: 'PURCHASE_RECEIPT',
  PRODUCTION_OUTPUT: 'PRODUCTION_OUTPUT',
  PRODUCTION_ADJUSTMENT: 'PRODUCTION_ADJUSTMENT',
  SALES_DISPATCH: 'SALES_DISPATCH',
  ADJUSTMENT_IN: 'ADJUSTMENT_IN',
  ADJUSTMENT_OUT: 'ADJUSTMENT_OUT',
  RETURN_IN: 'RETURN_IN',
  RETURN_OUT: 'RETURN_OUT'
};

export type MovementType = (typeof MovementType)[keyof typeof MovementType]


export const InvoiceType: {
  SALES: 'SALES',
  PURCHASE: 'PURCHASE'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const MatchStatus: {
  PENDING: 'PENDING',
  MATCHED: 'MATCHED',
  MISMATCHED: 'MISMATCHED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const TxType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  TRANSFER: 'TRANSFER'
};

export type TxType = (typeof TxType)[keyof typeof TxType]

}

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type PayMethod = $Enums.PayMethod

export const PayMethod: typeof $Enums.PayMethod

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type DocStatus = $Enums.DocStatus

export const DocStatus: typeof $Enums.DocStatus

export type MovementType = $Enums.MovementType

export const MovementType: typeof $Enums.MovementType

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type TxType = $Enums.TxType

export const TxType: typeof $Enums.TxType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.salaryRange`: Exposes CRUD operations for the **SalaryRange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryRanges
    * const salaryRanges = await prisma.salaryRange.findMany()
    * ```
    */
  get salaryRange(): Prisma.SalaryRangeDelegate<ExtArgs>;

  /**
   * `prisma.employeeProfile`: Exposes CRUD operations for the **EmployeeProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeProfiles
    * const employeeProfiles = await prisma.employeeProfile.findMany()
    * ```
    */
  get employeeProfile(): Prisma.EmployeeProfileDelegate<ExtArgs>;

  /**
   * `prisma.attendanceDaily`: Exposes CRUD operations for the **AttendanceDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceDailies
    * const attendanceDailies = await prisma.attendanceDaily.findMany()
    * ```
    */
  get attendanceDaily(): Prisma.AttendanceDailyDelegate<ExtArgs>;

  /**
   * `prisma.salaryPeriod`: Exposes CRUD operations for the **SalaryPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPeriods
    * const salaryPeriods = await prisma.salaryPeriod.findMany()
    * ```
    */
  get salaryPeriod(): Prisma.SalaryPeriodDelegate<ExtArgs>;

  /**
   * `prisma.salaryRecord`: Exposes CRUD operations for the **SalaryRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryRecords
    * const salaryRecords = await prisma.salaryRecord.findMany()
    * ```
    */
  get salaryRecord(): Prisma.SalaryRecordDelegate<ExtArgs>;

  /**
   * `prisma.salaryPayment`: Exposes CRUD operations for the **SalaryPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPayments
    * const salaryPayments = await prisma.salaryPayment.findMany()
    * ```
    */
  get salaryPayment(): Prisma.SalaryPaymentDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.supplierItemPrice`: Exposes CRUD operations for the **SupplierItemPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierItemPrices
    * const supplierItemPrices = await prisma.supplierItemPrice.findMany()
    * ```
    */
  get supplierItemPrice(): Prisma.SupplierItemPriceDelegate<ExtArgs>;

  /**
   * `prisma.customerItemPrice`: Exposes CRUD operations for the **CustomerItemPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerItemPrices
    * const customerItemPrices = await prisma.customerItemPrice.findMany()
    * ```
    */
  get customerItemPrice(): Prisma.CustomerItemPriceDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrderLine`: Exposes CRUD operations for the **PurchaseOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderLines
    * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
    * ```
    */
  get purchaseOrderLine(): Prisma.PurchaseOrderLineDelegate<ExtArgs>;

  /**
   * `prisma.salesOrder`: Exposes CRUD operations for the **SalesOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrders
    * const salesOrders = await prisma.salesOrder.findMany()
    * ```
    */
  get salesOrder(): Prisma.SalesOrderDelegate<ExtArgs>;

  /**
   * `prisma.salesOrderLine`: Exposes CRUD operations for the **SalesOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrderLines
    * const salesOrderLines = await prisma.salesOrderLine.findMany()
    * ```
    */
  get salesOrderLine(): Prisma.SalesOrderLineDelegate<ExtArgs>;

  /**
   * `prisma.dispatch`: Exposes CRUD operations for the **Dispatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dispatches
    * const dispatches = await prisma.dispatch.findMany()
    * ```
    */
  get dispatch(): Prisma.DispatchDelegate<ExtArgs>;

  /**
   * `prisma.productionDay`: Exposes CRUD operations for the **ProductionDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionDays
    * const productionDays = await prisma.productionDay.findMany()
    * ```
    */
  get productionDay(): Prisma.ProductionDayDelegate<ExtArgs>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs>;

  /**
   * `prisma.stockBalance`: Exposes CRUD operations for the **StockBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockBalances
    * const stockBalances = await prisma.stockBalance.findMany()
    * ```
    */
  get stockBalance(): Prisma.StockBalanceDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.cashTransaction`: Exposes CRUD operations for the **CashTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashTransactions
    * const cashTransactions = await prisma.cashTransaction.findMany()
    * ```
    */
  get cashTransaction(): Prisma.CashTransactionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    User: 'User',
    SalaryRange: 'SalaryRange',
    EmployeeProfile: 'EmployeeProfile',
    AttendanceDaily: 'AttendanceDaily',
    SalaryPeriod: 'SalaryPeriod',
    SalaryRecord: 'SalaryRecord',
    SalaryPayment: 'SalaryPayment',
    Unit: 'Unit',
    ItemCategory: 'ItemCategory',
    Item: 'Item',
    Supplier: 'Supplier',
    Customer: 'Customer',
    SupplierItemPrice: 'SupplierItemPrice',
    CustomerItemPrice: 'CustomerItemPrice',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderLine: 'PurchaseOrderLine',
    SalesOrder: 'SalesOrder',
    SalesOrderLine: 'SalesOrderLine',
    Dispatch: 'Dispatch',
    ProductionDay: 'ProductionDay',
    StockMovement: 'StockMovement',
    StockBalance: 'StockBalance',
    Invoice: 'Invoice',
    InvoiceLine: 'InvoiceLine',
    Payment: 'Payment',
    Expense: 'Expense',
    CashTransaction: 'CashTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "role" | "user" | "salaryRange" | "employeeProfile" | "attendanceDaily" | "salaryPeriod" | "salaryRecord" | "salaryPayment" | "unit" | "itemCategory" | "item" | "supplier" | "customer" | "supplierItemPrice" | "customerItemPrice" | "purchaseOrder" | "purchaseOrderLine" | "salesOrder" | "salesOrderLine" | "dispatch" | "productionDay" | "stockMovement" | "stockBalance" | "invoice" | "invoiceLine" | "payment" | "expense" | "cashTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SalaryRange: {
        payload: Prisma.$SalaryRangePayload<ExtArgs>
        fields: Prisma.SalaryRangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryRangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryRangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>
          }
          findFirst: {
            args: Prisma.SalaryRangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryRangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>
          }
          findMany: {
            args: Prisma.SalaryRangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>[]
          }
          create: {
            args: Prisma.SalaryRangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>
          }
          createMany: {
            args: Prisma.SalaryRangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryRangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>[]
          }
          delete: {
            args: Prisma.SalaryRangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>
          }
          update: {
            args: Prisma.SalaryRangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>
          }
          deleteMany: {
            args: Prisma.SalaryRangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryRangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryRangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRangePayload>
          }
          aggregate: {
            args: Prisma.SalaryRangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryRange>
          }
          groupBy: {
            args: Prisma.SalaryRangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryRangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryRangeCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryRangeCountAggregateOutputType> | number
          }
        }
      }
      EmployeeProfile: {
        payload: Prisma.$EmployeeProfilePayload<ExtArgs>
        fields: Prisma.EmployeeProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findFirst: {
            args: Prisma.EmployeeProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findMany: {
            args: Prisma.EmployeeProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          create: {
            args: Prisma.EmployeeProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          createMany: {
            args: Prisma.EmployeeProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          delete: {
            args: Prisma.EmployeeProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          update: {
            args: Prisma.EmployeeProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          aggregate: {
            args: Prisma.EmployeeProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeProfile>
          }
          groupBy: {
            args: Prisma.EmployeeProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileCountAggregateOutputType> | number
          }
        }
      }
      AttendanceDaily: {
        payload: Prisma.$AttendanceDailyPayload<ExtArgs>
        fields: Prisma.AttendanceDailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceDailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceDailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>
          }
          findFirst: {
            args: Prisma.AttendanceDailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceDailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>
          }
          findMany: {
            args: Prisma.AttendanceDailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>[]
          }
          create: {
            args: Prisma.AttendanceDailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>
          }
          createMany: {
            args: Prisma.AttendanceDailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceDailyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>[]
          }
          delete: {
            args: Prisma.AttendanceDailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>
          }
          update: {
            args: Prisma.AttendanceDailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceDailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceDailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceDailyPayload>
          }
          aggregate: {
            args: Prisma.AttendanceDailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceDaily>
          }
          groupBy: {
            args: Prisma.AttendanceDailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceDailyCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceDailyCountAggregateOutputType> | number
          }
        }
      }
      SalaryPeriod: {
        payload: Prisma.$SalaryPeriodPayload<ExtArgs>
        fields: Prisma.SalaryPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>
          }
          findFirst: {
            args: Prisma.SalaryPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>
          }
          findMany: {
            args: Prisma.SalaryPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>[]
          }
          create: {
            args: Prisma.SalaryPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>
          }
          createMany: {
            args: Prisma.SalaryPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>[]
          }
          delete: {
            args: Prisma.SalaryPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>
          }
          update: {
            args: Prisma.SalaryPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPeriodPayload>
          }
          aggregate: {
            args: Prisma.SalaryPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPeriod>
          }
          groupBy: {
            args: Prisma.SalaryPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPeriodCountAggregateOutputType> | number
          }
        }
      }
      SalaryRecord: {
        payload: Prisma.$SalaryRecordPayload<ExtArgs>
        fields: Prisma.SalaryRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          findFirst: {
            args: Prisma.SalaryRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          findMany: {
            args: Prisma.SalaryRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>[]
          }
          create: {
            args: Prisma.SalaryRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          createMany: {
            args: Prisma.SalaryRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>[]
          }
          delete: {
            args: Prisma.SalaryRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          update: {
            args: Prisma.SalaryRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          deleteMany: {
            args: Prisma.SalaryRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryRecordPayload>
          }
          aggregate: {
            args: Prisma.SalaryRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryRecord>
          }
          groupBy: {
            args: Prisma.SalaryRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryRecordCountAggregateOutputType> | number
          }
        }
      }
      SalaryPayment: {
        payload: Prisma.$SalaryPaymentPayload<ExtArgs>
        fields: Prisma.SalaryPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findFirst: {
            args: Prisma.SalaryPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findMany: {
            args: Prisma.SalaryPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          create: {
            args: Prisma.SalaryPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          createMany: {
            args: Prisma.SalaryPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          delete: {
            args: Prisma.SalaryPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          update: {
            args: Prisma.SalaryPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          aggregate: {
            args: Prisma.SalaryPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPayment>
          }
          groupBy: {
            args: Prisma.SalaryPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      ItemCategory: {
        payload: Prisma.$ItemCategoryPayload<ExtArgs>
        fields: Prisma.ItemCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          update: {
            args: Prisma.ItemCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategory>
          }
          groupBy: {
            args: Prisma.ItemCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      SupplierItemPrice: {
        payload: Prisma.$SupplierItemPricePayload<ExtArgs>
        fields: Prisma.SupplierItemPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierItemPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierItemPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>
          }
          findFirst: {
            args: Prisma.SupplierItemPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierItemPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>
          }
          findMany: {
            args: Prisma.SupplierItemPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>[]
          }
          create: {
            args: Prisma.SupplierItemPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>
          }
          createMany: {
            args: Prisma.SupplierItemPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierItemPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>[]
          }
          delete: {
            args: Prisma.SupplierItemPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>
          }
          update: {
            args: Prisma.SupplierItemPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>
          }
          deleteMany: {
            args: Prisma.SupplierItemPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierItemPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierItemPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierItemPricePayload>
          }
          aggregate: {
            args: Prisma.SupplierItemPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierItemPrice>
          }
          groupBy: {
            args: Prisma.SupplierItemPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierItemPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierItemPriceCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierItemPriceCountAggregateOutputType> | number
          }
        }
      }
      CustomerItemPrice: {
        payload: Prisma.$CustomerItemPricePayload<ExtArgs>
        fields: Prisma.CustomerItemPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerItemPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerItemPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>
          }
          findFirst: {
            args: Prisma.CustomerItemPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerItemPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>
          }
          findMany: {
            args: Prisma.CustomerItemPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>[]
          }
          create: {
            args: Prisma.CustomerItemPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>
          }
          createMany: {
            args: Prisma.CustomerItemPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerItemPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>[]
          }
          delete: {
            args: Prisma.CustomerItemPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>
          }
          update: {
            args: Prisma.CustomerItemPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>
          }
          deleteMany: {
            args: Prisma.CustomerItemPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerItemPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerItemPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerItemPricePayload>
          }
          aggregate: {
            args: Prisma.CustomerItemPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerItemPrice>
          }
          groupBy: {
            args: Prisma.CustomerItemPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerItemPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerItemPriceCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerItemPriceCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderLine: {
        payload: Prisma.$PurchaseOrderLinePayload<ExtArgs>
        fields: Prisma.PurchaseOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          update: {
            args: Prisma.PurchaseOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderLine>
          }
          groupBy: {
            args: Prisma.PurchaseOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineCountAggregateOutputType> | number
          }
        }
      }
      SalesOrder: {
        payload: Prisma.$SalesOrderPayload<ExtArgs>
        fields: Prisma.SalesOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findFirst: {
            args: Prisma.SalesOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findMany: {
            args: Prisma.SalesOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          create: {
            args: Prisma.SalesOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          createMany: {
            args: Prisma.SalesOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          delete: {
            args: Prisma.SalesOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          update: {
            args: Prisma.SalesOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          aggregate: {
            args: Prisma.SalesOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrder>
          }
          groupBy: {
            args: Prisma.SalesOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderCountAggregateOutputType> | number
          }
        }
      }
      SalesOrderLine: {
        payload: Prisma.$SalesOrderLinePayload<ExtArgs>
        fields: Prisma.SalesOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          findFirst: {
            args: Prisma.SalesOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          findMany: {
            args: Prisma.SalesOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          create: {
            args: Prisma.SalesOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          createMany: {
            args: Prisma.SalesOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          delete: {
            args: Prisma.SalesOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          update: {
            args: Prisma.SalesOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          aggregate: {
            args: Prisma.SalesOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrderLine>
          }
          groupBy: {
            args: Prisma.SalesOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderLineCountAggregateOutputType> | number
          }
        }
      }
      Dispatch: {
        payload: Prisma.$DispatchPayload<ExtArgs>
        fields: Prisma.DispatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>
          }
          findFirst: {
            args: Prisma.DispatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>
          }
          findMany: {
            args: Prisma.DispatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>[]
          }
          create: {
            args: Prisma.DispatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>
          }
          createMany: {
            args: Prisma.DispatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>[]
          }
          delete: {
            args: Prisma.DispatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>
          }
          update: {
            args: Prisma.DispatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>
          }
          deleteMany: {
            args: Prisma.DispatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DispatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispatchPayload>
          }
          aggregate: {
            args: Prisma.DispatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispatch>
          }
          groupBy: {
            args: Prisma.DispatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispatchCountArgs<ExtArgs>
            result: $Utils.Optional<DispatchCountAggregateOutputType> | number
          }
        }
      }
      ProductionDay: {
        payload: Prisma.$ProductionDayPayload<ExtArgs>
        fields: Prisma.ProductionDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>
          }
          findFirst: {
            args: Prisma.ProductionDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>
          }
          findMany: {
            args: Prisma.ProductionDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>[]
          }
          create: {
            args: Prisma.ProductionDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>
          }
          createMany: {
            args: Prisma.ProductionDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>[]
          }
          delete: {
            args: Prisma.ProductionDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>
          }
          update: {
            args: Prisma.ProductionDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>
          }
          deleteMany: {
            args: Prisma.ProductionDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductionDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionDayPayload>
          }
          aggregate: {
            args: Prisma.ProductionDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionDay>
          }
          groupBy: {
            args: Prisma.ProductionDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionDayCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionDayCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      StockBalance: {
        payload: Prisma.$StockBalancePayload<ExtArgs>
        fields: Prisma.StockBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>
          }
          findFirst: {
            args: Prisma.StockBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>
          }
          findMany: {
            args: Prisma.StockBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>[]
          }
          create: {
            args: Prisma.StockBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>
          }
          createMany: {
            args: Prisma.StockBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>[]
          }
          delete: {
            args: Prisma.StockBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>
          }
          update: {
            args: Prisma.StockBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>
          }
          deleteMany: {
            args: Prisma.StockBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBalancePayload>
          }
          aggregate: {
            args: Prisma.StockBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockBalance>
          }
          groupBy: {
            args: Prisma.StockBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<StockBalanceCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      CashTransaction: {
        payload: Prisma.$CashTransactionPayload<ExtArgs>
        fields: Prisma.CashTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findFirst: {
            args: Prisma.CashTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findMany: {
            args: Prisma.CashTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          create: {
            args: Prisma.CashTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          createMany: {
            args: Prisma.CashTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          delete: {
            args: Prisma.CashTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          update: {
            args: Prisma.CashTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CashTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          aggregate: {
            args: Prisma.CashTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashTransaction>
          }
          groupBy: {
            args: Prisma.CashTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    recordedAttendances: number
    attendances: number
    cashTransactions: number
    dispatches: number
    expenses: number
    invoicesCreated: number
    invoicesMatched: number
    payments: number
    productionDaysClosed: number
    productionDaysCreated: number
    productionDaysReopened: number
    purchaseOrders: number
    salaryPaymentsPaid: number
    salaryRecords: number
    salesOrders: number
    stockMovements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedAttendances?: boolean | UserCountOutputTypeCountRecordedAttendancesArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    cashTransactions?: boolean | UserCountOutputTypeCountCashTransactionsArgs
    dispatches?: boolean | UserCountOutputTypeCountDispatchesArgs
    expenses?: boolean | UserCountOutputTypeCountExpensesArgs
    invoicesCreated?: boolean | UserCountOutputTypeCountInvoicesCreatedArgs
    invoicesMatched?: boolean | UserCountOutputTypeCountInvoicesMatchedArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    productionDaysClosed?: boolean | UserCountOutputTypeCountProductionDaysClosedArgs
    productionDaysCreated?: boolean | UserCountOutputTypeCountProductionDaysCreatedArgs
    productionDaysReopened?: boolean | UserCountOutputTypeCountProductionDaysReopenedArgs
    purchaseOrders?: boolean | UserCountOutputTypeCountPurchaseOrdersArgs
    salaryPaymentsPaid?: boolean | UserCountOutputTypeCountSalaryPaymentsPaidArgs
    salaryRecords?: boolean | UserCountOutputTypeCountSalaryRecordsArgs
    salesOrders?: boolean | UserCountOutputTypeCountSalesOrdersArgs
    stockMovements?: boolean | UserCountOutputTypeCountStockMovementsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecordedAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesMatchedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionDaysClosedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionDaysCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductionDaysReopenedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDayWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryPaymentsPaidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }


  /**
   * Count Type SalaryRangeCountOutputType
   */

  export type SalaryRangeCountOutputType = {
    employeeProfiles: number
  }

  export type SalaryRangeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeProfiles?: boolean | SalaryRangeCountOutputTypeCountEmployeeProfilesArgs
  }

  // Custom InputTypes
  /**
   * SalaryRangeCountOutputType without action
   */
  export type SalaryRangeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRangeCountOutputType
     */
    select?: SalaryRangeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalaryRangeCountOutputType without action
   */
  export type SalaryRangeCountOutputTypeCountEmployeeProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
  }


  /**
   * Count Type SalaryPeriodCountOutputType
   */

  export type SalaryPeriodCountOutputType = {
    salaryRecords: number
  }

  export type SalaryPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salaryRecords?: boolean | SalaryPeriodCountOutputTypeCountSalaryRecordsArgs
  }

  // Custom InputTypes
  /**
   * SalaryPeriodCountOutputType without action
   */
  export type SalaryPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriodCountOutputType
     */
    select?: SalaryPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalaryPeriodCountOutputType without action
   */
  export type SalaryPeriodCountOutputTypeCountSalaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRecordWhereInput
  }


  /**
   * Count Type SalaryRecordCountOutputType
   */

  export type SalaryRecordCountOutputType = {
    payments: number
  }

  export type SalaryRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SalaryRecordCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SalaryRecordCountOutputType without action
   */
  export type SalaryRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecordCountOutputType
     */
    select?: SalaryRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalaryRecordCountOutputType without action
   */
  export type SalaryRecordCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    items: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | UnitCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemCategoryCountOutputType
   */

  export type ItemCategoryCountOutputType = {
    items: number
  }

  export type ItemCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemCategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    customerPrices: number
    invoiceLines: number
    productionDays: number
    purchaseOrderLines: number
    salesOrderLines: number
    stockMovements: number
    supplierPrices: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerPrices?: boolean | ItemCountOutputTypeCountCustomerPricesArgs
    invoiceLines?: boolean | ItemCountOutputTypeCountInvoiceLinesArgs
    productionDays?: boolean | ItemCountOutputTypeCountProductionDaysArgs
    purchaseOrderLines?: boolean | ItemCountOutputTypeCountPurchaseOrderLinesArgs
    salesOrderLines?: boolean | ItemCountOutputTypeCountSalesOrderLinesArgs
    stockMovements?: boolean | ItemCountOutputTypeCountStockMovementsArgs
    supplierPrices?: boolean | ItemCountOutputTypeCountSupplierPricesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountCustomerPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemPriceWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInvoiceLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountProductionDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDayWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPurchaseOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSalesOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSupplierPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierItemPriceWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    expenses: number
    invoices: number
    purchaseOrders: number
    itemPrices: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | SupplierCountOutputTypeCountExpensesArgs
    invoices?: boolean | SupplierCountOutputTypeCountInvoicesArgs
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
    itemPrices?: boolean | SupplierCountOutputTypeCountItemPricesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountItemPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierItemPriceWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    itemPrices: number
    invoices: number
    salesOrders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemPrices?: boolean | CustomerCountOutputTypeCountItemPricesArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    salesOrders?: boolean | CustomerCountOutputTypeCountSalesOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountItemPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemPriceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    invoices: number
    lines: number
    stockMovements: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | PurchaseOrderCountOutputTypeCountInvoicesArgs
    lines?: boolean | PurchaseOrderCountOutputTypeCountLinesArgs
    stockMovements?: boolean | PurchaseOrderCountOutputTypeCountStockMovementsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }


  /**
   * Count Type SalesOrderCountOutputType
   */

  export type SalesOrderCountOutputType = {
    dispatches: number
    invoices: number
    lines: number
  }

  export type SalesOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispatches?: boolean | SalesOrderCountOutputTypeCountDispatchesArgs
    invoices?: boolean | SalesOrderCountOutputTypeCountInvoicesArgs
    lines?: boolean | SalesOrderCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderCountOutputType
     */
    select?: SalesOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountDispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchWhereInput
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lines: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceCountOutputTypeCountLinesArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    roleId: number | null
  }

  export type RoleSumAggregateOutputType = {
    roleId: number | null
  }

  export type RoleMinAggregateOutputType = {
    roleId: number | null
    roleName: $Enums.RoleName | null
    idPrefix: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    roleId: number | null
    roleName: $Enums.RoleName | null
    idPrefix: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    roleId: number
    roleName: number
    idPrefix: number
    description: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    roleId?: true
  }

  export type RoleSumAggregateInputType = {
    roleId?: true
  }

  export type RoleMinAggregateInputType = {
    roleId?: true
    roleName?: true
    idPrefix?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    roleId?: true
    roleName?: true
    idPrefix?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    roleId?: true
    roleName?: true
    idPrefix?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    roleId: number
    roleName: $Enums.RoleName
    idPrefix: string
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    roleName?: boolean
    idPrefix?: boolean
    description?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    roleName?: boolean
    idPrefix?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    roleId?: boolean
    roleName?: boolean
    idPrefix?: boolean
    description?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      roleName: $Enums.RoleName
      idPrefix: string
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const roleWithRoleIdOnly = await prisma.role.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `roleId`
     * const roleWithRoleIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly roleId: FieldRef<"Role", 'Int'>
    readonly roleName: FieldRef<"Role", 'RoleName'>
    readonly idPrefix: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    userId: bigint | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    userId: bigint | null
    userCode: string | null
    roleId: number | null
    fullName: string | null
    username: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    userId: bigint | null
    userCode: string | null
    roleId: number | null
    fullName: string | null
    username: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    userId: number
    userCode: number
    roleId: number
    fullName: number
    username: number
    email: number
    phone: number
    passwordHash: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    userId?: true
    userCode?: true
    roleId?: true
    fullName?: true
    username?: true
    email?: true
    phone?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    userId?: true
    userCode?: true
    roleId?: true
    fullName?: true
    username?: true
    email?: true
    phone?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    userId?: true
    userCode?: true
    roleId?: true
    fullName?: true
    username?: true
    email?: true
    phone?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    userId: bigint
    userCode: string
    roleId: number
    fullName: string
    username: string | null
    email: string | null
    phone: string | null
    passwordHash: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    userCode?: boolean
    roleId?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recordedAttendances?: boolean | User$recordedAttendancesArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    cashTransactions?: boolean | User$cashTransactionsArgs<ExtArgs>
    dispatches?: boolean | User$dispatchesArgs<ExtArgs>
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    expenses?: boolean | User$expensesArgs<ExtArgs>
    invoicesCreated?: boolean | User$invoicesCreatedArgs<ExtArgs>
    invoicesMatched?: boolean | User$invoicesMatchedArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    productionDaysClosed?: boolean | User$productionDaysClosedArgs<ExtArgs>
    productionDaysCreated?: boolean | User$productionDaysCreatedArgs<ExtArgs>
    productionDaysReopened?: boolean | User$productionDaysReopenedArgs<ExtArgs>
    purchaseOrders?: boolean | User$purchaseOrdersArgs<ExtArgs>
    salaryPaymentsPaid?: boolean | User$salaryPaymentsPaidArgs<ExtArgs>
    salaryRecords?: boolean | User$salaryRecordsArgs<ExtArgs>
    salesOrders?: boolean | User$salesOrdersArgs<ExtArgs>
    stockMovements?: boolean | User$stockMovementsArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    userCode?: boolean
    roleId?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    userId?: boolean
    userCode?: boolean
    roleId?: boolean
    fullName?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recordedAttendances?: boolean | User$recordedAttendancesArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    cashTransactions?: boolean | User$cashTransactionsArgs<ExtArgs>
    dispatches?: boolean | User$dispatchesArgs<ExtArgs>
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    expenses?: boolean | User$expensesArgs<ExtArgs>
    invoicesCreated?: boolean | User$invoicesCreatedArgs<ExtArgs>
    invoicesMatched?: boolean | User$invoicesMatchedArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    productionDaysClosed?: boolean | User$productionDaysClosedArgs<ExtArgs>
    productionDaysCreated?: boolean | User$productionDaysCreatedArgs<ExtArgs>
    productionDaysReopened?: boolean | User$productionDaysReopenedArgs<ExtArgs>
    purchaseOrders?: boolean | User$purchaseOrdersArgs<ExtArgs>
    salaryPaymentsPaid?: boolean | User$salaryPaymentsPaidArgs<ExtArgs>
    salaryRecords?: boolean | User$salaryRecordsArgs<ExtArgs>
    salesOrders?: boolean | User$salesOrdersArgs<ExtArgs>
    stockMovements?: boolean | User$stockMovementsArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      recordedAttendances: Prisma.$AttendanceDailyPayload<ExtArgs>[]
      attendances: Prisma.$AttendanceDailyPayload<ExtArgs>[]
      cashTransactions: Prisma.$CashTransactionPayload<ExtArgs>[]
      dispatches: Prisma.$DispatchPayload<ExtArgs>[]
      employeeProfile: Prisma.$EmployeeProfilePayload<ExtArgs> | null
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      invoicesCreated: Prisma.$InvoicePayload<ExtArgs>[]
      invoicesMatched: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      productionDaysClosed: Prisma.$ProductionDayPayload<ExtArgs>[]
      productionDaysCreated: Prisma.$ProductionDayPayload<ExtArgs>[]
      productionDaysReopened: Prisma.$ProductionDayPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      salaryPaymentsPaid: Prisma.$SalaryPaymentPayload<ExtArgs>[]
      salaryRecords: Prisma.$SalaryRecordPayload<ExtArgs>[]
      salesOrders: Prisma.$SalesOrderPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: bigint
      userCode: string
      roleId: number
      fullName: string
      username: string | null
      email: string | null
      phone: string | null
      passwordHash: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWithUserIdOnly = await prisma.user.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `userId`
     * const userWithUserIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recordedAttendances<T extends User$recordedAttendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$recordedAttendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findMany"> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findMany"> | Null>
    cashTransactions<T extends User$cashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    dispatches<T extends User$dispatchesArgs<ExtArgs> = {}>(args?: Subset<T, User$dispatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findMany"> | Null>
    employeeProfile<T extends User$employeeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeProfileArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    expenses<T extends User$expensesArgs<ExtArgs> = {}>(args?: Subset<T, User$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    invoicesCreated<T extends User$invoicesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    invoicesMatched<T extends User$invoicesMatchedArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesMatchedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    productionDaysClosed<T extends User$productionDaysClosedArgs<ExtArgs> = {}>(args?: Subset<T, User$productionDaysClosedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findMany"> | Null>
    productionDaysCreated<T extends User$productionDaysCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$productionDaysCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findMany"> | Null>
    productionDaysReopened<T extends User$productionDaysReopenedArgs<ExtArgs> = {}>(args?: Subset<T, User$productionDaysReopenedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends User$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    salaryPaymentsPaid<T extends User$salaryPaymentsPaidArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryPaymentsPaidArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    salaryRecords<T extends User$salaryRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findMany"> | Null>
    salesOrders<T extends User$salesOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$salesOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends User$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly userId: FieldRef<"User", 'BigInt'>
    readonly userCode: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.recordedAttendances
   */
  export type User$recordedAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    where?: AttendanceDailyWhereInput
    orderBy?: AttendanceDailyOrderByWithRelationInput | AttendanceDailyOrderByWithRelationInput[]
    cursor?: AttendanceDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailyScalarFieldEnum | AttendanceDailyScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    where?: AttendanceDailyWhereInput
    orderBy?: AttendanceDailyOrderByWithRelationInput | AttendanceDailyOrderByWithRelationInput[]
    cursor?: AttendanceDailyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceDailyScalarFieldEnum | AttendanceDailyScalarFieldEnum[]
  }

  /**
   * User.cashTransactions
   */
  export type User$cashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * User.dispatches
   */
  export type User$dispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    where?: DispatchWhereInput
    orderBy?: DispatchOrderByWithRelationInput | DispatchOrderByWithRelationInput[]
    cursor?: DispatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchScalarFieldEnum | DispatchScalarFieldEnum[]
  }

  /**
   * User.employeeProfile
   */
  export type User$employeeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
  }

  /**
   * User.expenses
   */
  export type User$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * User.invoicesCreated
   */
  export type User$invoicesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.invoicesMatched
   */
  export type User$invoicesMatchedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.productionDaysClosed
   */
  export type User$productionDaysClosedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    where?: ProductionDayWhereInput
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    cursor?: ProductionDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * User.productionDaysCreated
   */
  export type User$productionDaysCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    where?: ProductionDayWhereInput
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    cursor?: ProductionDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * User.productionDaysReopened
   */
  export type User$productionDaysReopenedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    where?: ProductionDayWhereInput
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    cursor?: ProductionDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * User.purchaseOrders
   */
  export type User$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User.salaryPaymentsPaid
   */
  export type User$salaryPaymentsPaidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    cursor?: SalaryPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * User.salaryRecords
   */
  export type User$salaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    where?: SalaryRecordWhereInput
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    cursor?: SalaryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * User.salesOrders
   */
  export type User$salesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * User.stockMovements
   */
  export type User$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SalaryRange
   */

  export type AggregateSalaryRange = {
    _count: SalaryRangeCountAggregateOutputType | null
    _avg: SalaryRangeAvgAggregateOutputType | null
    _sum: SalaryRangeSumAggregateOutputType | null
    _min: SalaryRangeMinAggregateOutputType | null
    _max: SalaryRangeMaxAggregateOutputType | null
  }

  export type SalaryRangeAvgAggregateOutputType = {
    salaryRangeId: number | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
  }

  export type SalaryRangeSumAggregateOutputType = {
    salaryRangeId: bigint | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
  }

  export type SalaryRangeMinAggregateOutputType = {
    salaryRangeId: bigint | null
    rangeName: string | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SalaryRangeMaxAggregateOutputType = {
    salaryRangeId: bigint | null
    rangeName: string | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type SalaryRangeCountAggregateOutputType = {
    salaryRangeId: number
    rangeName: number
    minSalary: number
    maxSalary: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type SalaryRangeAvgAggregateInputType = {
    salaryRangeId?: true
    minSalary?: true
    maxSalary?: true
  }

  export type SalaryRangeSumAggregateInputType = {
    salaryRangeId?: true
    minSalary?: true
    maxSalary?: true
  }

  export type SalaryRangeMinAggregateInputType = {
    salaryRangeId?: true
    rangeName?: true
    minSalary?: true
    maxSalary?: true
    isActive?: true
    createdAt?: true
  }

  export type SalaryRangeMaxAggregateInputType = {
    salaryRangeId?: true
    rangeName?: true
    minSalary?: true
    maxSalary?: true
    isActive?: true
    createdAt?: true
  }

  export type SalaryRangeCountAggregateInputType = {
    salaryRangeId?: true
    rangeName?: true
    minSalary?: true
    maxSalary?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type SalaryRangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRange to aggregate.
     */
    where?: SalaryRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRanges to fetch.
     */
    orderBy?: SalaryRangeOrderByWithRelationInput | SalaryRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryRanges
    **/
    _count?: true | SalaryRangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryRangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryRangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryRangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryRangeMaxAggregateInputType
  }

  export type GetSalaryRangeAggregateType<T extends SalaryRangeAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryRange[P]>
      : GetScalarType<T[P], AggregateSalaryRange[P]>
  }




  export type SalaryRangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRangeWhereInput
    orderBy?: SalaryRangeOrderByWithAggregationInput | SalaryRangeOrderByWithAggregationInput[]
    by: SalaryRangeScalarFieldEnum[] | SalaryRangeScalarFieldEnum
    having?: SalaryRangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryRangeCountAggregateInputType | true
    _avg?: SalaryRangeAvgAggregateInputType
    _sum?: SalaryRangeSumAggregateInputType
    _min?: SalaryRangeMinAggregateInputType
    _max?: SalaryRangeMaxAggregateInputType
  }

  export type SalaryRangeGroupByOutputType = {
    salaryRangeId: bigint
    rangeName: string
    minSalary: Decimal
    maxSalary: Decimal
    isActive: boolean
    createdAt: Date
    _count: SalaryRangeCountAggregateOutputType | null
    _avg: SalaryRangeAvgAggregateOutputType | null
    _sum: SalaryRangeSumAggregateOutputType | null
    _min: SalaryRangeMinAggregateOutputType | null
    _max: SalaryRangeMaxAggregateOutputType | null
  }

  type GetSalaryRangeGroupByPayload<T extends SalaryRangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryRangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryRangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryRangeGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryRangeGroupByOutputType[P]>
        }
      >
    >


  export type SalaryRangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salaryRangeId?: boolean
    rangeName?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
    employeeProfiles?: boolean | SalaryRange$employeeProfilesArgs<ExtArgs>
    _count?: boolean | SalaryRangeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRange"]>

  export type SalaryRangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salaryRangeId?: boolean
    rangeName?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["salaryRange"]>

  export type SalaryRangeSelectScalar = {
    salaryRangeId?: boolean
    rangeName?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type SalaryRangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeProfiles?: boolean | SalaryRange$employeeProfilesArgs<ExtArgs>
    _count?: boolean | SalaryRangeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalaryRangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SalaryRangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryRange"
    objects: {
      employeeProfiles: Prisma.$EmployeeProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      salaryRangeId: bigint
      rangeName: string
      minSalary: Prisma.Decimal
      maxSalary: Prisma.Decimal
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["salaryRange"]>
    composites: {}
  }

  type SalaryRangeGetPayload<S extends boolean | null | undefined | SalaryRangeDefaultArgs> = $Result.GetResult<Prisma.$SalaryRangePayload, S>

  type SalaryRangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryRangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryRangeCountAggregateInputType | true
    }

  export interface SalaryRangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryRange'], meta: { name: 'SalaryRange' } }
    /**
     * Find zero or one SalaryRange that matches the filter.
     * @param {SalaryRangeFindUniqueArgs} args - Arguments to find a SalaryRange
     * @example
     * // Get one SalaryRange
     * const salaryRange = await prisma.salaryRange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryRangeFindUniqueArgs>(args: SelectSubset<T, SalaryRangeFindUniqueArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalaryRange that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryRangeFindUniqueOrThrowArgs} args - Arguments to find a SalaryRange
     * @example
     * // Get one SalaryRange
     * const salaryRange = await prisma.salaryRange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryRangeFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryRangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalaryRange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeFindFirstArgs} args - Arguments to find a SalaryRange
     * @example
     * // Get one SalaryRange
     * const salaryRange = await prisma.salaryRange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryRangeFindFirstArgs>(args?: SelectSubset<T, SalaryRangeFindFirstArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalaryRange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeFindFirstOrThrowArgs} args - Arguments to find a SalaryRange
     * @example
     * // Get one SalaryRange
     * const salaryRange = await prisma.salaryRange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryRangeFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryRangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalaryRanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryRanges
     * const salaryRanges = await prisma.salaryRange.findMany()
     * 
     * // Get first 10 SalaryRanges
     * const salaryRanges = await prisma.salaryRange.findMany({ take: 10 })
     * 
     * // Only select the `salaryRangeId`
     * const salaryRangeWithSalaryRangeIdOnly = await prisma.salaryRange.findMany({ select: { salaryRangeId: true } })
     * 
     */
    findMany<T extends SalaryRangeFindManyArgs>(args?: SelectSubset<T, SalaryRangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalaryRange.
     * @param {SalaryRangeCreateArgs} args - Arguments to create a SalaryRange.
     * @example
     * // Create one SalaryRange
     * const SalaryRange = await prisma.salaryRange.create({
     *   data: {
     *     // ... data to create a SalaryRange
     *   }
     * })
     * 
     */
    create<T extends SalaryRangeCreateArgs>(args: SelectSubset<T, SalaryRangeCreateArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalaryRanges.
     * @param {SalaryRangeCreateManyArgs} args - Arguments to create many SalaryRanges.
     * @example
     * // Create many SalaryRanges
     * const salaryRange = await prisma.salaryRange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryRangeCreateManyArgs>(args?: SelectSubset<T, SalaryRangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryRanges and returns the data saved in the database.
     * @param {SalaryRangeCreateManyAndReturnArgs} args - Arguments to create many SalaryRanges.
     * @example
     * // Create many SalaryRanges
     * const salaryRange = await prisma.salaryRange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryRanges and only return the `salaryRangeId`
     * const salaryRangeWithSalaryRangeIdOnly = await prisma.salaryRange.createManyAndReturn({ 
     *   select: { salaryRangeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryRangeCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryRangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalaryRange.
     * @param {SalaryRangeDeleteArgs} args - Arguments to delete one SalaryRange.
     * @example
     * // Delete one SalaryRange
     * const SalaryRange = await prisma.salaryRange.delete({
     *   where: {
     *     // ... filter to delete one SalaryRange
     *   }
     * })
     * 
     */
    delete<T extends SalaryRangeDeleteArgs>(args: SelectSubset<T, SalaryRangeDeleteArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalaryRange.
     * @param {SalaryRangeUpdateArgs} args - Arguments to update one SalaryRange.
     * @example
     * // Update one SalaryRange
     * const salaryRange = await prisma.salaryRange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryRangeUpdateArgs>(args: SelectSubset<T, SalaryRangeUpdateArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalaryRanges.
     * @param {SalaryRangeDeleteManyArgs} args - Arguments to filter SalaryRanges to delete.
     * @example
     * // Delete a few SalaryRanges
     * const { count } = await prisma.salaryRange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryRangeDeleteManyArgs>(args?: SelectSubset<T, SalaryRangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryRanges
     * const salaryRange = await prisma.salaryRange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryRangeUpdateManyArgs>(args: SelectSubset<T, SalaryRangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryRange.
     * @param {SalaryRangeUpsertArgs} args - Arguments to update or create a SalaryRange.
     * @example
     * // Update or create a SalaryRange
     * const salaryRange = await prisma.salaryRange.upsert({
     *   create: {
     *     // ... data to create a SalaryRange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryRange we want to update
     *   }
     * })
     */
    upsert<T extends SalaryRangeUpsertArgs>(args: SelectSubset<T, SalaryRangeUpsertArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalaryRanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeCountArgs} args - Arguments to filter SalaryRanges to count.
     * @example
     * // Count the number of SalaryRanges
     * const count = await prisma.salaryRange.count({
     *   where: {
     *     // ... the filter for the SalaryRanges we want to count
     *   }
     * })
    **/
    count<T extends SalaryRangeCountArgs>(
      args?: Subset<T, SalaryRangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryRangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryRangeAggregateArgs>(args: Subset<T, SalaryRangeAggregateArgs>): Prisma.PrismaPromise<GetSalaryRangeAggregateType<T>>

    /**
     * Group by SalaryRange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryRangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryRangeGroupByArgs['orderBy'] }
        : { orderBy?: SalaryRangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryRangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryRangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryRange model
   */
  readonly fields: SalaryRangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryRange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryRangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeProfiles<T extends SalaryRange$employeeProfilesArgs<ExtArgs> = {}>(args?: Subset<T, SalaryRange$employeeProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryRange model
   */ 
  interface SalaryRangeFieldRefs {
    readonly salaryRangeId: FieldRef<"SalaryRange", 'BigInt'>
    readonly rangeName: FieldRef<"SalaryRange", 'String'>
    readonly minSalary: FieldRef<"SalaryRange", 'Decimal'>
    readonly maxSalary: FieldRef<"SalaryRange", 'Decimal'>
    readonly isActive: FieldRef<"SalaryRange", 'Boolean'>
    readonly createdAt: FieldRef<"SalaryRange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryRange findUnique
   */
  export type SalaryRangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRange to fetch.
     */
    where: SalaryRangeWhereUniqueInput
  }

  /**
   * SalaryRange findUniqueOrThrow
   */
  export type SalaryRangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRange to fetch.
     */
    where: SalaryRangeWhereUniqueInput
  }

  /**
   * SalaryRange findFirst
   */
  export type SalaryRangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRange to fetch.
     */
    where?: SalaryRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRanges to fetch.
     */
    orderBy?: SalaryRangeOrderByWithRelationInput | SalaryRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRanges.
     */
    cursor?: SalaryRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRanges.
     */
    distinct?: SalaryRangeScalarFieldEnum | SalaryRangeScalarFieldEnum[]
  }

  /**
   * SalaryRange findFirstOrThrow
   */
  export type SalaryRangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRange to fetch.
     */
    where?: SalaryRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRanges to fetch.
     */
    orderBy?: SalaryRangeOrderByWithRelationInput | SalaryRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRanges.
     */
    cursor?: SalaryRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRanges.
     */
    distinct?: SalaryRangeScalarFieldEnum | SalaryRangeScalarFieldEnum[]
  }

  /**
   * SalaryRange findMany
   */
  export type SalaryRangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRanges to fetch.
     */
    where?: SalaryRangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRanges to fetch.
     */
    orderBy?: SalaryRangeOrderByWithRelationInput | SalaryRangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryRanges.
     */
    cursor?: SalaryRangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRanges.
     */
    skip?: number
    distinct?: SalaryRangeScalarFieldEnum | SalaryRangeScalarFieldEnum[]
  }

  /**
   * SalaryRange create
   */
  export type SalaryRangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryRange.
     */
    data: XOR<SalaryRangeCreateInput, SalaryRangeUncheckedCreateInput>
  }

  /**
   * SalaryRange createMany
   */
  export type SalaryRangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryRanges.
     */
    data: SalaryRangeCreateManyInput | SalaryRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryRange createManyAndReturn
   */
  export type SalaryRangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalaryRanges.
     */
    data: SalaryRangeCreateManyInput | SalaryRangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryRange update
   */
  export type SalaryRangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryRange.
     */
    data: XOR<SalaryRangeUpdateInput, SalaryRangeUncheckedUpdateInput>
    /**
     * Choose, which SalaryRange to update.
     */
    where: SalaryRangeWhereUniqueInput
  }

  /**
   * SalaryRange updateMany
   */
  export type SalaryRangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryRanges.
     */
    data: XOR<SalaryRangeUpdateManyMutationInput, SalaryRangeUncheckedUpdateManyInput>
    /**
     * Filter which SalaryRanges to update
     */
    where?: SalaryRangeWhereInput
  }

  /**
   * SalaryRange upsert
   */
  export type SalaryRangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryRange to update in case it exists.
     */
    where: SalaryRangeWhereUniqueInput
    /**
     * In case the SalaryRange found by the `where` argument doesn't exist, create a new SalaryRange with this data.
     */
    create: XOR<SalaryRangeCreateInput, SalaryRangeUncheckedCreateInput>
    /**
     * In case the SalaryRange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryRangeUpdateInput, SalaryRangeUncheckedUpdateInput>
  }

  /**
   * SalaryRange delete
   */
  export type SalaryRangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    /**
     * Filter which SalaryRange to delete.
     */
    where: SalaryRangeWhereUniqueInput
  }

  /**
   * SalaryRange deleteMany
   */
  export type SalaryRangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRanges to delete
     */
    where?: SalaryRangeWhereInput
  }

  /**
   * SalaryRange.employeeProfiles
   */
  export type SalaryRange$employeeProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    cursor?: EmployeeProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * SalaryRange without action
   */
  export type SalaryRangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeProfile
   */

  export type AggregateEmployeeProfile = {
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  export type EmployeeProfileAvgAggregateOutputType = {
    userId: number | null
    basicSalary: Decimal | null
    salaryRangeId: number | null
    otRate: Decimal | null
  }

  export type EmployeeProfileSumAggregateOutputType = {
    userId: bigint | null
    basicSalary: Decimal | null
    salaryRangeId: bigint | null
    otRate: Decimal | null
  }

  export type EmployeeProfileMinAggregateOutputType = {
    userId: bigint | null
    nic: string | null
    address: string | null
    joinedDate: Date | null
    designation: string | null
    basicSalary: Decimal | null
    salaryRangeId: bigint | null
    otRate: Decimal | null
    notes: string | null
  }

  export type EmployeeProfileMaxAggregateOutputType = {
    userId: bigint | null
    nic: string | null
    address: string | null
    joinedDate: Date | null
    designation: string | null
    basicSalary: Decimal | null
    salaryRangeId: bigint | null
    otRate: Decimal | null
    notes: string | null
  }

  export type EmployeeProfileCountAggregateOutputType = {
    userId: number
    nic: number
    address: number
    joinedDate: number
    designation: number
    basicSalary: number
    salaryRangeId: number
    otRate: number
    notes: number
    _all: number
  }


  export type EmployeeProfileAvgAggregateInputType = {
    userId?: true
    basicSalary?: true
    salaryRangeId?: true
    otRate?: true
  }

  export type EmployeeProfileSumAggregateInputType = {
    userId?: true
    basicSalary?: true
    salaryRangeId?: true
    otRate?: true
  }

  export type EmployeeProfileMinAggregateInputType = {
    userId?: true
    nic?: true
    address?: true
    joinedDate?: true
    designation?: true
    basicSalary?: true
    salaryRangeId?: true
    otRate?: true
    notes?: true
  }

  export type EmployeeProfileMaxAggregateInputType = {
    userId?: true
    nic?: true
    address?: true
    joinedDate?: true
    designation?: true
    basicSalary?: true
    salaryRangeId?: true
    otRate?: true
    notes?: true
  }

  export type EmployeeProfileCountAggregateInputType = {
    userId?: true
    nic?: true
    address?: true
    joinedDate?: true
    designation?: true
    basicSalary?: true
    salaryRangeId?: true
    otRate?: true
    notes?: true
    _all?: true
  }

  export type EmployeeProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfile to aggregate.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeProfiles
    **/
    _count?: true | EmployeeProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type GetEmployeeProfileAggregateType<T extends EmployeeProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeProfile[P]>
      : GetScalarType<T[P], AggregateEmployeeProfile[P]>
  }




  export type EmployeeProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithAggregationInput | EmployeeProfileOrderByWithAggregationInput[]
    by: EmployeeProfileScalarFieldEnum[] | EmployeeProfileScalarFieldEnum
    having?: EmployeeProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeProfileCountAggregateInputType | true
    _avg?: EmployeeProfileAvgAggregateInputType
    _sum?: EmployeeProfileSumAggregateInputType
    _min?: EmployeeProfileMinAggregateInputType
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type EmployeeProfileGroupByOutputType = {
    userId: bigint
    nic: string | null
    address: string | null
    joinedDate: Date | null
    designation: string | null
    basicSalary: Decimal
    salaryRangeId: bigint | null
    otRate: Decimal
    notes: string | null
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  type GetEmployeeProfileGroupByPayload<T extends EmployeeProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    nic?: boolean
    address?: boolean
    joinedDate?: boolean
    designation?: boolean
    basicSalary?: boolean
    salaryRangeId?: boolean
    otRate?: boolean
    notes?: boolean
    salaryRange?: boolean | EmployeeProfile$salaryRangeArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    nic?: boolean
    address?: boolean
    joinedDate?: boolean
    designation?: boolean
    basicSalary?: boolean
    salaryRangeId?: boolean
    otRate?: boolean
    notes?: boolean
    salaryRange?: boolean | EmployeeProfile$salaryRangeArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectScalar = {
    userId?: boolean
    nic?: boolean
    address?: boolean
    joinedDate?: boolean
    designation?: boolean
    basicSalary?: boolean
    salaryRangeId?: boolean
    otRate?: boolean
    notes?: boolean
  }

  export type EmployeeProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salaryRange?: boolean | EmployeeProfile$salaryRangeArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salaryRange?: boolean | EmployeeProfile$salaryRangeArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeProfile"
    objects: {
      salaryRange: Prisma.$SalaryRangePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: bigint
      nic: string | null
      address: string | null
      joinedDate: Date | null
      designation: string | null
      basicSalary: Prisma.Decimal
      salaryRangeId: bigint | null
      otRate: Prisma.Decimal
      notes: string | null
    }, ExtArgs["result"]["employeeProfile"]>
    composites: {}
  }

  type EmployeeProfileGetPayload<S extends boolean | null | undefined | EmployeeProfileDefaultArgs> = $Result.GetResult<Prisma.$EmployeeProfilePayload, S>

  type EmployeeProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeProfileCountAggregateInputType | true
    }

  export interface EmployeeProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeProfile'], meta: { name: 'EmployeeProfile' } }
    /**
     * Find zero or one EmployeeProfile that matches the filter.
     * @param {EmployeeProfileFindUniqueArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeProfileFindUniqueArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeProfileFindUniqueOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeProfileFindFirstArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany()
     * 
     * // Get first 10 EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const employeeProfileWithUserIdOnly = await prisma.employeeProfile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends EmployeeProfileFindManyArgs>(args?: SelectSubset<T, EmployeeProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeProfile.
     * @param {EmployeeProfileCreateArgs} args - Arguments to create a EmployeeProfile.
     * @example
     * // Create one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.create({
     *   data: {
     *     // ... data to create a EmployeeProfile
     *   }
     * })
     * 
     */
    create<T extends EmployeeProfileCreateArgs>(args: SelectSubset<T, EmployeeProfileCreateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeProfiles.
     * @param {EmployeeProfileCreateManyArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeProfileCreateManyArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeProfiles and returns the data saved in the database.
     * @param {EmployeeProfileCreateManyAndReturnArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeProfiles and only return the `userId`
     * const employeeProfileWithUserIdOnly = await prisma.employeeProfile.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeProfile.
     * @param {EmployeeProfileDeleteArgs} args - Arguments to delete one EmployeeProfile.
     * @example
     * // Delete one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.delete({
     *   where: {
     *     // ... filter to delete one EmployeeProfile
     *   }
     * })
     * 
     */
    delete<T extends EmployeeProfileDeleteArgs>(args: SelectSubset<T, EmployeeProfileDeleteArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeProfile.
     * @param {EmployeeProfileUpdateArgs} args - Arguments to update one EmployeeProfile.
     * @example
     * // Update one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeProfileUpdateArgs>(args: SelectSubset<T, EmployeeProfileUpdateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeProfiles.
     * @param {EmployeeProfileDeleteManyArgs} args - Arguments to filter EmployeeProfiles to delete.
     * @example
     * // Delete a few EmployeeProfiles
     * const { count } = await prisma.employeeProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeProfileDeleteManyArgs>(args?: SelectSubset<T, EmployeeProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeProfileUpdateManyArgs>(args: SelectSubset<T, EmployeeProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeProfile.
     * @param {EmployeeProfileUpsertArgs} args - Arguments to update or create a EmployeeProfile.
     * @example
     * // Update or create a EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.upsert({
     *   create: {
     *     // ... data to create a EmployeeProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeProfile we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeProfileUpsertArgs>(args: SelectSubset<T, EmployeeProfileUpsertArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileCountArgs} args - Arguments to filter EmployeeProfiles to count.
     * @example
     * // Count the number of EmployeeProfiles
     * const count = await prisma.employeeProfile.count({
     *   where: {
     *     // ... the filter for the EmployeeProfiles we want to count
     *   }
     * })
    **/
    count<T extends EmployeeProfileCountArgs>(
      args?: Subset<T, EmployeeProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeProfileAggregateArgs>(args: Subset<T, EmployeeProfileAggregateArgs>): Prisma.PrismaPromise<GetEmployeeProfileAggregateType<T>>

    /**
     * Group by EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeProfileGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeProfile model
   */
  readonly fields: EmployeeProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salaryRange<T extends EmployeeProfile$salaryRangeArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeProfile$salaryRangeArgs<ExtArgs>>): Prisma__SalaryRangeClient<$Result.GetResult<Prisma.$SalaryRangePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeProfile model
   */ 
  interface EmployeeProfileFieldRefs {
    readonly userId: FieldRef<"EmployeeProfile", 'BigInt'>
    readonly nic: FieldRef<"EmployeeProfile", 'String'>
    readonly address: FieldRef<"EmployeeProfile", 'String'>
    readonly joinedDate: FieldRef<"EmployeeProfile", 'DateTime'>
    readonly designation: FieldRef<"EmployeeProfile", 'String'>
    readonly basicSalary: FieldRef<"EmployeeProfile", 'Decimal'>
    readonly salaryRangeId: FieldRef<"EmployeeProfile", 'BigInt'>
    readonly otRate: FieldRef<"EmployeeProfile", 'Decimal'>
    readonly notes: FieldRef<"EmployeeProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeProfile findUnique
   */
  export type EmployeeProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findUniqueOrThrow
   */
  export type EmployeeProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findFirst
   */
  export type EmployeeProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findFirstOrThrow
   */
  export type EmployeeProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findMany
   */
  export type EmployeeProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfiles to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile create
   */
  export type EmployeeProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeProfile.
     */
    data: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
  }

  /**
   * EmployeeProfile createMany
   */
  export type EmployeeProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeProfile createManyAndReturn
   */
  export type EmployeeProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeProfile update
   */
  export type EmployeeProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeProfile.
     */
    data: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
    /**
     * Choose, which EmployeeProfile to update.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile updateMany
   */
  export type EmployeeProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeProfiles.
     */
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeProfiles to update
     */
    where?: EmployeeProfileWhereInput
  }

  /**
   * EmployeeProfile upsert
   */
  export type EmployeeProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeProfile to update in case it exists.
     */
    where: EmployeeProfileWhereUniqueInput
    /**
     * In case the EmployeeProfile found by the `where` argument doesn't exist, create a new EmployeeProfile with this data.
     */
    create: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
    /**
     * In case the EmployeeProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
  }

  /**
   * EmployeeProfile delete
   */
  export type EmployeeProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter which EmployeeProfile to delete.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile deleteMany
   */
  export type EmployeeProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfiles to delete
     */
    where?: EmployeeProfileWhereInput
  }

  /**
   * EmployeeProfile.salaryRange
   */
  export type EmployeeProfile$salaryRangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRange
     */
    select?: SalaryRangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRangeInclude<ExtArgs> | null
    where?: SalaryRangeWhereInput
  }

  /**
   * EmployeeProfile without action
   */
  export type EmployeeProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceDaily
   */

  export type AggregateAttendanceDaily = {
    _count: AttendanceDailyCountAggregateOutputType | null
    _avg: AttendanceDailyAvgAggregateOutputType | null
    _sum: AttendanceDailySumAggregateOutputType | null
    _min: AttendanceDailyMinAggregateOutputType | null
    _max: AttendanceDailyMaxAggregateOutputType | null
  }

  export type AttendanceDailyAvgAggregateOutputType = {
    attendanceId: number | null
    userId: number | null
    systemHours: Decimal | null
    systemOtHours: Decimal | null
    manualOtHours: Decimal | null
    recordedBy: number | null
  }

  export type AttendanceDailySumAggregateOutputType = {
    attendanceId: bigint | null
    userId: bigint | null
    systemHours: Decimal | null
    systemOtHours: Decimal | null
    manualOtHours: Decimal | null
    recordedBy: bigint | null
  }

  export type AttendanceDailyMinAggregateOutputType = {
    attendanceId: bigint | null
    userId: bigint | null
    workDate: Date | null
    timeIn: Date | null
    timeOut: Date | null
    systemHours: Decimal | null
    systemOtHours: Decimal | null
    manualOtHours: Decimal | null
    remarks: string | null
    recordedBy: bigint | null
    createdAt: Date | null
  }

  export type AttendanceDailyMaxAggregateOutputType = {
    attendanceId: bigint | null
    userId: bigint | null
    workDate: Date | null
    timeIn: Date | null
    timeOut: Date | null
    systemHours: Decimal | null
    systemOtHours: Decimal | null
    manualOtHours: Decimal | null
    remarks: string | null
    recordedBy: bigint | null
    createdAt: Date | null
  }

  export type AttendanceDailyCountAggregateOutputType = {
    attendanceId: number
    userId: number
    workDate: number
    timeIn: number
    timeOut: number
    systemHours: number
    systemOtHours: number
    manualOtHours: number
    remarks: number
    recordedBy: number
    createdAt: number
    _all: number
  }


  export type AttendanceDailyAvgAggregateInputType = {
    attendanceId?: true
    userId?: true
    systemHours?: true
    systemOtHours?: true
    manualOtHours?: true
    recordedBy?: true
  }

  export type AttendanceDailySumAggregateInputType = {
    attendanceId?: true
    userId?: true
    systemHours?: true
    systemOtHours?: true
    manualOtHours?: true
    recordedBy?: true
  }

  export type AttendanceDailyMinAggregateInputType = {
    attendanceId?: true
    userId?: true
    workDate?: true
    timeIn?: true
    timeOut?: true
    systemHours?: true
    systemOtHours?: true
    manualOtHours?: true
    remarks?: true
    recordedBy?: true
    createdAt?: true
  }

  export type AttendanceDailyMaxAggregateInputType = {
    attendanceId?: true
    userId?: true
    workDate?: true
    timeIn?: true
    timeOut?: true
    systemHours?: true
    systemOtHours?: true
    manualOtHours?: true
    remarks?: true
    recordedBy?: true
    createdAt?: true
  }

  export type AttendanceDailyCountAggregateInputType = {
    attendanceId?: true
    userId?: true
    workDate?: true
    timeIn?: true
    timeOut?: true
    systemHours?: true
    systemOtHours?: true
    manualOtHours?: true
    remarks?: true
    recordedBy?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceDailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDaily to aggregate.
     */
    where?: AttendanceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailies to fetch.
     */
    orderBy?: AttendanceDailyOrderByWithRelationInput | AttendanceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceDailies
    **/
    _count?: true | AttendanceDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceDailyMaxAggregateInputType
  }

  export type GetAttendanceDailyAggregateType<T extends AttendanceDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceDaily[P]>
      : GetScalarType<T[P], AggregateAttendanceDaily[P]>
  }




  export type AttendanceDailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceDailyWhereInput
    orderBy?: AttendanceDailyOrderByWithAggregationInput | AttendanceDailyOrderByWithAggregationInput[]
    by: AttendanceDailyScalarFieldEnum[] | AttendanceDailyScalarFieldEnum
    having?: AttendanceDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceDailyCountAggregateInputType | true
    _avg?: AttendanceDailyAvgAggregateInputType
    _sum?: AttendanceDailySumAggregateInputType
    _min?: AttendanceDailyMinAggregateInputType
    _max?: AttendanceDailyMaxAggregateInputType
  }

  export type AttendanceDailyGroupByOutputType = {
    attendanceId: bigint
    userId: bigint
    workDate: Date
    timeIn: Date | null
    timeOut: Date | null
    systemHours: Decimal
    systemOtHours: Decimal
    manualOtHours: Decimal
    remarks: string | null
    recordedBy: bigint | null
    createdAt: Date
    _count: AttendanceDailyCountAggregateOutputType | null
    _avg: AttendanceDailyAvgAggregateOutputType | null
    _sum: AttendanceDailySumAggregateOutputType | null
    _min: AttendanceDailyMinAggregateOutputType | null
    _max: AttendanceDailyMaxAggregateOutputType | null
  }

  type GetAttendanceDailyGroupByPayload<T extends AttendanceDailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceDailyGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceDailyGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceDailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attendanceId?: boolean
    userId?: boolean
    workDate?: boolean
    timeIn?: boolean
    timeOut?: boolean
    systemHours?: boolean
    systemOtHours?: boolean
    manualOtHours?: boolean
    remarks?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    recorder?: boolean | AttendanceDaily$recorderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDaily"]>

  export type AttendanceDailySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attendanceId?: boolean
    userId?: boolean
    workDate?: boolean
    timeIn?: boolean
    timeOut?: boolean
    systemHours?: boolean
    systemOtHours?: boolean
    manualOtHours?: boolean
    remarks?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    recorder?: boolean | AttendanceDaily$recorderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceDaily"]>

  export type AttendanceDailySelectScalar = {
    attendanceId?: boolean
    userId?: boolean
    workDate?: boolean
    timeIn?: boolean
    timeOut?: boolean
    systemHours?: boolean
    systemOtHours?: boolean
    manualOtHours?: boolean
    remarks?: boolean
    recordedBy?: boolean
    createdAt?: boolean
  }

  export type AttendanceDailyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recorder?: boolean | AttendanceDaily$recorderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceDailyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recorder?: boolean | AttendanceDaily$recorderArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendanceDailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceDaily"
    objects: {
      recorder: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      attendanceId: bigint
      userId: bigint
      workDate: Date
      timeIn: Date | null
      timeOut: Date | null
      systemHours: Prisma.Decimal
      systemOtHours: Prisma.Decimal
      manualOtHours: Prisma.Decimal
      remarks: string | null
      recordedBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["attendanceDaily"]>
    composites: {}
  }

  type AttendanceDailyGetPayload<S extends boolean | null | undefined | AttendanceDailyDefaultArgs> = $Result.GetResult<Prisma.$AttendanceDailyPayload, S>

  type AttendanceDailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceDailyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceDailyCountAggregateInputType | true
    }

  export interface AttendanceDailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceDaily'], meta: { name: 'AttendanceDaily' } }
    /**
     * Find zero or one AttendanceDaily that matches the filter.
     * @param {AttendanceDailyFindUniqueArgs} args - Arguments to find a AttendanceDaily
     * @example
     * // Get one AttendanceDaily
     * const attendanceDaily = await prisma.attendanceDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceDailyFindUniqueArgs>(args: SelectSubset<T, AttendanceDailyFindUniqueArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttendanceDaily that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceDailyFindUniqueOrThrowArgs} args - Arguments to find a AttendanceDaily
     * @example
     * // Get one AttendanceDaily
     * const attendanceDaily = await prisma.attendanceDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceDailyFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceDailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttendanceDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyFindFirstArgs} args - Arguments to find a AttendanceDaily
     * @example
     * // Get one AttendanceDaily
     * const attendanceDaily = await prisma.attendanceDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceDailyFindFirstArgs>(args?: SelectSubset<T, AttendanceDailyFindFirstArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttendanceDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyFindFirstOrThrowArgs} args - Arguments to find a AttendanceDaily
     * @example
     * // Get one AttendanceDaily
     * const attendanceDaily = await prisma.attendanceDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceDailyFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceDailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttendanceDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceDailies
     * const attendanceDailies = await prisma.attendanceDaily.findMany()
     * 
     * // Get first 10 AttendanceDailies
     * const attendanceDailies = await prisma.attendanceDaily.findMany({ take: 10 })
     * 
     * // Only select the `attendanceId`
     * const attendanceDailyWithAttendanceIdOnly = await prisma.attendanceDaily.findMany({ select: { attendanceId: true } })
     * 
     */
    findMany<T extends AttendanceDailyFindManyArgs>(args?: SelectSubset<T, AttendanceDailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttendanceDaily.
     * @param {AttendanceDailyCreateArgs} args - Arguments to create a AttendanceDaily.
     * @example
     * // Create one AttendanceDaily
     * const AttendanceDaily = await prisma.attendanceDaily.create({
     *   data: {
     *     // ... data to create a AttendanceDaily
     *   }
     * })
     * 
     */
    create<T extends AttendanceDailyCreateArgs>(args: SelectSubset<T, AttendanceDailyCreateArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttendanceDailies.
     * @param {AttendanceDailyCreateManyArgs} args - Arguments to create many AttendanceDailies.
     * @example
     * // Create many AttendanceDailies
     * const attendanceDaily = await prisma.attendanceDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceDailyCreateManyArgs>(args?: SelectSubset<T, AttendanceDailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceDailies and returns the data saved in the database.
     * @param {AttendanceDailyCreateManyAndReturnArgs} args - Arguments to create many AttendanceDailies.
     * @example
     * // Create many AttendanceDailies
     * const attendanceDaily = await prisma.attendanceDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceDailies and only return the `attendanceId`
     * const attendanceDailyWithAttendanceIdOnly = await prisma.attendanceDaily.createManyAndReturn({ 
     *   select: { attendanceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceDailyCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceDailyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttendanceDaily.
     * @param {AttendanceDailyDeleteArgs} args - Arguments to delete one AttendanceDaily.
     * @example
     * // Delete one AttendanceDaily
     * const AttendanceDaily = await prisma.attendanceDaily.delete({
     *   where: {
     *     // ... filter to delete one AttendanceDaily
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDailyDeleteArgs>(args: SelectSubset<T, AttendanceDailyDeleteArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttendanceDaily.
     * @param {AttendanceDailyUpdateArgs} args - Arguments to update one AttendanceDaily.
     * @example
     * // Update one AttendanceDaily
     * const attendanceDaily = await prisma.attendanceDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceDailyUpdateArgs>(args: SelectSubset<T, AttendanceDailyUpdateArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttendanceDailies.
     * @param {AttendanceDailyDeleteManyArgs} args - Arguments to filter AttendanceDailies to delete.
     * @example
     * // Delete a few AttendanceDailies
     * const { count } = await prisma.attendanceDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDailyDeleteManyArgs>(args?: SelectSubset<T, AttendanceDailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceDailies
     * const attendanceDaily = await prisma.attendanceDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceDailyUpdateManyArgs>(args: SelectSubset<T, AttendanceDailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceDaily.
     * @param {AttendanceDailyUpsertArgs} args - Arguments to update or create a AttendanceDaily.
     * @example
     * // Update or create a AttendanceDaily
     * const attendanceDaily = await prisma.attendanceDaily.upsert({
     *   create: {
     *     // ... data to create a AttendanceDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceDaily we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceDailyUpsertArgs>(args: SelectSubset<T, AttendanceDailyUpsertArgs<ExtArgs>>): Prisma__AttendanceDailyClient<$Result.GetResult<Prisma.$AttendanceDailyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttendanceDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyCountArgs} args - Arguments to filter AttendanceDailies to count.
     * @example
     * // Count the number of AttendanceDailies
     * const count = await prisma.attendanceDaily.count({
     *   where: {
     *     // ... the filter for the AttendanceDailies we want to count
     *   }
     * })
    **/
    count<T extends AttendanceDailyCountArgs>(
      args?: Subset<T, AttendanceDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceDailyAggregateArgs>(args: Subset<T, AttendanceDailyAggregateArgs>): Prisma.PrismaPromise<GetAttendanceDailyAggregateType<T>>

    /**
     * Group by AttendanceDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceDailyGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceDailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceDaily model
   */
  readonly fields: AttendanceDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceDailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recorder<T extends AttendanceDaily$recorderArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceDaily$recorderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceDaily model
   */ 
  interface AttendanceDailyFieldRefs {
    readonly attendanceId: FieldRef<"AttendanceDaily", 'BigInt'>
    readonly userId: FieldRef<"AttendanceDaily", 'BigInt'>
    readonly workDate: FieldRef<"AttendanceDaily", 'DateTime'>
    readonly timeIn: FieldRef<"AttendanceDaily", 'DateTime'>
    readonly timeOut: FieldRef<"AttendanceDaily", 'DateTime'>
    readonly systemHours: FieldRef<"AttendanceDaily", 'Decimal'>
    readonly systemOtHours: FieldRef<"AttendanceDaily", 'Decimal'>
    readonly manualOtHours: FieldRef<"AttendanceDaily", 'Decimal'>
    readonly remarks: FieldRef<"AttendanceDaily", 'String'>
    readonly recordedBy: FieldRef<"AttendanceDaily", 'BigInt'>
    readonly createdAt: FieldRef<"AttendanceDaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceDaily findUnique
   */
  export type AttendanceDailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDaily to fetch.
     */
    where: AttendanceDailyWhereUniqueInput
  }

  /**
   * AttendanceDaily findUniqueOrThrow
   */
  export type AttendanceDailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDaily to fetch.
     */
    where: AttendanceDailyWhereUniqueInput
  }

  /**
   * AttendanceDaily findFirst
   */
  export type AttendanceDailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDaily to fetch.
     */
    where?: AttendanceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailies to fetch.
     */
    orderBy?: AttendanceDailyOrderByWithRelationInput | AttendanceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDailies.
     */
    cursor?: AttendanceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDailies.
     */
    distinct?: AttendanceDailyScalarFieldEnum | AttendanceDailyScalarFieldEnum[]
  }

  /**
   * AttendanceDaily findFirstOrThrow
   */
  export type AttendanceDailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDaily to fetch.
     */
    where?: AttendanceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailies to fetch.
     */
    orderBy?: AttendanceDailyOrderByWithRelationInput | AttendanceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceDailies.
     */
    cursor?: AttendanceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceDailies.
     */
    distinct?: AttendanceDailyScalarFieldEnum | AttendanceDailyScalarFieldEnum[]
  }

  /**
   * AttendanceDaily findMany
   */
  export type AttendanceDailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceDailies to fetch.
     */
    where?: AttendanceDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceDailies to fetch.
     */
    orderBy?: AttendanceDailyOrderByWithRelationInput | AttendanceDailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceDailies.
     */
    cursor?: AttendanceDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceDailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceDailies.
     */
    skip?: number
    distinct?: AttendanceDailyScalarFieldEnum | AttendanceDailyScalarFieldEnum[]
  }

  /**
   * AttendanceDaily create
   */
  export type AttendanceDailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceDaily.
     */
    data: XOR<AttendanceDailyCreateInput, AttendanceDailyUncheckedCreateInput>
  }

  /**
   * AttendanceDaily createMany
   */
  export type AttendanceDailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceDailies.
     */
    data: AttendanceDailyCreateManyInput | AttendanceDailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceDaily createManyAndReturn
   */
  export type AttendanceDailyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttendanceDailies.
     */
    data: AttendanceDailyCreateManyInput | AttendanceDailyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceDaily update
   */
  export type AttendanceDailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceDaily.
     */
    data: XOR<AttendanceDailyUpdateInput, AttendanceDailyUncheckedUpdateInput>
    /**
     * Choose, which AttendanceDaily to update.
     */
    where: AttendanceDailyWhereUniqueInput
  }

  /**
   * AttendanceDaily updateMany
   */
  export type AttendanceDailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceDailies.
     */
    data: XOR<AttendanceDailyUpdateManyMutationInput, AttendanceDailyUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceDailies to update
     */
    where?: AttendanceDailyWhereInput
  }

  /**
   * AttendanceDaily upsert
   */
  export type AttendanceDailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceDaily to update in case it exists.
     */
    where: AttendanceDailyWhereUniqueInput
    /**
     * In case the AttendanceDaily found by the `where` argument doesn't exist, create a new AttendanceDaily with this data.
     */
    create: XOR<AttendanceDailyCreateInput, AttendanceDailyUncheckedCreateInput>
    /**
     * In case the AttendanceDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceDailyUpdateInput, AttendanceDailyUncheckedUpdateInput>
  }

  /**
   * AttendanceDaily delete
   */
  export type AttendanceDailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
    /**
     * Filter which AttendanceDaily to delete.
     */
    where: AttendanceDailyWhereUniqueInput
  }

  /**
   * AttendanceDaily deleteMany
   */
  export type AttendanceDailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceDailies to delete
     */
    where?: AttendanceDailyWhereInput
  }

  /**
   * AttendanceDaily.recorder
   */
  export type AttendanceDaily$recorderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AttendanceDaily without action
   */
  export type AttendanceDailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceDaily
     */
    select?: AttendanceDailySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceDailyInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPeriod
   */

  export type AggregateSalaryPeriod = {
    _count: SalaryPeriodCountAggregateOutputType | null
    _avg: SalaryPeriodAvgAggregateOutputType | null
    _sum: SalaryPeriodSumAggregateOutputType | null
    _min: SalaryPeriodMinAggregateOutputType | null
    _max: SalaryPeriodMaxAggregateOutputType | null
  }

  export type SalaryPeriodAvgAggregateOutputType = {
    periodId: number | null
    year: number | null
    month: number | null
  }

  export type SalaryPeriodSumAggregateOutputType = {
    periodId: bigint | null
    year: number | null
    month: number | null
  }

  export type SalaryPeriodMinAggregateOutputType = {
    periodId: bigint | null
    year: number | null
    month: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
  }

  export type SalaryPeriodMaxAggregateOutputType = {
    periodId: bigint | null
    year: number | null
    month: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
  }

  export type SalaryPeriodCountAggregateOutputType = {
    periodId: number
    year: number
    month: number
    startDate: number
    endDate: number
    status: number
    _all: number
  }


  export type SalaryPeriodAvgAggregateInputType = {
    periodId?: true
    year?: true
    month?: true
  }

  export type SalaryPeriodSumAggregateInputType = {
    periodId?: true
    year?: true
    month?: true
  }

  export type SalaryPeriodMinAggregateInputType = {
    periodId?: true
    year?: true
    month?: true
    startDate?: true
    endDate?: true
    status?: true
  }

  export type SalaryPeriodMaxAggregateInputType = {
    periodId?: true
    year?: true
    month?: true
    startDate?: true
    endDate?: true
    status?: true
  }

  export type SalaryPeriodCountAggregateInputType = {
    periodId?: true
    year?: true
    month?: true
    startDate?: true
    endDate?: true
    status?: true
    _all?: true
  }

  export type SalaryPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPeriod to aggregate.
     */
    where?: SalaryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPeriods to fetch.
     */
    orderBy?: SalaryPeriodOrderByWithRelationInput | SalaryPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPeriods
    **/
    _count?: true | SalaryPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPeriodMaxAggregateInputType
  }

  export type GetSalaryPeriodAggregateType<T extends SalaryPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPeriod[P]>
      : GetScalarType<T[P], AggregateSalaryPeriod[P]>
  }




  export type SalaryPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPeriodWhereInput
    orderBy?: SalaryPeriodOrderByWithAggregationInput | SalaryPeriodOrderByWithAggregationInput[]
    by: SalaryPeriodScalarFieldEnum[] | SalaryPeriodScalarFieldEnum
    having?: SalaryPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPeriodCountAggregateInputType | true
    _avg?: SalaryPeriodAvgAggregateInputType
    _sum?: SalaryPeriodSumAggregateInputType
    _min?: SalaryPeriodMinAggregateInputType
    _max?: SalaryPeriodMaxAggregateInputType
  }

  export type SalaryPeriodGroupByOutputType = {
    periodId: bigint
    year: number
    month: number
    startDate: Date
    endDate: Date
    status: string
    _count: SalaryPeriodCountAggregateOutputType | null
    _avg: SalaryPeriodAvgAggregateOutputType | null
    _sum: SalaryPeriodSumAggregateOutputType | null
    _min: SalaryPeriodMinAggregateOutputType | null
    _max: SalaryPeriodMaxAggregateOutputType | null
  }

  type GetSalaryPeriodGroupByPayload<T extends SalaryPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPeriodGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    periodId?: boolean
    year?: boolean
    month?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    salaryRecords?: boolean | SalaryPeriod$salaryRecordsArgs<ExtArgs>
    _count?: boolean | SalaryPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPeriod"]>

  export type SalaryPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    periodId?: boolean
    year?: boolean
    month?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
  }, ExtArgs["result"]["salaryPeriod"]>

  export type SalaryPeriodSelectScalar = {
    periodId?: boolean
    year?: boolean
    month?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
  }

  export type SalaryPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salaryRecords?: boolean | SalaryPeriod$salaryRecordsArgs<ExtArgs>
    _count?: boolean | SalaryPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalaryPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SalaryPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPeriod"
    objects: {
      salaryRecords: Prisma.$SalaryRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      periodId: bigint
      year: number
      month: number
      startDate: Date
      endDate: Date
      status: string
    }, ExtArgs["result"]["salaryPeriod"]>
    composites: {}
  }

  type SalaryPeriodGetPayload<S extends boolean | null | undefined | SalaryPeriodDefaultArgs> = $Result.GetResult<Prisma.$SalaryPeriodPayload, S>

  type SalaryPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryPeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryPeriodCountAggregateInputType | true
    }

  export interface SalaryPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPeriod'], meta: { name: 'SalaryPeriod' } }
    /**
     * Find zero or one SalaryPeriod that matches the filter.
     * @param {SalaryPeriodFindUniqueArgs} args - Arguments to find a SalaryPeriod
     * @example
     * // Get one SalaryPeriod
     * const salaryPeriod = await prisma.salaryPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPeriodFindUniqueArgs>(args: SelectSubset<T, SalaryPeriodFindUniqueArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalaryPeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryPeriodFindUniqueOrThrowArgs} args - Arguments to find a SalaryPeriod
     * @example
     * // Get one SalaryPeriod
     * const salaryPeriod = await prisma.salaryPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalaryPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodFindFirstArgs} args - Arguments to find a SalaryPeriod
     * @example
     * // Get one SalaryPeriod
     * const salaryPeriod = await prisma.salaryPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPeriodFindFirstArgs>(args?: SelectSubset<T, SalaryPeriodFindFirstArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalaryPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodFindFirstOrThrowArgs} args - Arguments to find a SalaryPeriod
     * @example
     * // Get one SalaryPeriod
     * const salaryPeriod = await prisma.salaryPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalaryPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPeriods
     * const salaryPeriods = await prisma.salaryPeriod.findMany()
     * 
     * // Get first 10 SalaryPeriods
     * const salaryPeriods = await prisma.salaryPeriod.findMany({ take: 10 })
     * 
     * // Only select the `periodId`
     * const salaryPeriodWithPeriodIdOnly = await prisma.salaryPeriod.findMany({ select: { periodId: true } })
     * 
     */
    findMany<T extends SalaryPeriodFindManyArgs>(args?: SelectSubset<T, SalaryPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalaryPeriod.
     * @param {SalaryPeriodCreateArgs} args - Arguments to create a SalaryPeriod.
     * @example
     * // Create one SalaryPeriod
     * const SalaryPeriod = await prisma.salaryPeriod.create({
     *   data: {
     *     // ... data to create a SalaryPeriod
     *   }
     * })
     * 
     */
    create<T extends SalaryPeriodCreateArgs>(args: SelectSubset<T, SalaryPeriodCreateArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalaryPeriods.
     * @param {SalaryPeriodCreateManyArgs} args - Arguments to create many SalaryPeriods.
     * @example
     * // Create many SalaryPeriods
     * const salaryPeriod = await prisma.salaryPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPeriodCreateManyArgs>(args?: SelectSubset<T, SalaryPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPeriods and returns the data saved in the database.
     * @param {SalaryPeriodCreateManyAndReturnArgs} args - Arguments to create many SalaryPeriods.
     * @example
     * // Create many SalaryPeriods
     * const salaryPeriod = await prisma.salaryPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPeriods and only return the `periodId`
     * const salaryPeriodWithPeriodIdOnly = await prisma.salaryPeriod.createManyAndReturn({ 
     *   select: { periodId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalaryPeriod.
     * @param {SalaryPeriodDeleteArgs} args - Arguments to delete one SalaryPeriod.
     * @example
     * // Delete one SalaryPeriod
     * const SalaryPeriod = await prisma.salaryPeriod.delete({
     *   where: {
     *     // ... filter to delete one SalaryPeriod
     *   }
     * })
     * 
     */
    delete<T extends SalaryPeriodDeleteArgs>(args: SelectSubset<T, SalaryPeriodDeleteArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalaryPeriod.
     * @param {SalaryPeriodUpdateArgs} args - Arguments to update one SalaryPeriod.
     * @example
     * // Update one SalaryPeriod
     * const salaryPeriod = await prisma.salaryPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPeriodUpdateArgs>(args: SelectSubset<T, SalaryPeriodUpdateArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalaryPeriods.
     * @param {SalaryPeriodDeleteManyArgs} args - Arguments to filter SalaryPeriods to delete.
     * @example
     * // Delete a few SalaryPeriods
     * const { count } = await prisma.salaryPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPeriodDeleteManyArgs>(args?: SelectSubset<T, SalaryPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPeriods
     * const salaryPeriod = await prisma.salaryPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPeriodUpdateManyArgs>(args: SelectSubset<T, SalaryPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryPeriod.
     * @param {SalaryPeriodUpsertArgs} args - Arguments to update or create a SalaryPeriod.
     * @example
     * // Update or create a SalaryPeriod
     * const salaryPeriod = await prisma.salaryPeriod.upsert({
     *   create: {
     *     // ... data to create a SalaryPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPeriod we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPeriodUpsertArgs>(args: SelectSubset<T, SalaryPeriodUpsertArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalaryPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodCountArgs} args - Arguments to filter SalaryPeriods to count.
     * @example
     * // Count the number of SalaryPeriods
     * const count = await prisma.salaryPeriod.count({
     *   where: {
     *     // ... the filter for the SalaryPeriods we want to count
     *   }
     * })
    **/
    count<T extends SalaryPeriodCountArgs>(
      args?: Subset<T, SalaryPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPeriodAggregateArgs>(args: Subset<T, SalaryPeriodAggregateArgs>): Prisma.PrismaPromise<GetSalaryPeriodAggregateType<T>>

    /**
     * Group by SalaryPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPeriodGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPeriod model
   */
  readonly fields: SalaryPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salaryRecords<T extends SalaryPeriod$salaryRecordsArgs<ExtArgs> = {}>(args?: Subset<T, SalaryPeriod$salaryRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPeriod model
   */ 
  interface SalaryPeriodFieldRefs {
    readonly periodId: FieldRef<"SalaryPeriod", 'BigInt'>
    readonly year: FieldRef<"SalaryPeriod", 'Int'>
    readonly month: FieldRef<"SalaryPeriod", 'Int'>
    readonly startDate: FieldRef<"SalaryPeriod", 'DateTime'>
    readonly endDate: FieldRef<"SalaryPeriod", 'DateTime'>
    readonly status: FieldRef<"SalaryPeriod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPeriod findUnique
   */
  export type SalaryPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPeriod to fetch.
     */
    where: SalaryPeriodWhereUniqueInput
  }

  /**
   * SalaryPeriod findUniqueOrThrow
   */
  export type SalaryPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPeriod to fetch.
     */
    where: SalaryPeriodWhereUniqueInput
  }

  /**
   * SalaryPeriod findFirst
   */
  export type SalaryPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPeriod to fetch.
     */
    where?: SalaryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPeriods to fetch.
     */
    orderBy?: SalaryPeriodOrderByWithRelationInput | SalaryPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPeriods.
     */
    cursor?: SalaryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPeriods.
     */
    distinct?: SalaryPeriodScalarFieldEnum | SalaryPeriodScalarFieldEnum[]
  }

  /**
   * SalaryPeriod findFirstOrThrow
   */
  export type SalaryPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPeriod to fetch.
     */
    where?: SalaryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPeriods to fetch.
     */
    orderBy?: SalaryPeriodOrderByWithRelationInput | SalaryPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPeriods.
     */
    cursor?: SalaryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPeriods.
     */
    distinct?: SalaryPeriodScalarFieldEnum | SalaryPeriodScalarFieldEnum[]
  }

  /**
   * SalaryPeriod findMany
   */
  export type SalaryPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPeriods to fetch.
     */
    where?: SalaryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPeriods to fetch.
     */
    orderBy?: SalaryPeriodOrderByWithRelationInput | SalaryPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPeriods.
     */
    cursor?: SalaryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPeriods.
     */
    skip?: number
    distinct?: SalaryPeriodScalarFieldEnum | SalaryPeriodScalarFieldEnum[]
  }

  /**
   * SalaryPeriod create
   */
  export type SalaryPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPeriod.
     */
    data: XOR<SalaryPeriodCreateInput, SalaryPeriodUncheckedCreateInput>
  }

  /**
   * SalaryPeriod createMany
   */
  export type SalaryPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPeriods.
     */
    data: SalaryPeriodCreateManyInput | SalaryPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryPeriod createManyAndReturn
   */
  export type SalaryPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalaryPeriods.
     */
    data: SalaryPeriodCreateManyInput | SalaryPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryPeriod update
   */
  export type SalaryPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPeriod.
     */
    data: XOR<SalaryPeriodUpdateInput, SalaryPeriodUncheckedUpdateInput>
    /**
     * Choose, which SalaryPeriod to update.
     */
    where: SalaryPeriodWhereUniqueInput
  }

  /**
   * SalaryPeriod updateMany
   */
  export type SalaryPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPeriods.
     */
    data: XOR<SalaryPeriodUpdateManyMutationInput, SalaryPeriodUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPeriods to update
     */
    where?: SalaryPeriodWhereInput
  }

  /**
   * SalaryPeriod upsert
   */
  export type SalaryPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPeriod to update in case it exists.
     */
    where: SalaryPeriodWhereUniqueInput
    /**
     * In case the SalaryPeriod found by the `where` argument doesn't exist, create a new SalaryPeriod with this data.
     */
    create: XOR<SalaryPeriodCreateInput, SalaryPeriodUncheckedCreateInput>
    /**
     * In case the SalaryPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPeriodUpdateInput, SalaryPeriodUncheckedUpdateInput>
  }

  /**
   * SalaryPeriod delete
   */
  export type SalaryPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
    /**
     * Filter which SalaryPeriod to delete.
     */
    where: SalaryPeriodWhereUniqueInput
  }

  /**
   * SalaryPeriod deleteMany
   */
  export type SalaryPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPeriods to delete
     */
    where?: SalaryPeriodWhereInput
  }

  /**
   * SalaryPeriod.salaryRecords
   */
  export type SalaryPeriod$salaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    where?: SalaryRecordWhereInput
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    cursor?: SalaryRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryPeriod without action
   */
  export type SalaryPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPeriod
     */
    select?: SalaryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPeriodInclude<ExtArgs> | null
  }


  /**
   * Model SalaryRecord
   */

  export type AggregateSalaryRecord = {
    _count: SalaryRecordCountAggregateOutputType | null
    _avg: SalaryRecordAvgAggregateOutputType | null
    _sum: SalaryRecordSumAggregateOutputType | null
    _min: SalaryRecordMinAggregateOutputType | null
    _max: SalaryRecordMaxAggregateOutputType | null
  }

  export type SalaryRecordAvgAggregateOutputType = {
    salaryRecordId: number | null
    periodId: number | null
    userId: number | null
    baseSalary: Decimal | null
    otHours: Decimal | null
    otAmount: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    totalPay: Decimal | null
  }

  export type SalaryRecordSumAggregateOutputType = {
    salaryRecordId: bigint | null
    periodId: bigint | null
    userId: bigint | null
    baseSalary: Decimal | null
    otHours: Decimal | null
    otAmount: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    totalPay: Decimal | null
  }

  export type SalaryRecordMinAggregateOutputType = {
    salaryRecordId: bigint | null
    periodId: bigint | null
    userId: bigint | null
    baseSalary: Decimal | null
    otHours: Decimal | null
    otAmount: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    totalPay: Decimal | null
    status: string | null
  }

  export type SalaryRecordMaxAggregateOutputType = {
    salaryRecordId: bigint | null
    periodId: bigint | null
    userId: bigint | null
    baseSalary: Decimal | null
    otHours: Decimal | null
    otAmount: Decimal | null
    allowances: Decimal | null
    deductions: Decimal | null
    totalPay: Decimal | null
    status: string | null
  }

  export type SalaryRecordCountAggregateOutputType = {
    salaryRecordId: number
    periodId: number
    userId: number
    baseSalary: number
    otHours: number
    otAmount: number
    allowances: number
    deductions: number
    totalPay: number
    status: number
    _all: number
  }


  export type SalaryRecordAvgAggregateInputType = {
    salaryRecordId?: true
    periodId?: true
    userId?: true
    baseSalary?: true
    otHours?: true
    otAmount?: true
    allowances?: true
    deductions?: true
    totalPay?: true
  }

  export type SalaryRecordSumAggregateInputType = {
    salaryRecordId?: true
    periodId?: true
    userId?: true
    baseSalary?: true
    otHours?: true
    otAmount?: true
    allowances?: true
    deductions?: true
    totalPay?: true
  }

  export type SalaryRecordMinAggregateInputType = {
    salaryRecordId?: true
    periodId?: true
    userId?: true
    baseSalary?: true
    otHours?: true
    otAmount?: true
    allowances?: true
    deductions?: true
    totalPay?: true
    status?: true
  }

  export type SalaryRecordMaxAggregateInputType = {
    salaryRecordId?: true
    periodId?: true
    userId?: true
    baseSalary?: true
    otHours?: true
    otAmount?: true
    allowances?: true
    deductions?: true
    totalPay?: true
    status?: true
  }

  export type SalaryRecordCountAggregateInputType = {
    salaryRecordId?: true
    periodId?: true
    userId?: true
    baseSalary?: true
    otHours?: true
    otAmount?: true
    allowances?: true
    deductions?: true
    totalPay?: true
    status?: true
    _all?: true
  }

  export type SalaryRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRecord to aggregate.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryRecords
    **/
    _count?: true | SalaryRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryRecordMaxAggregateInputType
  }

  export type GetSalaryRecordAggregateType<T extends SalaryRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryRecord[P]>
      : GetScalarType<T[P], AggregateSalaryRecord[P]>
  }




  export type SalaryRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryRecordWhereInput
    orderBy?: SalaryRecordOrderByWithAggregationInput | SalaryRecordOrderByWithAggregationInput[]
    by: SalaryRecordScalarFieldEnum[] | SalaryRecordScalarFieldEnum
    having?: SalaryRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryRecordCountAggregateInputType | true
    _avg?: SalaryRecordAvgAggregateInputType
    _sum?: SalaryRecordSumAggregateInputType
    _min?: SalaryRecordMinAggregateInputType
    _max?: SalaryRecordMaxAggregateInputType
  }

  export type SalaryRecordGroupByOutputType = {
    salaryRecordId: bigint
    periodId: bigint
    userId: bigint
    baseSalary: Decimal
    otHours: Decimal
    otAmount: Decimal
    allowances: Decimal
    deductions: Decimal
    totalPay: Decimal
    status: string
    _count: SalaryRecordCountAggregateOutputType | null
    _avg: SalaryRecordAvgAggregateOutputType | null
    _sum: SalaryRecordSumAggregateOutputType | null
    _min: SalaryRecordMinAggregateOutputType | null
    _max: SalaryRecordMaxAggregateOutputType | null
  }

  type GetSalaryRecordGroupByPayload<T extends SalaryRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryRecordGroupByOutputType[P]>
        }
      >
    >


  export type SalaryRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salaryRecordId?: boolean
    periodId?: boolean
    userId?: boolean
    baseSalary?: boolean
    otHours?: boolean
    otAmount?: boolean
    allowances?: boolean
    deductions?: boolean
    totalPay?: boolean
    status?: boolean
    payments?: boolean | SalaryRecord$paymentsArgs<ExtArgs>
    period?: boolean | SalaryPeriodDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | SalaryRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRecord"]>

  export type SalaryRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salaryRecordId?: boolean
    periodId?: boolean
    userId?: boolean
    baseSalary?: boolean
    otHours?: boolean
    otAmount?: boolean
    allowances?: boolean
    deductions?: boolean
    totalPay?: boolean
    status?: boolean
    period?: boolean | SalaryPeriodDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryRecord"]>

  export type SalaryRecordSelectScalar = {
    salaryRecordId?: boolean
    periodId?: boolean
    userId?: boolean
    baseSalary?: boolean
    otHours?: boolean
    otAmount?: boolean
    allowances?: boolean
    deductions?: boolean
    totalPay?: boolean
    status?: boolean
  }

  export type SalaryRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SalaryRecord$paymentsArgs<ExtArgs>
    period?: boolean | SalaryPeriodDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | SalaryRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalaryRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    period?: boolean | SalaryPeriodDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalaryRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryRecord"
    objects: {
      payments: Prisma.$SalaryPaymentPayload<ExtArgs>[]
      period: Prisma.$SalaryPeriodPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      salaryRecordId: bigint
      periodId: bigint
      userId: bigint
      baseSalary: Prisma.Decimal
      otHours: Prisma.Decimal
      otAmount: Prisma.Decimal
      allowances: Prisma.Decimal
      deductions: Prisma.Decimal
      totalPay: Prisma.Decimal
      status: string
    }, ExtArgs["result"]["salaryRecord"]>
    composites: {}
  }

  type SalaryRecordGetPayload<S extends boolean | null | undefined | SalaryRecordDefaultArgs> = $Result.GetResult<Prisma.$SalaryRecordPayload, S>

  type SalaryRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryRecordCountAggregateInputType | true
    }

  export interface SalaryRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryRecord'], meta: { name: 'SalaryRecord' } }
    /**
     * Find zero or one SalaryRecord that matches the filter.
     * @param {SalaryRecordFindUniqueArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryRecordFindUniqueArgs>(args: SelectSubset<T, SalaryRecordFindUniqueArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalaryRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryRecordFindUniqueOrThrowArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalaryRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordFindFirstArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryRecordFindFirstArgs>(args?: SelectSubset<T, SalaryRecordFindFirstArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalaryRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordFindFirstOrThrowArgs} args - Arguments to find a SalaryRecord
     * @example
     * // Get one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalaryRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryRecords
     * const salaryRecords = await prisma.salaryRecord.findMany()
     * 
     * // Get first 10 SalaryRecords
     * const salaryRecords = await prisma.salaryRecord.findMany({ take: 10 })
     * 
     * // Only select the `salaryRecordId`
     * const salaryRecordWithSalaryRecordIdOnly = await prisma.salaryRecord.findMany({ select: { salaryRecordId: true } })
     * 
     */
    findMany<T extends SalaryRecordFindManyArgs>(args?: SelectSubset<T, SalaryRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalaryRecord.
     * @param {SalaryRecordCreateArgs} args - Arguments to create a SalaryRecord.
     * @example
     * // Create one SalaryRecord
     * const SalaryRecord = await prisma.salaryRecord.create({
     *   data: {
     *     // ... data to create a SalaryRecord
     *   }
     * })
     * 
     */
    create<T extends SalaryRecordCreateArgs>(args: SelectSubset<T, SalaryRecordCreateArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalaryRecords.
     * @param {SalaryRecordCreateManyArgs} args - Arguments to create many SalaryRecords.
     * @example
     * // Create many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryRecordCreateManyArgs>(args?: SelectSubset<T, SalaryRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryRecords and returns the data saved in the database.
     * @param {SalaryRecordCreateManyAndReturnArgs} args - Arguments to create many SalaryRecords.
     * @example
     * // Create many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryRecords and only return the `salaryRecordId`
     * const salaryRecordWithSalaryRecordIdOnly = await prisma.salaryRecord.createManyAndReturn({ 
     *   select: { salaryRecordId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalaryRecord.
     * @param {SalaryRecordDeleteArgs} args - Arguments to delete one SalaryRecord.
     * @example
     * // Delete one SalaryRecord
     * const SalaryRecord = await prisma.salaryRecord.delete({
     *   where: {
     *     // ... filter to delete one SalaryRecord
     *   }
     * })
     * 
     */
    delete<T extends SalaryRecordDeleteArgs>(args: SelectSubset<T, SalaryRecordDeleteArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalaryRecord.
     * @param {SalaryRecordUpdateArgs} args - Arguments to update one SalaryRecord.
     * @example
     * // Update one SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryRecordUpdateArgs>(args: SelectSubset<T, SalaryRecordUpdateArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalaryRecords.
     * @param {SalaryRecordDeleteManyArgs} args - Arguments to filter SalaryRecords to delete.
     * @example
     * // Delete a few SalaryRecords
     * const { count } = await prisma.salaryRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryRecordDeleteManyArgs>(args?: SelectSubset<T, SalaryRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryRecords
     * const salaryRecord = await prisma.salaryRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryRecordUpdateManyArgs>(args: SelectSubset<T, SalaryRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryRecord.
     * @param {SalaryRecordUpsertArgs} args - Arguments to update or create a SalaryRecord.
     * @example
     * // Update or create a SalaryRecord
     * const salaryRecord = await prisma.salaryRecord.upsert({
     *   create: {
     *     // ... data to create a SalaryRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryRecord we want to update
     *   }
     * })
     */
    upsert<T extends SalaryRecordUpsertArgs>(args: SelectSubset<T, SalaryRecordUpsertArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalaryRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordCountArgs} args - Arguments to filter SalaryRecords to count.
     * @example
     * // Count the number of SalaryRecords
     * const count = await prisma.salaryRecord.count({
     *   where: {
     *     // ... the filter for the SalaryRecords we want to count
     *   }
     * })
    **/
    count<T extends SalaryRecordCountArgs>(
      args?: Subset<T, SalaryRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryRecordAggregateArgs>(args: Subset<T, SalaryRecordAggregateArgs>): Prisma.PrismaPromise<GetSalaryRecordAggregateType<T>>

    /**
     * Group by SalaryRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryRecordGroupByArgs['orderBy'] }
        : { orderBy?: SalaryRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryRecord model
   */
  readonly fields: SalaryRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends SalaryRecord$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, SalaryRecord$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    period<T extends SalaryPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaryPeriodDefaultArgs<ExtArgs>>): Prisma__SalaryPeriodClient<$Result.GetResult<Prisma.$SalaryPeriodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryRecord model
   */ 
  interface SalaryRecordFieldRefs {
    readonly salaryRecordId: FieldRef<"SalaryRecord", 'BigInt'>
    readonly periodId: FieldRef<"SalaryRecord", 'BigInt'>
    readonly userId: FieldRef<"SalaryRecord", 'BigInt'>
    readonly baseSalary: FieldRef<"SalaryRecord", 'Decimal'>
    readonly otHours: FieldRef<"SalaryRecord", 'Decimal'>
    readonly otAmount: FieldRef<"SalaryRecord", 'Decimal'>
    readonly allowances: FieldRef<"SalaryRecord", 'Decimal'>
    readonly deductions: FieldRef<"SalaryRecord", 'Decimal'>
    readonly totalPay: FieldRef<"SalaryRecord", 'Decimal'>
    readonly status: FieldRef<"SalaryRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalaryRecord findUnique
   */
  export type SalaryRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord findUniqueOrThrow
   */
  export type SalaryRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord findFirst
   */
  export type SalaryRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRecords.
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRecords.
     */
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryRecord findFirstOrThrow
   */
  export type SalaryRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecord to fetch.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryRecords.
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryRecords.
     */
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryRecord findMany
   */
  export type SalaryRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter, which SalaryRecords to fetch.
     */
    where?: SalaryRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryRecords to fetch.
     */
    orderBy?: SalaryRecordOrderByWithRelationInput | SalaryRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryRecords.
     */
    cursor?: SalaryRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryRecords.
     */
    skip?: number
    distinct?: SalaryRecordScalarFieldEnum | SalaryRecordScalarFieldEnum[]
  }

  /**
   * SalaryRecord create
   */
  export type SalaryRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryRecord.
     */
    data: XOR<SalaryRecordCreateInput, SalaryRecordUncheckedCreateInput>
  }

  /**
   * SalaryRecord createMany
   */
  export type SalaryRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryRecords.
     */
    data: SalaryRecordCreateManyInput | SalaryRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryRecord createManyAndReturn
   */
  export type SalaryRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalaryRecords.
     */
    data: SalaryRecordCreateManyInput | SalaryRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryRecord update
   */
  export type SalaryRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryRecord.
     */
    data: XOR<SalaryRecordUpdateInput, SalaryRecordUncheckedUpdateInput>
    /**
     * Choose, which SalaryRecord to update.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord updateMany
   */
  export type SalaryRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryRecords.
     */
    data: XOR<SalaryRecordUpdateManyMutationInput, SalaryRecordUncheckedUpdateManyInput>
    /**
     * Filter which SalaryRecords to update
     */
    where?: SalaryRecordWhereInput
  }

  /**
   * SalaryRecord upsert
   */
  export type SalaryRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryRecord to update in case it exists.
     */
    where: SalaryRecordWhereUniqueInput
    /**
     * In case the SalaryRecord found by the `where` argument doesn't exist, create a new SalaryRecord with this data.
     */
    create: XOR<SalaryRecordCreateInput, SalaryRecordUncheckedCreateInput>
    /**
     * In case the SalaryRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryRecordUpdateInput, SalaryRecordUncheckedUpdateInput>
  }

  /**
   * SalaryRecord delete
   */
  export type SalaryRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
    /**
     * Filter which SalaryRecord to delete.
     */
    where: SalaryRecordWhereUniqueInput
  }

  /**
   * SalaryRecord deleteMany
   */
  export type SalaryRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryRecords to delete
     */
    where?: SalaryRecordWhereInput
  }

  /**
   * SalaryRecord.payments
   */
  export type SalaryRecord$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    cursor?: SalaryPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryRecord without action
   */
  export type SalaryRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryRecord
     */
    select?: SalaryRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryRecordInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPayment
   */

  export type AggregateSalaryPayment = {
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  export type SalaryPaymentAvgAggregateOutputType = {
    salaryPaymentId: number | null
    salaryRecordId: number | null
    amount: Decimal | null
    paidBy: number | null
  }

  export type SalaryPaymentSumAggregateOutputType = {
    salaryPaymentId: bigint | null
    salaryRecordId: bigint | null
    amount: Decimal | null
    paidBy: bigint | null
  }

  export type SalaryPaymentMinAggregateOutputType = {
    salaryPaymentId: bigint | null
    salaryRecordId: bigint | null
    payDate: Date | null
    amount: Decimal | null
    method: $Enums.PayMethod | null
    referenceNo: string | null
    paidBy: bigint | null
    createdAt: Date | null
  }

  export type SalaryPaymentMaxAggregateOutputType = {
    salaryPaymentId: bigint | null
    salaryRecordId: bigint | null
    payDate: Date | null
    amount: Decimal | null
    method: $Enums.PayMethod | null
    referenceNo: string | null
    paidBy: bigint | null
    createdAt: Date | null
  }

  export type SalaryPaymentCountAggregateOutputType = {
    salaryPaymentId: number
    salaryRecordId: number
    payDate: number
    amount: number
    method: number
    referenceNo: number
    paidBy: number
    createdAt: number
    _all: number
  }


  export type SalaryPaymentAvgAggregateInputType = {
    salaryPaymentId?: true
    salaryRecordId?: true
    amount?: true
    paidBy?: true
  }

  export type SalaryPaymentSumAggregateInputType = {
    salaryPaymentId?: true
    salaryRecordId?: true
    amount?: true
    paidBy?: true
  }

  export type SalaryPaymentMinAggregateInputType = {
    salaryPaymentId?: true
    salaryRecordId?: true
    payDate?: true
    amount?: true
    method?: true
    referenceNo?: true
    paidBy?: true
    createdAt?: true
  }

  export type SalaryPaymentMaxAggregateInputType = {
    salaryPaymentId?: true
    salaryRecordId?: true
    payDate?: true
    amount?: true
    method?: true
    referenceNo?: true
    paidBy?: true
    createdAt?: true
  }

  export type SalaryPaymentCountAggregateInputType = {
    salaryPaymentId?: true
    salaryRecordId?: true
    payDate?: true
    amount?: true
    method?: true
    referenceNo?: true
    paidBy?: true
    createdAt?: true
    _all?: true
  }

  export type SalaryPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayment to aggregate.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPayments
    **/
    _count?: true | SalaryPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type GetSalaryPaymentAggregateType<T extends SalaryPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPayment[P]>
      : GetScalarType<T[P], AggregateSalaryPayment[P]>
  }




  export type SalaryPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithAggregationInput | SalaryPaymentOrderByWithAggregationInput[]
    by: SalaryPaymentScalarFieldEnum[] | SalaryPaymentScalarFieldEnum
    having?: SalaryPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPaymentCountAggregateInputType | true
    _avg?: SalaryPaymentAvgAggregateInputType
    _sum?: SalaryPaymentSumAggregateInputType
    _min?: SalaryPaymentMinAggregateInputType
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type SalaryPaymentGroupByOutputType = {
    salaryPaymentId: bigint
    salaryRecordId: bigint
    payDate: Date
    amount: Decimal
    method: $Enums.PayMethod
    referenceNo: string | null
    paidBy: bigint | null
    createdAt: Date
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  type GetSalaryPaymentGroupByPayload<T extends SalaryPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salaryPaymentId?: boolean
    salaryRecordId?: boolean
    payDate?: boolean
    amount?: boolean
    method?: boolean
    referenceNo?: boolean
    paidBy?: boolean
    createdAt?: boolean
    payer?: boolean | SalaryPayment$payerArgs<ExtArgs>
    salaryRecord?: boolean | SalaryRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salaryPaymentId?: boolean
    salaryRecordId?: boolean
    payDate?: boolean
    amount?: boolean
    method?: boolean
    referenceNo?: boolean
    paidBy?: boolean
    createdAt?: boolean
    payer?: boolean | SalaryPayment$payerArgs<ExtArgs>
    salaryRecord?: boolean | SalaryRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectScalar = {
    salaryPaymentId?: boolean
    salaryRecordId?: boolean
    payDate?: boolean
    amount?: boolean
    method?: boolean
    referenceNo?: boolean
    paidBy?: boolean
    createdAt?: boolean
  }

  export type SalaryPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payer?: boolean | SalaryPayment$payerArgs<ExtArgs>
    salaryRecord?: boolean | SalaryRecordDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payer?: boolean | SalaryPayment$payerArgs<ExtArgs>
    salaryRecord?: boolean | SalaryRecordDefaultArgs<ExtArgs>
  }

  export type $SalaryPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPayment"
    objects: {
      payer: Prisma.$UserPayload<ExtArgs> | null
      salaryRecord: Prisma.$SalaryRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      salaryPaymentId: bigint
      salaryRecordId: bigint
      payDate: Date
      amount: Prisma.Decimal
      method: $Enums.PayMethod
      referenceNo: string | null
      paidBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["salaryPayment"]>
    composites: {}
  }

  type SalaryPaymentGetPayload<S extends boolean | null | undefined | SalaryPaymentDefaultArgs> = $Result.GetResult<Prisma.$SalaryPaymentPayload, S>

  type SalaryPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryPaymentCountAggregateInputType | true
    }

  export interface SalaryPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPayment'], meta: { name: 'SalaryPayment' } }
    /**
     * Find zero or one SalaryPayment that matches the filter.
     * @param {SalaryPaymentFindUniqueArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPaymentFindUniqueArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalaryPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryPaymentFindUniqueOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalaryPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPaymentFindFirstArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalaryPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany()
     * 
     * // Get first 10 SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany({ take: 10 })
     * 
     * // Only select the `salaryPaymentId`
     * const salaryPaymentWithSalaryPaymentIdOnly = await prisma.salaryPayment.findMany({ select: { salaryPaymentId: true } })
     * 
     */
    findMany<T extends SalaryPaymentFindManyArgs>(args?: SelectSubset<T, SalaryPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalaryPayment.
     * @param {SalaryPaymentCreateArgs} args - Arguments to create a SalaryPayment.
     * @example
     * // Create one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.create({
     *   data: {
     *     // ... data to create a SalaryPayment
     *   }
     * })
     * 
     */
    create<T extends SalaryPaymentCreateArgs>(args: SelectSubset<T, SalaryPaymentCreateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalaryPayments.
     * @param {SalaryPaymentCreateManyArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPaymentCreateManyArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPayments and returns the data saved in the database.
     * @param {SalaryPaymentCreateManyAndReturnArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPayments and only return the `salaryPaymentId`
     * const salaryPaymentWithSalaryPaymentIdOnly = await prisma.salaryPayment.createManyAndReturn({ 
     *   select: { salaryPaymentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalaryPayment.
     * @param {SalaryPaymentDeleteArgs} args - Arguments to delete one SalaryPayment.
     * @example
     * // Delete one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.delete({
     *   where: {
     *     // ... filter to delete one SalaryPayment
     *   }
     * })
     * 
     */
    delete<T extends SalaryPaymentDeleteArgs>(args: SelectSubset<T, SalaryPaymentDeleteArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalaryPayment.
     * @param {SalaryPaymentUpdateArgs} args - Arguments to update one SalaryPayment.
     * @example
     * // Update one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPaymentUpdateArgs>(args: SelectSubset<T, SalaryPaymentUpdateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalaryPayments.
     * @param {SalaryPaymentDeleteManyArgs} args - Arguments to filter SalaryPayments to delete.
     * @example
     * // Delete a few SalaryPayments
     * const { count } = await prisma.salaryPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPaymentDeleteManyArgs>(args?: SelectSubset<T, SalaryPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPaymentUpdateManyArgs>(args: SelectSubset<T, SalaryPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryPayment.
     * @param {SalaryPaymentUpsertArgs} args - Arguments to update or create a SalaryPayment.
     * @example
     * // Update or create a SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.upsert({
     *   create: {
     *     // ... data to create a SalaryPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPayment we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPaymentUpsertArgs>(args: SelectSubset<T, SalaryPaymentUpsertArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentCountArgs} args - Arguments to filter SalaryPayments to count.
     * @example
     * // Count the number of SalaryPayments
     * const count = await prisma.salaryPayment.count({
     *   where: {
     *     // ... the filter for the SalaryPayments we want to count
     *   }
     * })
    **/
    count<T extends SalaryPaymentCountArgs>(
      args?: Subset<T, SalaryPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPaymentAggregateArgs>(args: Subset<T, SalaryPaymentAggregateArgs>): Prisma.PrismaPromise<GetSalaryPaymentAggregateType<T>>

    /**
     * Group by SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPayment model
   */
  readonly fields: SalaryPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payer<T extends SalaryPayment$payerArgs<ExtArgs> = {}>(args?: Subset<T, SalaryPayment$payerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    salaryRecord<T extends SalaryRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaryRecordDefaultArgs<ExtArgs>>): Prisma__SalaryRecordClient<$Result.GetResult<Prisma.$SalaryRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPayment model
   */ 
  interface SalaryPaymentFieldRefs {
    readonly salaryPaymentId: FieldRef<"SalaryPayment", 'BigInt'>
    readonly salaryRecordId: FieldRef<"SalaryPayment", 'BigInt'>
    readonly payDate: FieldRef<"SalaryPayment", 'DateTime'>
    readonly amount: FieldRef<"SalaryPayment", 'Decimal'>
    readonly method: FieldRef<"SalaryPayment", 'PayMethod'>
    readonly referenceNo: FieldRef<"SalaryPayment", 'String'>
    readonly paidBy: FieldRef<"SalaryPayment", 'BigInt'>
    readonly createdAt: FieldRef<"SalaryPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPayment findUnique
   */
  export type SalaryPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findUniqueOrThrow
   */
  export type SalaryPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findFirst
   */
  export type SalaryPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findFirstOrThrow
   */
  export type SalaryPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findMany
   */
  export type SalaryPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment create
   */
  export type SalaryPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPayment.
     */
    data: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
  }

  /**
   * SalaryPayment createMany
   */
  export type SalaryPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryPayment createManyAndReturn
   */
  export type SalaryPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayment update
   */
  export type SalaryPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPayment.
     */
    data: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
    /**
     * Choose, which SalaryPayment to update.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment updateMany
   */
  export type SalaryPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentWhereInput
  }

  /**
   * SalaryPayment upsert
   */
  export type SalaryPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPayment to update in case it exists.
     */
    where: SalaryPaymentWhereUniqueInput
    /**
     * In case the SalaryPayment found by the `where` argument doesn't exist, create a new SalaryPayment with this data.
     */
    create: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
    /**
     * In case the SalaryPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
  }

  /**
   * SalaryPayment delete
   */
  export type SalaryPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter which SalaryPayment to delete.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment deleteMany
   */
  export type SalaryPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to delete
     */
    where?: SalaryPaymentWhereInput
  }

  /**
   * SalaryPayment.payer
   */
  export type SalaryPayment$payerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SalaryPayment without action
   */
  export type SalaryPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    unitId: number | null
  }

  export type UnitSumAggregateOutputType = {
    unitId: number | null
  }

  export type UnitMinAggregateOutputType = {
    unitId: number | null
    unitName: string | null
    symbol: string | null
  }

  export type UnitMaxAggregateOutputType = {
    unitId: number | null
    unitName: string | null
    symbol: string | null
  }

  export type UnitCountAggregateOutputType = {
    unitId: number
    unitName: number
    symbol: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    unitId?: true
  }

  export type UnitSumAggregateInputType = {
    unitId?: true
  }

  export type UnitMinAggregateInputType = {
    unitId?: true
    unitName?: true
    symbol?: true
  }

  export type UnitMaxAggregateInputType = {
    unitId?: true
    unitName?: true
    symbol?: true
  }

  export type UnitCountAggregateInputType = {
    unitId?: true
    unitName?: true
    symbol?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    unitId: number
    unitName: string
    symbol: string | null
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    unitId?: boolean
    unitName?: boolean
    symbol?: boolean
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    unitId?: boolean
    unitName?: boolean
    symbol?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    unitId?: boolean
    unitName?: boolean
    symbol?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Unit$itemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      unitId: number
      unitName: string
      symbol: string | null
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `unitId`
     * const unitWithUnitIdOnly = await prisma.unit.findMany({ select: { unitId: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `unitId`
     * const unitWithUnitIdOnly = await prisma.unit.createManyAndReturn({ 
     *   select: { unitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Unit$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly unitId: FieldRef<"Unit", 'Int'>
    readonly unitName: FieldRef<"Unit", 'String'>
    readonly symbol: FieldRef<"Unit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }

  /**
   * Unit.items
   */
  export type Unit$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategory
   */

  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryAvgAggregateOutputType = {
    categoryId: number | null
  }

  export type ItemCategorySumAggregateOutputType = {
    categoryId: number | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    categoryId: number | null
    categoryName: string | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    categoryId: number | null
    categoryName: string | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    categoryId: number
    categoryName: number
    _all: number
  }


  export type ItemCategoryAvgAggregateInputType = {
    categoryId?: true
  }

  export type ItemCategorySumAggregateInputType = {
    categoryId?: true
  }

  export type ItemCategoryMinAggregateInputType = {
    categoryId?: true
    categoryName?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    categoryId?: true
    categoryName?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    categoryId?: true
    categoryName?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithAggregationInput | ItemCategoryOrderByWithAggregationInput[]
    by: ItemCategoryScalarFieldEnum[] | ItemCategoryScalarFieldEnum
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _avg?: ItemCategoryAvgAggregateInputType
    _sum?: ItemCategorySumAggregateInputType
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type ItemCategoryGroupByOutputType = {
    categoryId: number
    categoryName: string
    _count: ItemCategoryCountAggregateOutputType | null
    _avg: ItemCategoryAvgAggregateOutputType | null
    _sum: ItemCategorySumAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryId?: boolean
    categoryName?: boolean
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryId?: boolean
    categoryName?: boolean
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectScalar = {
    categoryId?: boolean
    categoryName?: boolean
  }

  export type ItemCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategory"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      categoryId: number
      categoryName: string
    }, ExtArgs["result"]["itemCategory"]>
    composites: {}
  }

  type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryPayload, S>

  type ItemCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategory'], meta: { name: 'ItemCategory' } }
    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ItemCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `categoryId`
     * const itemCategoryWithCategoryIdOnly = await prisma.itemCategory.findMany({ select: { categoryId: true } })
     * 
     */
    findMany<T extends ItemCategoryFindManyArgs>(args?: SelectSubset<T, ItemCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCreateArgs>(args: SelectSubset<T, ItemCategoryCreateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ItemCategories.
     * @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategories and returns the data saved in the database.
     * @param {ItemCategoryCreateManyAndReturnArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategories and only return the `categoryId`
     * const itemCategoryWithCategoryIdOnly = await prisma.itemCategory.createManyAndReturn({ 
     *   select: { categoryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryDeleteArgs>(args: SelectSubset<T, ItemCategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryUpdateArgs>(args: SelectSubset<T, ItemCategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryUpsertArgs>(args: SelectSubset<T, ItemCategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategory model
   */
  readonly fields: ItemCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends ItemCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategory model
   */ 
  interface ItemCategoryFieldRefs {
    readonly categoryId: FieldRef<"ItemCategory", 'Int'>
    readonly categoryName: FieldRef<"ItemCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategory findUnique
   */
  export type ItemCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findFirst
   */
  export type ItemCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }

  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory createManyAndReturn
   */
  export type ItemCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory.items
   */
  export type ItemCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * ItemCategory without action
   */
  export type ItemCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    itemId: number | null
    categoryId: number | null
    unitId: number | null
  }

  export type ItemSumAggregateOutputType = {
    itemId: bigint | null
    categoryId: number | null
    unitId: number | null
  }

  export type ItemMinAggregateOutputType = {
    itemId: bigint | null
    itemCode: string | null
    itemName: string | null
    itemType: $Enums.ItemType | null
    categoryId: number | null
    unitId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    itemId: bigint | null
    itemCode: string | null
    itemName: string | null
    itemType: $Enums.ItemType | null
    categoryId: number | null
    unitId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    itemId: number
    itemCode: number
    itemName: number
    itemType: number
    categoryId: number
    unitId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    itemId?: true
    categoryId?: true
    unitId?: true
  }

  export type ItemSumAggregateInputType = {
    itemId?: true
    categoryId?: true
    unitId?: true
  }

  export type ItemMinAggregateInputType = {
    itemId?: true
    itemCode?: true
    itemName?: true
    itemType?: true
    categoryId?: true
    unitId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    itemId?: true
    itemCode?: true
    itemName?: true
    itemType?: true
    categoryId?: true
    unitId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    itemId?: true
    itemCode?: true
    itemName?: true
    itemType?: true
    categoryId?: true
    unitId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    itemId: bigint
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId: number | null
    unitId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    itemCode?: boolean
    itemName?: boolean
    itemType?: boolean
    categoryId?: boolean
    unitId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerPrices?: boolean | Item$customerPricesArgs<ExtArgs>
    invoiceLines?: boolean | Item$invoiceLinesArgs<ExtArgs>
    category?: boolean | Item$categoryArgs<ExtArgs>
    unit?: boolean | Item$unitArgs<ExtArgs>
    productionDays?: boolean | Item$productionDaysArgs<ExtArgs>
    purchaseOrderLines?: boolean | Item$purchaseOrderLinesArgs<ExtArgs>
    salesOrderLines?: boolean | Item$salesOrderLinesArgs<ExtArgs>
    stockBalance?: boolean | Item$stockBalanceArgs<ExtArgs>
    stockMovements?: boolean | Item$stockMovementsArgs<ExtArgs>
    supplierPrices?: boolean | Item$supplierPricesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    itemCode?: boolean
    itemName?: boolean
    itemType?: boolean
    categoryId?: boolean
    unitId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Item$categoryArgs<ExtArgs>
    unit?: boolean | Item$unitArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    itemId?: boolean
    itemCode?: boolean
    itemName?: boolean
    itemType?: boolean
    categoryId?: boolean
    unitId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerPrices?: boolean | Item$customerPricesArgs<ExtArgs>
    invoiceLines?: boolean | Item$invoiceLinesArgs<ExtArgs>
    category?: boolean | Item$categoryArgs<ExtArgs>
    unit?: boolean | Item$unitArgs<ExtArgs>
    productionDays?: boolean | Item$productionDaysArgs<ExtArgs>
    purchaseOrderLines?: boolean | Item$purchaseOrderLinesArgs<ExtArgs>
    salesOrderLines?: boolean | Item$salesOrderLinesArgs<ExtArgs>
    stockBalance?: boolean | Item$stockBalanceArgs<ExtArgs>
    stockMovements?: boolean | Item$stockMovementsArgs<ExtArgs>
    supplierPrices?: boolean | Item$supplierPricesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Item$categoryArgs<ExtArgs>
    unit?: boolean | Item$unitArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      customerPrices: Prisma.$CustomerItemPricePayload<ExtArgs>[]
      invoiceLines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      category: Prisma.$ItemCategoryPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      productionDays: Prisma.$ProductionDayPayload<ExtArgs>[]
      purchaseOrderLines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      salesOrderLines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      stockBalance: Prisma.$StockBalancePayload<ExtArgs> | null
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      supplierPrices: Prisma.$SupplierItemPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      itemId: bigint
      itemCode: string
      itemName: string
      itemType: $Enums.ItemType
      categoryId: number | null
      unitId: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemWithItemIdOnly = await prisma.item.findMany({ select: { itemId: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `itemId`
     * const itemWithItemIdOnly = await prisma.item.createManyAndReturn({ 
     *   select: { itemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerPrices<T extends Item$customerPricesArgs<ExtArgs> = {}>(args?: Subset<T, Item$customerPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findMany"> | Null>
    invoiceLines<T extends Item$invoiceLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$invoiceLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends Item$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Item$categoryArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    unit<T extends Item$unitArgs<ExtArgs> = {}>(args?: Subset<T, Item$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productionDays<T extends Item$productionDaysArgs<ExtArgs> = {}>(args?: Subset<T, Item$productionDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrderLines<T extends Item$purchaseOrderLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$purchaseOrderLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany"> | Null>
    salesOrderLines<T extends Item$salesOrderLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$salesOrderLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany"> | Null>
    stockBalance<T extends Item$stockBalanceArgs<ExtArgs> = {}>(args?: Subset<T, Item$stockBalanceArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stockMovements<T extends Item$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Item$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    supplierPrices<T extends Item$supplierPricesArgs<ExtArgs> = {}>(args?: Subset<T, Item$supplierPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly itemId: FieldRef<"Item", 'BigInt'>
    readonly itemCode: FieldRef<"Item", 'String'>
    readonly itemName: FieldRef<"Item", 'String'>
    readonly itemType: FieldRef<"Item", 'ItemType'>
    readonly categoryId: FieldRef<"Item", 'Int'>
    readonly unitId: FieldRef<"Item", 'Int'>
    readonly isActive: FieldRef<"Item", 'Boolean'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }

  /**
   * Item.customerPrices
   */
  export type Item$customerPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    where?: CustomerItemPriceWhereInput
    orderBy?: CustomerItemPriceOrderByWithRelationInput | CustomerItemPriceOrderByWithRelationInput[]
    cursor?: CustomerItemPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerItemPriceScalarFieldEnum | CustomerItemPriceScalarFieldEnum[]
  }

  /**
   * Item.invoiceLines
   */
  export type Item$invoiceLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Item.category
   */
  export type Item$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
  }

  /**
   * Item.unit
   */
  export type Item$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Item.productionDays
   */
  export type Item$productionDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    where?: ProductionDayWhereInput
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    cursor?: ProductionDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * Item.purchaseOrderLines
   */
  export type Item$purchaseOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * Item.salesOrderLines
   */
  export type Item$salesOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * Item.stockBalance
   */
  export type Item$stockBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    where?: StockBalanceWhereInput
  }

  /**
   * Item.stockMovements
   */
  export type Item$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Item.supplierPrices
   */
  export type Item$supplierPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    where?: SupplierItemPriceWhereInput
    orderBy?: SupplierItemPriceOrderByWithRelationInput | SupplierItemPriceOrderByWithRelationInput[]
    cursor?: SupplierItemPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierItemPriceScalarFieldEnum | SupplierItemPriceScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    supplierId: number | null
    createdBy: number | null
    updatedBy: number | null
    deactivatedBy: number | null
  }

  export type SupplierSumAggregateOutputType = {
    supplierId: bigint | null
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedBy: bigint | null
  }

  export type SupplierMinAggregateOutputType = {
    supplierId: bigint | null
    supplierCode: string | null
    supplierName: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedAt: Date | null
    deactivatedBy: bigint | null
  }

  export type SupplierMaxAggregateOutputType = {
    supplierId: bigint | null
    supplierCode: string | null
    supplierName: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedAt: Date | null
    deactivatedBy: bigint | null
  }

  export type SupplierCountAggregateOutputType = {
    supplierId: number
    supplierCode: number
    supplierName: number
    contactName: number
    phone: number
    email: number
    address: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    deactivatedAt: number
    deactivatedBy: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    supplierId?: true
    createdBy?: true
    updatedBy?: true
    deactivatedBy?: true
  }

  export type SupplierSumAggregateInputType = {
    supplierId?: true
    createdBy?: true
    updatedBy?: true
    deactivatedBy?: true
  }

  export type SupplierMinAggregateInputType = {
    supplierId?: true
    supplierCode?: true
    supplierName?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type SupplierMaxAggregateInputType = {
    supplierId?: true
    supplierCode?: true
    supplierName?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type SupplierCountAggregateInputType = {
    supplierId?: true
    supplierCode?: true
    supplierName?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    supplierId: bigint
    supplierCode: string
    supplierName: string
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedAt: Date | null
    deactivatedBy: bigint | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    supplierCode?: boolean
    supplierName?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
    expenses?: boolean | Supplier$expensesArgs<ExtArgs>
    invoices?: boolean | Supplier$invoicesArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    itemPrices?: boolean | Supplier$itemPricesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierId?: boolean
    supplierCode?: boolean
    supplierName?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    supplierId?: boolean
    supplierCode?: boolean
    supplierName?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | Supplier$expensesArgs<ExtArgs>
    invoices?: boolean | Supplier$invoicesArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    itemPrices?: boolean | Supplier$itemPricesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      itemPrices: Prisma.$SupplierItemPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      supplierId: bigint
      supplierCode: string
      supplierName: string
      contactName: string | null
      phone: string | null
      email: string | null
      address: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: bigint | null
      updatedBy: bigint | null
      deactivatedAt: Date | null
      deactivatedBy: bigint | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `supplierId`
     * const supplierWithSupplierIdOnly = await prisma.supplier.findMany({ select: { supplierId: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `supplierId`
     * const supplierWithSupplierIdOnly = await prisma.supplier.createManyAndReturn({ 
     *   select: { supplierId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends Supplier$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Supplier$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    itemPrices<T extends Supplier$itemPricesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$itemPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly supplierId: FieldRef<"Supplier", 'BigInt'>
    readonly supplierCode: FieldRef<"Supplier", 'String'>
    readonly supplierName: FieldRef<"Supplier", 'String'>
    readonly contactName: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
    readonly createdBy: FieldRef<"Supplier", 'BigInt'>
    readonly updatedBy: FieldRef<"Supplier", 'BigInt'>
    readonly deactivatedAt: FieldRef<"Supplier", 'DateTime'>
    readonly deactivatedBy: FieldRef<"Supplier", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.expenses
   */
  export type Supplier$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Supplier.invoices
   */
  export type Supplier$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier.itemPrices
   */
  export type Supplier$itemPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    where?: SupplierItemPriceWhereInput
    orderBy?: SupplierItemPriceOrderByWithRelationInput | SupplierItemPriceOrderByWithRelationInput[]
    cursor?: SupplierItemPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierItemPriceScalarFieldEnum | SupplierItemPriceScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    customerId: number | null
    createdBy: number | null
    updatedBy: number | null
    deactivatedBy: number | null
  }

  export type CustomerSumAggregateOutputType = {
    customerId: bigint | null
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedBy: bigint | null
  }

  export type CustomerMinAggregateOutputType = {
    customerId: bigint | null
    customerCode: string | null
    customerName: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedAt: Date | null
    deactivatedBy: bigint | null
  }

  export type CustomerMaxAggregateOutputType = {
    customerId: bigint | null
    customerCode: string | null
    customerName: string | null
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedAt: Date | null
    deactivatedBy: bigint | null
  }

  export type CustomerCountAggregateOutputType = {
    customerId: number
    customerCode: number
    customerName: number
    contactName: number
    phone: number
    email: number
    address: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    deactivatedAt: number
    deactivatedBy: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    customerId?: true
    createdBy?: true
    updatedBy?: true
    deactivatedBy?: true
  }

  export type CustomerSumAggregateInputType = {
    customerId?: true
    createdBy?: true
    updatedBy?: true
    deactivatedBy?: true
  }

  export type CustomerMinAggregateInputType = {
    customerId?: true
    customerCode?: true
    customerName?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type CustomerMaxAggregateInputType = {
    customerId?: true
    customerCode?: true
    customerName?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
  }

  export type CustomerCountAggregateInputType = {
    customerId?: true
    customerCode?: true
    customerName?: true
    contactName?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deactivatedAt?: true
    deactivatedBy?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    customerId: bigint
    customerCode: string
    customerName: string
    contactName: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: bigint | null
    updatedBy: bigint | null
    deactivatedAt: Date | null
    deactivatedBy: bigint | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerCode?: boolean
    customerName?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
    itemPrices?: boolean | Customer$itemPricesArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    salesOrders?: boolean | Customer$salesOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerCode?: boolean
    customerName?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    customerId?: boolean
    customerCode?: boolean
    customerName?: boolean
    contactName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deactivatedAt?: boolean
    deactivatedBy?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemPrices?: boolean | Customer$itemPricesArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    salesOrders?: boolean | Customer$salesOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      itemPrices: Prisma.$CustomerItemPricePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      salesOrders: Prisma.$SalesOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      customerId: bigint
      customerCode: string
      customerName: string
      contactName: string | null
      phone: string | null
      email: string | null
      address: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: bigint | null
      updatedBy: bigint | null
      deactivatedAt: Date | null
      deactivatedBy: bigint | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const customerWithCustomerIdOnly = await prisma.customer.findMany({ select: { customerId: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `customerId`
     * const customerWithCustomerIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { customerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemPrices<T extends Customer$itemPricesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$itemPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    salesOrders<T extends Customer$salesOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly customerId: FieldRef<"Customer", 'BigInt'>
    readonly customerCode: FieldRef<"Customer", 'String'>
    readonly customerName: FieldRef<"Customer", 'String'>
    readonly contactName: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly createdBy: FieldRef<"Customer", 'BigInt'>
    readonly updatedBy: FieldRef<"Customer", 'BigInt'>
    readonly deactivatedAt: FieldRef<"Customer", 'DateTime'>
    readonly deactivatedBy: FieldRef<"Customer", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.itemPrices
   */
  export type Customer$itemPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    where?: CustomerItemPriceWhereInput
    orderBy?: CustomerItemPriceOrderByWithRelationInput | CustomerItemPriceOrderByWithRelationInput[]
    cursor?: CustomerItemPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerItemPriceScalarFieldEnum | CustomerItemPriceScalarFieldEnum[]
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.salesOrders
   */
  export type Customer$salesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model SupplierItemPrice
   */

  export type AggregateSupplierItemPrice = {
    _count: SupplierItemPriceCountAggregateOutputType | null
    _avg: SupplierItemPriceAvgAggregateOutputType | null
    _sum: SupplierItemPriceSumAggregateOutputType | null
    _min: SupplierItemPriceMinAggregateOutputType | null
    _max: SupplierItemPriceMaxAggregateOutputType | null
  }

  export type SupplierItemPriceAvgAggregateOutputType = {
    supplierItemPriceId: number | null
    supplierId: number | null
    itemId: number | null
    unitPrice: Decimal | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type SupplierItemPriceSumAggregateOutputType = {
    supplierItemPriceId: bigint | null
    supplierId: bigint | null
    itemId: bigint | null
    unitPrice: Decimal | null
    createdBy: bigint | null
    updatedBy: bigint | null
  }

  export type SupplierItemPriceMinAggregateOutputType = {
    supplierItemPriceId: bigint | null
    supplierId: bigint | null
    itemId: bigint | null
    unitPrice: Decimal | null
    effectiveFrom: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
  }

  export type SupplierItemPriceMaxAggregateOutputType = {
    supplierItemPriceId: bigint | null
    supplierId: bigint | null
    itemId: bigint | null
    unitPrice: Decimal | null
    effectiveFrom: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
  }

  export type SupplierItemPriceCountAggregateOutputType = {
    supplierItemPriceId: number
    supplierId: number
    itemId: number
    unitPrice: number
    effectiveFrom: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type SupplierItemPriceAvgAggregateInputType = {
    supplierItemPriceId?: true
    supplierId?: true
    itemId?: true
    unitPrice?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SupplierItemPriceSumAggregateInputType = {
    supplierItemPriceId?: true
    supplierId?: true
    itemId?: true
    unitPrice?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SupplierItemPriceMinAggregateInputType = {
    supplierItemPriceId?: true
    supplierId?: true
    itemId?: true
    unitPrice?: true
    effectiveFrom?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SupplierItemPriceMaxAggregateInputType = {
    supplierItemPriceId?: true
    supplierId?: true
    itemId?: true
    unitPrice?: true
    effectiveFrom?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type SupplierItemPriceCountAggregateInputType = {
    supplierItemPriceId?: true
    supplierId?: true
    itemId?: true
    unitPrice?: true
    effectiveFrom?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type SupplierItemPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierItemPrice to aggregate.
     */
    where?: SupplierItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItemPrices to fetch.
     */
    orderBy?: SupplierItemPriceOrderByWithRelationInput | SupplierItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierItemPrices
    **/
    _count?: true | SupplierItemPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierItemPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierItemPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierItemPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierItemPriceMaxAggregateInputType
  }

  export type GetSupplierItemPriceAggregateType<T extends SupplierItemPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierItemPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierItemPrice[P]>
      : GetScalarType<T[P], AggregateSupplierItemPrice[P]>
  }




  export type SupplierItemPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierItemPriceWhereInput
    orderBy?: SupplierItemPriceOrderByWithAggregationInput | SupplierItemPriceOrderByWithAggregationInput[]
    by: SupplierItemPriceScalarFieldEnum[] | SupplierItemPriceScalarFieldEnum
    having?: SupplierItemPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierItemPriceCountAggregateInputType | true
    _avg?: SupplierItemPriceAvgAggregateInputType
    _sum?: SupplierItemPriceSumAggregateInputType
    _min?: SupplierItemPriceMinAggregateInputType
    _max?: SupplierItemPriceMaxAggregateInputType
  }

  export type SupplierItemPriceGroupByOutputType = {
    supplierItemPriceId: bigint
    supplierId: bigint
    itemId: bigint
    unitPrice: Decimal
    effectiveFrom: Date
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: bigint | null
    updatedBy: bigint | null
    _count: SupplierItemPriceCountAggregateOutputType | null
    _avg: SupplierItemPriceAvgAggregateOutputType | null
    _sum: SupplierItemPriceSumAggregateOutputType | null
    _min: SupplierItemPriceMinAggregateOutputType | null
    _max: SupplierItemPriceMaxAggregateOutputType | null
  }

  type GetSupplierItemPriceGroupByPayload<T extends SupplierItemPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierItemPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierItemPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierItemPriceGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierItemPriceGroupByOutputType[P]>
        }
      >
    >


  export type SupplierItemPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierItemPriceId?: boolean
    supplierId?: boolean
    itemId?: boolean
    unitPrice?: boolean
    effectiveFrom?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierItemPrice"]>

  export type SupplierItemPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supplierItemPriceId?: boolean
    supplierId?: boolean
    itemId?: boolean
    unitPrice?: boolean
    effectiveFrom?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierItemPrice"]>

  export type SupplierItemPriceSelectScalar = {
    supplierItemPriceId?: boolean
    supplierId?: boolean
    itemId?: boolean
    unitPrice?: boolean
    effectiveFrom?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type SupplierItemPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierItemPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierItemPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierItemPrice"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      supplierItemPriceId: bigint
      supplierId: bigint
      itemId: bigint
      unitPrice: Prisma.Decimal
      effectiveFrom: Date
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: bigint | null
      updatedBy: bigint | null
    }, ExtArgs["result"]["supplierItemPrice"]>
    composites: {}
  }

  type SupplierItemPriceGetPayload<S extends boolean | null | undefined | SupplierItemPriceDefaultArgs> = $Result.GetResult<Prisma.$SupplierItemPricePayload, S>

  type SupplierItemPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierItemPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierItemPriceCountAggregateInputType | true
    }

  export interface SupplierItemPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierItemPrice'], meta: { name: 'SupplierItemPrice' } }
    /**
     * Find zero or one SupplierItemPrice that matches the filter.
     * @param {SupplierItemPriceFindUniqueArgs} args - Arguments to find a SupplierItemPrice
     * @example
     * // Get one SupplierItemPrice
     * const supplierItemPrice = await prisma.supplierItemPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierItemPriceFindUniqueArgs>(args: SelectSubset<T, SupplierItemPriceFindUniqueArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupplierItemPrice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierItemPriceFindUniqueOrThrowArgs} args - Arguments to find a SupplierItemPrice
     * @example
     * // Get one SupplierItemPrice
     * const supplierItemPrice = await prisma.supplierItemPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierItemPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierItemPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupplierItemPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceFindFirstArgs} args - Arguments to find a SupplierItemPrice
     * @example
     * // Get one SupplierItemPrice
     * const supplierItemPrice = await prisma.supplierItemPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierItemPriceFindFirstArgs>(args?: SelectSubset<T, SupplierItemPriceFindFirstArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupplierItemPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceFindFirstOrThrowArgs} args - Arguments to find a SupplierItemPrice
     * @example
     * // Get one SupplierItemPrice
     * const supplierItemPrice = await prisma.supplierItemPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierItemPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierItemPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupplierItemPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierItemPrices
     * const supplierItemPrices = await prisma.supplierItemPrice.findMany()
     * 
     * // Get first 10 SupplierItemPrices
     * const supplierItemPrices = await prisma.supplierItemPrice.findMany({ take: 10 })
     * 
     * // Only select the `supplierItemPriceId`
     * const supplierItemPriceWithSupplierItemPriceIdOnly = await prisma.supplierItemPrice.findMany({ select: { supplierItemPriceId: true } })
     * 
     */
    findMany<T extends SupplierItemPriceFindManyArgs>(args?: SelectSubset<T, SupplierItemPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupplierItemPrice.
     * @param {SupplierItemPriceCreateArgs} args - Arguments to create a SupplierItemPrice.
     * @example
     * // Create one SupplierItemPrice
     * const SupplierItemPrice = await prisma.supplierItemPrice.create({
     *   data: {
     *     // ... data to create a SupplierItemPrice
     *   }
     * })
     * 
     */
    create<T extends SupplierItemPriceCreateArgs>(args: SelectSubset<T, SupplierItemPriceCreateArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupplierItemPrices.
     * @param {SupplierItemPriceCreateManyArgs} args - Arguments to create many SupplierItemPrices.
     * @example
     * // Create many SupplierItemPrices
     * const supplierItemPrice = await prisma.supplierItemPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierItemPriceCreateManyArgs>(args?: SelectSubset<T, SupplierItemPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierItemPrices and returns the data saved in the database.
     * @param {SupplierItemPriceCreateManyAndReturnArgs} args - Arguments to create many SupplierItemPrices.
     * @example
     * // Create many SupplierItemPrices
     * const supplierItemPrice = await prisma.supplierItemPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierItemPrices and only return the `supplierItemPriceId`
     * const supplierItemPriceWithSupplierItemPriceIdOnly = await prisma.supplierItemPrice.createManyAndReturn({ 
     *   select: { supplierItemPriceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierItemPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierItemPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupplierItemPrice.
     * @param {SupplierItemPriceDeleteArgs} args - Arguments to delete one SupplierItemPrice.
     * @example
     * // Delete one SupplierItemPrice
     * const SupplierItemPrice = await prisma.supplierItemPrice.delete({
     *   where: {
     *     // ... filter to delete one SupplierItemPrice
     *   }
     * })
     * 
     */
    delete<T extends SupplierItemPriceDeleteArgs>(args: SelectSubset<T, SupplierItemPriceDeleteArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupplierItemPrice.
     * @param {SupplierItemPriceUpdateArgs} args - Arguments to update one SupplierItemPrice.
     * @example
     * // Update one SupplierItemPrice
     * const supplierItemPrice = await prisma.supplierItemPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierItemPriceUpdateArgs>(args: SelectSubset<T, SupplierItemPriceUpdateArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupplierItemPrices.
     * @param {SupplierItemPriceDeleteManyArgs} args - Arguments to filter SupplierItemPrices to delete.
     * @example
     * // Delete a few SupplierItemPrices
     * const { count } = await prisma.supplierItemPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierItemPriceDeleteManyArgs>(args?: SelectSubset<T, SupplierItemPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierItemPrices
     * const supplierItemPrice = await prisma.supplierItemPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierItemPriceUpdateManyArgs>(args: SelectSubset<T, SupplierItemPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplierItemPrice.
     * @param {SupplierItemPriceUpsertArgs} args - Arguments to update or create a SupplierItemPrice.
     * @example
     * // Update or create a SupplierItemPrice
     * const supplierItemPrice = await prisma.supplierItemPrice.upsert({
     *   create: {
     *     // ... data to create a SupplierItemPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierItemPrice we want to update
     *   }
     * })
     */
    upsert<T extends SupplierItemPriceUpsertArgs>(args: SelectSubset<T, SupplierItemPriceUpsertArgs<ExtArgs>>): Prisma__SupplierItemPriceClient<$Result.GetResult<Prisma.$SupplierItemPricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupplierItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceCountArgs} args - Arguments to filter SupplierItemPrices to count.
     * @example
     * // Count the number of SupplierItemPrices
     * const count = await prisma.supplierItemPrice.count({
     *   where: {
     *     // ... the filter for the SupplierItemPrices we want to count
     *   }
     * })
    **/
    count<T extends SupplierItemPriceCountArgs>(
      args?: Subset<T, SupplierItemPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierItemPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierItemPriceAggregateArgs>(args: Subset<T, SupplierItemPriceAggregateArgs>): Prisma.PrismaPromise<GetSupplierItemPriceAggregateType<T>>

    /**
     * Group by SupplierItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierItemPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierItemPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierItemPriceGroupByArgs['orderBy'] }
        : { orderBy?: SupplierItemPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierItemPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierItemPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierItemPrice model
   */
  readonly fields: SupplierItemPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierItemPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierItemPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierItemPrice model
   */ 
  interface SupplierItemPriceFieldRefs {
    readonly supplierItemPriceId: FieldRef<"SupplierItemPrice", 'BigInt'>
    readonly supplierId: FieldRef<"SupplierItemPrice", 'BigInt'>
    readonly itemId: FieldRef<"SupplierItemPrice", 'BigInt'>
    readonly unitPrice: FieldRef<"SupplierItemPrice", 'Decimal'>
    readonly effectiveFrom: FieldRef<"SupplierItemPrice", 'DateTime'>
    readonly endDate: FieldRef<"SupplierItemPrice", 'DateTime'>
    readonly isActive: FieldRef<"SupplierItemPrice", 'Boolean'>
    readonly createdAt: FieldRef<"SupplierItemPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierItemPrice", 'DateTime'>
    readonly createdBy: FieldRef<"SupplierItemPrice", 'BigInt'>
    readonly updatedBy: FieldRef<"SupplierItemPrice", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * SupplierItemPrice findUnique
   */
  export type SupplierItemPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItemPrice to fetch.
     */
    where: SupplierItemPriceWhereUniqueInput
  }

  /**
   * SupplierItemPrice findUniqueOrThrow
   */
  export type SupplierItemPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItemPrice to fetch.
     */
    where: SupplierItemPriceWhereUniqueInput
  }

  /**
   * SupplierItemPrice findFirst
   */
  export type SupplierItemPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItemPrice to fetch.
     */
    where?: SupplierItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItemPrices to fetch.
     */
    orderBy?: SupplierItemPriceOrderByWithRelationInput | SupplierItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierItemPrices.
     */
    cursor?: SupplierItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierItemPrices.
     */
    distinct?: SupplierItemPriceScalarFieldEnum | SupplierItemPriceScalarFieldEnum[]
  }

  /**
   * SupplierItemPrice findFirstOrThrow
   */
  export type SupplierItemPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItemPrice to fetch.
     */
    where?: SupplierItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItemPrices to fetch.
     */
    orderBy?: SupplierItemPriceOrderByWithRelationInput | SupplierItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierItemPrices.
     */
    cursor?: SupplierItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierItemPrices.
     */
    distinct?: SupplierItemPriceScalarFieldEnum | SupplierItemPriceScalarFieldEnum[]
  }

  /**
   * SupplierItemPrice findMany
   */
  export type SupplierItemPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which SupplierItemPrices to fetch.
     */
    where?: SupplierItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierItemPrices to fetch.
     */
    orderBy?: SupplierItemPriceOrderByWithRelationInput | SupplierItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierItemPrices.
     */
    cursor?: SupplierItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierItemPrices.
     */
    skip?: number
    distinct?: SupplierItemPriceScalarFieldEnum | SupplierItemPriceScalarFieldEnum[]
  }

  /**
   * SupplierItemPrice create
   */
  export type SupplierItemPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierItemPrice.
     */
    data: XOR<SupplierItemPriceCreateInput, SupplierItemPriceUncheckedCreateInput>
  }

  /**
   * SupplierItemPrice createMany
   */
  export type SupplierItemPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierItemPrices.
     */
    data: SupplierItemPriceCreateManyInput | SupplierItemPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierItemPrice createManyAndReturn
   */
  export type SupplierItemPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupplierItemPrices.
     */
    data: SupplierItemPriceCreateManyInput | SupplierItemPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierItemPrice update
   */
  export type SupplierItemPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierItemPrice.
     */
    data: XOR<SupplierItemPriceUpdateInput, SupplierItemPriceUncheckedUpdateInput>
    /**
     * Choose, which SupplierItemPrice to update.
     */
    where: SupplierItemPriceWhereUniqueInput
  }

  /**
   * SupplierItemPrice updateMany
   */
  export type SupplierItemPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierItemPrices.
     */
    data: XOR<SupplierItemPriceUpdateManyMutationInput, SupplierItemPriceUncheckedUpdateManyInput>
    /**
     * Filter which SupplierItemPrices to update
     */
    where?: SupplierItemPriceWhereInput
  }

  /**
   * SupplierItemPrice upsert
   */
  export type SupplierItemPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierItemPrice to update in case it exists.
     */
    where: SupplierItemPriceWhereUniqueInput
    /**
     * In case the SupplierItemPrice found by the `where` argument doesn't exist, create a new SupplierItemPrice with this data.
     */
    create: XOR<SupplierItemPriceCreateInput, SupplierItemPriceUncheckedCreateInput>
    /**
     * In case the SupplierItemPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierItemPriceUpdateInput, SupplierItemPriceUncheckedUpdateInput>
  }

  /**
   * SupplierItemPrice delete
   */
  export type SupplierItemPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
    /**
     * Filter which SupplierItemPrice to delete.
     */
    where: SupplierItemPriceWhereUniqueInput
  }

  /**
   * SupplierItemPrice deleteMany
   */
  export type SupplierItemPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierItemPrices to delete
     */
    where?: SupplierItemPriceWhereInput
  }

  /**
   * SupplierItemPrice without action
   */
  export type SupplierItemPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierItemPrice
     */
    select?: SupplierItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierItemPriceInclude<ExtArgs> | null
  }


  /**
   * Model CustomerItemPrice
   */

  export type AggregateCustomerItemPrice = {
    _count: CustomerItemPriceCountAggregateOutputType | null
    _avg: CustomerItemPriceAvgAggregateOutputType | null
    _sum: CustomerItemPriceSumAggregateOutputType | null
    _min: CustomerItemPriceMinAggregateOutputType | null
    _max: CustomerItemPriceMaxAggregateOutputType | null
  }

  export type CustomerItemPriceAvgAggregateOutputType = {
    customerItemPriceId: number | null
    customerId: number | null
    itemId: number | null
    unitPrice: Decimal | null
    createdBy: number | null
    updatedBy: number | null
  }

  export type CustomerItemPriceSumAggregateOutputType = {
    customerItemPriceId: bigint | null
    customerId: bigint | null
    itemId: bigint | null
    unitPrice: Decimal | null
    createdBy: bigint | null
    updatedBy: bigint | null
  }

  export type CustomerItemPriceMinAggregateOutputType = {
    customerItemPriceId: bigint | null
    customerId: bigint | null
    itemId: bigint | null
    unitPrice: Decimal | null
    effectiveFrom: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
  }

  export type CustomerItemPriceMaxAggregateOutputType = {
    customerItemPriceId: bigint | null
    customerId: bigint | null
    itemId: bigint | null
    unitPrice: Decimal | null
    effectiveFrom: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: bigint | null
    updatedBy: bigint | null
  }

  export type CustomerItemPriceCountAggregateOutputType = {
    customerItemPriceId: number
    customerId: number
    itemId: number
    unitPrice: number
    effectiveFrom: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type CustomerItemPriceAvgAggregateInputType = {
    customerItemPriceId?: true
    customerId?: true
    itemId?: true
    unitPrice?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CustomerItemPriceSumAggregateInputType = {
    customerItemPriceId?: true
    customerId?: true
    itemId?: true
    unitPrice?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CustomerItemPriceMinAggregateInputType = {
    customerItemPriceId?: true
    customerId?: true
    itemId?: true
    unitPrice?: true
    effectiveFrom?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CustomerItemPriceMaxAggregateInputType = {
    customerItemPriceId?: true
    customerId?: true
    itemId?: true
    unitPrice?: true
    effectiveFrom?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type CustomerItemPriceCountAggregateInputType = {
    customerItemPriceId?: true
    customerId?: true
    itemId?: true
    unitPrice?: true
    effectiveFrom?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type CustomerItemPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerItemPrice to aggregate.
     */
    where?: CustomerItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemPrices to fetch.
     */
    orderBy?: CustomerItemPriceOrderByWithRelationInput | CustomerItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerItemPrices
    **/
    _count?: true | CustomerItemPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerItemPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerItemPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerItemPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerItemPriceMaxAggregateInputType
  }

  export type GetCustomerItemPriceAggregateType<T extends CustomerItemPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerItemPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerItemPrice[P]>
      : GetScalarType<T[P], AggregateCustomerItemPrice[P]>
  }




  export type CustomerItemPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerItemPriceWhereInput
    orderBy?: CustomerItemPriceOrderByWithAggregationInput | CustomerItemPriceOrderByWithAggregationInput[]
    by: CustomerItemPriceScalarFieldEnum[] | CustomerItemPriceScalarFieldEnum
    having?: CustomerItemPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerItemPriceCountAggregateInputType | true
    _avg?: CustomerItemPriceAvgAggregateInputType
    _sum?: CustomerItemPriceSumAggregateInputType
    _min?: CustomerItemPriceMinAggregateInputType
    _max?: CustomerItemPriceMaxAggregateInputType
  }

  export type CustomerItemPriceGroupByOutputType = {
    customerItemPriceId: bigint
    customerId: bigint
    itemId: bigint
    unitPrice: Decimal
    effectiveFrom: Date
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: bigint | null
    updatedBy: bigint | null
    _count: CustomerItemPriceCountAggregateOutputType | null
    _avg: CustomerItemPriceAvgAggregateOutputType | null
    _sum: CustomerItemPriceSumAggregateOutputType | null
    _min: CustomerItemPriceMinAggregateOutputType | null
    _max: CustomerItemPriceMaxAggregateOutputType | null
  }

  type GetCustomerItemPriceGroupByPayload<T extends CustomerItemPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerItemPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerItemPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerItemPriceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerItemPriceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerItemPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerItemPriceId?: boolean
    customerId?: boolean
    itemId?: boolean
    unitPrice?: boolean
    effectiveFrom?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerItemPrice"]>

  export type CustomerItemPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerItemPriceId?: boolean
    customerId?: boolean
    itemId?: boolean
    unitPrice?: boolean
    effectiveFrom?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerItemPrice"]>

  export type CustomerItemPriceSelectScalar = {
    customerItemPriceId?: boolean
    customerId?: boolean
    itemId?: boolean
    unitPrice?: boolean
    effectiveFrom?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type CustomerItemPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type CustomerItemPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $CustomerItemPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerItemPrice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      customerItemPriceId: bigint
      customerId: bigint
      itemId: bigint
      unitPrice: Prisma.Decimal
      effectiveFrom: Date
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: bigint | null
      updatedBy: bigint | null
    }, ExtArgs["result"]["customerItemPrice"]>
    composites: {}
  }

  type CustomerItemPriceGetPayload<S extends boolean | null | undefined | CustomerItemPriceDefaultArgs> = $Result.GetResult<Prisma.$CustomerItemPricePayload, S>

  type CustomerItemPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerItemPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerItemPriceCountAggregateInputType | true
    }

  export interface CustomerItemPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerItemPrice'], meta: { name: 'CustomerItemPrice' } }
    /**
     * Find zero or one CustomerItemPrice that matches the filter.
     * @param {CustomerItemPriceFindUniqueArgs} args - Arguments to find a CustomerItemPrice
     * @example
     * // Get one CustomerItemPrice
     * const customerItemPrice = await prisma.customerItemPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerItemPriceFindUniqueArgs>(args: SelectSubset<T, CustomerItemPriceFindUniqueArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerItemPrice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerItemPriceFindUniqueOrThrowArgs} args - Arguments to find a CustomerItemPrice
     * @example
     * // Get one CustomerItemPrice
     * const customerItemPrice = await prisma.customerItemPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerItemPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerItemPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerItemPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceFindFirstArgs} args - Arguments to find a CustomerItemPrice
     * @example
     * // Get one CustomerItemPrice
     * const customerItemPrice = await prisma.customerItemPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerItemPriceFindFirstArgs>(args?: SelectSubset<T, CustomerItemPriceFindFirstArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerItemPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceFindFirstOrThrowArgs} args - Arguments to find a CustomerItemPrice
     * @example
     * // Get one CustomerItemPrice
     * const customerItemPrice = await prisma.customerItemPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerItemPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerItemPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerItemPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerItemPrices
     * const customerItemPrices = await prisma.customerItemPrice.findMany()
     * 
     * // Get first 10 CustomerItemPrices
     * const customerItemPrices = await prisma.customerItemPrice.findMany({ take: 10 })
     * 
     * // Only select the `customerItemPriceId`
     * const customerItemPriceWithCustomerItemPriceIdOnly = await prisma.customerItemPrice.findMany({ select: { customerItemPriceId: true } })
     * 
     */
    findMany<T extends CustomerItemPriceFindManyArgs>(args?: SelectSubset<T, CustomerItemPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerItemPrice.
     * @param {CustomerItemPriceCreateArgs} args - Arguments to create a CustomerItemPrice.
     * @example
     * // Create one CustomerItemPrice
     * const CustomerItemPrice = await prisma.customerItemPrice.create({
     *   data: {
     *     // ... data to create a CustomerItemPrice
     *   }
     * })
     * 
     */
    create<T extends CustomerItemPriceCreateArgs>(args: SelectSubset<T, CustomerItemPriceCreateArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerItemPrices.
     * @param {CustomerItemPriceCreateManyArgs} args - Arguments to create many CustomerItemPrices.
     * @example
     * // Create many CustomerItemPrices
     * const customerItemPrice = await prisma.customerItemPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerItemPriceCreateManyArgs>(args?: SelectSubset<T, CustomerItemPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerItemPrices and returns the data saved in the database.
     * @param {CustomerItemPriceCreateManyAndReturnArgs} args - Arguments to create many CustomerItemPrices.
     * @example
     * // Create many CustomerItemPrices
     * const customerItemPrice = await prisma.customerItemPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerItemPrices and only return the `customerItemPriceId`
     * const customerItemPriceWithCustomerItemPriceIdOnly = await prisma.customerItemPrice.createManyAndReturn({ 
     *   select: { customerItemPriceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerItemPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerItemPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerItemPrice.
     * @param {CustomerItemPriceDeleteArgs} args - Arguments to delete one CustomerItemPrice.
     * @example
     * // Delete one CustomerItemPrice
     * const CustomerItemPrice = await prisma.customerItemPrice.delete({
     *   where: {
     *     // ... filter to delete one CustomerItemPrice
     *   }
     * })
     * 
     */
    delete<T extends CustomerItemPriceDeleteArgs>(args: SelectSubset<T, CustomerItemPriceDeleteArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerItemPrice.
     * @param {CustomerItemPriceUpdateArgs} args - Arguments to update one CustomerItemPrice.
     * @example
     * // Update one CustomerItemPrice
     * const customerItemPrice = await prisma.customerItemPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerItemPriceUpdateArgs>(args: SelectSubset<T, CustomerItemPriceUpdateArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerItemPrices.
     * @param {CustomerItemPriceDeleteManyArgs} args - Arguments to filter CustomerItemPrices to delete.
     * @example
     * // Delete a few CustomerItemPrices
     * const { count } = await prisma.customerItemPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerItemPriceDeleteManyArgs>(args?: SelectSubset<T, CustomerItemPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerItemPrices
     * const customerItemPrice = await prisma.customerItemPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerItemPriceUpdateManyArgs>(args: SelectSubset<T, CustomerItemPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerItemPrice.
     * @param {CustomerItemPriceUpsertArgs} args - Arguments to update or create a CustomerItemPrice.
     * @example
     * // Update or create a CustomerItemPrice
     * const customerItemPrice = await prisma.customerItemPrice.upsert({
     *   create: {
     *     // ... data to create a CustomerItemPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerItemPrice we want to update
     *   }
     * })
     */
    upsert<T extends CustomerItemPriceUpsertArgs>(args: SelectSubset<T, CustomerItemPriceUpsertArgs<ExtArgs>>): Prisma__CustomerItemPriceClient<$Result.GetResult<Prisma.$CustomerItemPricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerItemPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceCountArgs} args - Arguments to filter CustomerItemPrices to count.
     * @example
     * // Count the number of CustomerItemPrices
     * const count = await prisma.customerItemPrice.count({
     *   where: {
     *     // ... the filter for the CustomerItemPrices we want to count
     *   }
     * })
    **/
    count<T extends CustomerItemPriceCountArgs>(
      args?: Subset<T, CustomerItemPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerItemPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerItemPriceAggregateArgs>(args: Subset<T, CustomerItemPriceAggregateArgs>): Prisma.PrismaPromise<GetCustomerItemPriceAggregateType<T>>

    /**
     * Group by CustomerItemPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerItemPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerItemPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerItemPriceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerItemPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerItemPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerItemPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerItemPrice model
   */
  readonly fields: CustomerItemPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerItemPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerItemPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerItemPrice model
   */ 
  interface CustomerItemPriceFieldRefs {
    readonly customerItemPriceId: FieldRef<"CustomerItemPrice", 'BigInt'>
    readonly customerId: FieldRef<"CustomerItemPrice", 'BigInt'>
    readonly itemId: FieldRef<"CustomerItemPrice", 'BigInt'>
    readonly unitPrice: FieldRef<"CustomerItemPrice", 'Decimal'>
    readonly effectiveFrom: FieldRef<"CustomerItemPrice", 'DateTime'>
    readonly endDate: FieldRef<"CustomerItemPrice", 'DateTime'>
    readonly isActive: FieldRef<"CustomerItemPrice", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerItemPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerItemPrice", 'DateTime'>
    readonly createdBy: FieldRef<"CustomerItemPrice", 'BigInt'>
    readonly updatedBy: FieldRef<"CustomerItemPrice", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * CustomerItemPrice findUnique
   */
  export type CustomerItemPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemPrice to fetch.
     */
    where: CustomerItemPriceWhereUniqueInput
  }

  /**
   * CustomerItemPrice findUniqueOrThrow
   */
  export type CustomerItemPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemPrice to fetch.
     */
    where: CustomerItemPriceWhereUniqueInput
  }

  /**
   * CustomerItemPrice findFirst
   */
  export type CustomerItemPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemPrice to fetch.
     */
    where?: CustomerItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemPrices to fetch.
     */
    orderBy?: CustomerItemPriceOrderByWithRelationInput | CustomerItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerItemPrices.
     */
    cursor?: CustomerItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerItemPrices.
     */
    distinct?: CustomerItemPriceScalarFieldEnum | CustomerItemPriceScalarFieldEnum[]
  }

  /**
   * CustomerItemPrice findFirstOrThrow
   */
  export type CustomerItemPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemPrice to fetch.
     */
    where?: CustomerItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemPrices to fetch.
     */
    orderBy?: CustomerItemPriceOrderByWithRelationInput | CustomerItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerItemPrices.
     */
    cursor?: CustomerItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerItemPrices.
     */
    distinct?: CustomerItemPriceScalarFieldEnum | CustomerItemPriceScalarFieldEnum[]
  }

  /**
   * CustomerItemPrice findMany
   */
  export type CustomerItemPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * Filter, which CustomerItemPrices to fetch.
     */
    where?: CustomerItemPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerItemPrices to fetch.
     */
    orderBy?: CustomerItemPriceOrderByWithRelationInput | CustomerItemPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerItemPrices.
     */
    cursor?: CustomerItemPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerItemPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerItemPrices.
     */
    skip?: number
    distinct?: CustomerItemPriceScalarFieldEnum | CustomerItemPriceScalarFieldEnum[]
  }

  /**
   * CustomerItemPrice create
   */
  export type CustomerItemPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerItemPrice.
     */
    data: XOR<CustomerItemPriceCreateInput, CustomerItemPriceUncheckedCreateInput>
  }

  /**
   * CustomerItemPrice createMany
   */
  export type CustomerItemPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerItemPrices.
     */
    data: CustomerItemPriceCreateManyInput | CustomerItemPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerItemPrice createManyAndReturn
   */
  export type CustomerItemPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerItemPrices.
     */
    data: CustomerItemPriceCreateManyInput | CustomerItemPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerItemPrice update
   */
  export type CustomerItemPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerItemPrice.
     */
    data: XOR<CustomerItemPriceUpdateInput, CustomerItemPriceUncheckedUpdateInput>
    /**
     * Choose, which CustomerItemPrice to update.
     */
    where: CustomerItemPriceWhereUniqueInput
  }

  /**
   * CustomerItemPrice updateMany
   */
  export type CustomerItemPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerItemPrices.
     */
    data: XOR<CustomerItemPriceUpdateManyMutationInput, CustomerItemPriceUncheckedUpdateManyInput>
    /**
     * Filter which CustomerItemPrices to update
     */
    where?: CustomerItemPriceWhereInput
  }

  /**
   * CustomerItemPrice upsert
   */
  export type CustomerItemPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerItemPrice to update in case it exists.
     */
    where: CustomerItemPriceWhereUniqueInput
    /**
     * In case the CustomerItemPrice found by the `where` argument doesn't exist, create a new CustomerItemPrice with this data.
     */
    create: XOR<CustomerItemPriceCreateInput, CustomerItemPriceUncheckedCreateInput>
    /**
     * In case the CustomerItemPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerItemPriceUpdateInput, CustomerItemPriceUncheckedUpdateInput>
  }

  /**
   * CustomerItemPrice delete
   */
  export type CustomerItemPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
    /**
     * Filter which CustomerItemPrice to delete.
     */
    where: CustomerItemPriceWhereUniqueInput
  }

  /**
   * CustomerItemPrice deleteMany
   */
  export type CustomerItemPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerItemPrices to delete
     */
    where?: CustomerItemPriceWhereInput
  }

  /**
   * CustomerItemPrice without action
   */
  export type CustomerItemPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerItemPrice
     */
    select?: CustomerItemPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerItemPriceInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    purchaseId: number | null
    supplierId: number | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    createdBy: number | null
    updatedBy: number | null
    confirmedBy: number | null
    receivedBy: number | null
    cancelledBy: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    purchaseId: bigint | null
    supplierId: bigint | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    createdBy: bigint | null
    updatedBy: bigint | null
    confirmedBy: bigint | null
    receivedBy: bigint | null
    cancelledBy: bigint | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    purchaseId: bigint | null
    purchaseNo: string | null
    supplierId: bigint | null
    purchaseDate: Date | null
    status: $Enums.DocStatus | null
    notes: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    createdBy: bigint | null
    createdAt: Date | null
    updatedBy: bigint | null
    updatedAt: Date | null
    confirmedAt: Date | null
    confirmedBy: bigint | null
    receivedAt: Date | null
    receivedBy: bigint | null
    cancelledAt: Date | null
    cancelledBy: bigint | null
    cancelReason: string | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    purchaseId: bigint | null
    purchaseNo: string | null
    supplierId: bigint | null
    purchaseDate: Date | null
    status: $Enums.DocStatus | null
    notes: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    createdBy: bigint | null
    createdAt: Date | null
    updatedBy: bigint | null
    updatedAt: Date | null
    confirmedAt: Date | null
    confirmedBy: bigint | null
    receivedAt: Date | null
    receivedBy: bigint | null
    cancelledAt: Date | null
    cancelledBy: bigint | null
    cancelReason: string | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    purchaseId: number
    purchaseNo: number
    supplierId: number
    purchaseDate: number
    status: number
    notes: number
    subtotal: number
    discount: number
    tax: number
    total: number
    createdBy: number
    createdAt: number
    updatedBy: number
    updatedAt: number
    confirmedAt: number
    confirmedBy: number
    receivedAt: number
    receivedBy: number
    cancelledAt: number
    cancelledBy: number
    cancelReason: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    purchaseId?: true
    supplierId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
    updatedBy?: true
    confirmedBy?: true
    receivedBy?: true
    cancelledBy?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    purchaseId?: true
    supplierId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
    updatedBy?: true
    confirmedBy?: true
    receivedBy?: true
    cancelledBy?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    purchaseId?: true
    purchaseNo?: true
    supplierId?: true
    purchaseDate?: true
    status?: true
    notes?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
    createdAt?: true
    updatedBy?: true
    updatedAt?: true
    confirmedAt?: true
    confirmedBy?: true
    receivedAt?: true
    receivedBy?: true
    cancelledAt?: true
    cancelledBy?: true
    cancelReason?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    purchaseId?: true
    purchaseNo?: true
    supplierId?: true
    purchaseDate?: true
    status?: true
    notes?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
    createdAt?: true
    updatedBy?: true
    updatedAt?: true
    confirmedAt?: true
    confirmedBy?: true
    receivedAt?: true
    receivedBy?: true
    cancelledAt?: true
    cancelledBy?: true
    cancelReason?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    purchaseId?: true
    purchaseNo?: true
    supplierId?: true
    purchaseDate?: true
    status?: true
    notes?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
    createdAt?: true
    updatedBy?: true
    updatedAt?: true
    confirmedAt?: true
    confirmedBy?: true
    receivedAt?: true
    receivedBy?: true
    cancelledAt?: true
    cancelledBy?: true
    cancelReason?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    purchaseId: bigint
    purchaseNo: string
    supplierId: bigint
    purchaseDate: Date
    status: $Enums.DocStatus
    notes: string | null
    subtotal: Decimal
    discount: Decimal
    tax: Decimal
    total: Decimal
    createdBy: bigint | null
    createdAt: Date
    updatedBy: bigint | null
    updatedAt: Date
    confirmedAt: Date | null
    confirmedBy: bigint | null
    receivedAt: Date | null
    receivedBy: bigint | null
    cancelledAt: Date | null
    cancelledBy: bigint | null
    cancelReason: string | null
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purchaseId?: boolean
    purchaseNo?: boolean
    supplierId?: boolean
    purchaseDate?: boolean
    status?: boolean
    notes?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    receivedAt?: boolean
    receivedBy?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
    invoices?: boolean | PurchaseOrder$invoicesArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    creator?: boolean | PurchaseOrder$creatorArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    stockMovements?: boolean | PurchaseOrder$stockMovementsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purchaseId?: boolean
    purchaseNo?: boolean
    supplierId?: boolean
    purchaseDate?: boolean
    status?: boolean
    notes?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    receivedAt?: boolean
    receivedBy?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
    creator?: boolean | PurchaseOrder$creatorArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    purchaseId?: boolean
    purchaseNo?: boolean
    supplierId?: boolean
    purchaseDate?: boolean
    status?: boolean
    notes?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    receivedAt?: boolean
    receivedBy?: boolean
    cancelledAt?: boolean
    cancelledBy?: boolean
    cancelReason?: boolean
  }

  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | PurchaseOrder$invoicesArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    creator?: boolean | PurchaseOrder$creatorArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    stockMovements?: boolean | PurchaseOrder$stockMovementsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | PurchaseOrder$creatorArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      lines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs>
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      purchaseId: bigint
      purchaseNo: string
      supplierId: bigint
      purchaseDate: Date
      status: $Enums.DocStatus
      notes: string | null
      subtotal: Prisma.Decimal
      discount: Prisma.Decimal
      tax: Prisma.Decimal
      total: Prisma.Decimal
      createdBy: bigint | null
      createdAt: Date
      updatedBy: bigint | null
      updatedAt: Date
      confirmedAt: Date | null
      confirmedBy: bigint | null
      receivedAt: Date | null
      receivedBy: bigint | null
      cancelledAt: Date | null
      cancelledBy: bigint | null
      cancelReason: string | null
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `purchaseId`
     * const purchaseOrderWithPurchaseIdOnly = await prisma.purchaseOrder.findMany({ select: { purchaseId: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `purchaseId`
     * const purchaseOrderWithPurchaseIdOnly = await prisma.purchaseOrder.createManyAndReturn({ 
     *   select: { purchaseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends PurchaseOrder$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    lines<T extends PurchaseOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends PurchaseOrder$creatorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stockMovements<T extends PurchaseOrder$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */ 
  interface PurchaseOrderFieldRefs {
    readonly purchaseId: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly purchaseNo: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly purchaseDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'DocStatus'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly subtotal: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly discount: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly tax: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly total: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly createdBy: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedBy: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly confirmedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly confirmedBy: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly receivedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly receivedBy: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly cancelledAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly cancelledBy: FieldRef<"PurchaseOrder", 'BigInt'>
    readonly cancelReason: FieldRef<"PurchaseOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder.invoices
   */
  export type PurchaseOrder$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.lines
   */
  export type PurchaseOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.creator
   */
  export type PurchaseOrder$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PurchaseOrder.stockMovements
   */
  export type PurchaseOrder$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderLine
   */

  export type AggregatePurchaseOrderLine = {
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  export type PurchaseOrderLineAvgAggregateOutputType = {
    purchaseLineId: number | null
    purchaseId: number | null
    itemId: number | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
    overriddenBy: number | null
  }

  export type PurchaseOrderLineSumAggregateOutputType = {
    purchaseLineId: bigint | null
    purchaseId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
    overriddenBy: bigint | null
  }

  export type PurchaseOrderLineMinAggregateOutputType = {
    purchaseLineId: bigint | null
    purchaseId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
    priceSource: string | null
    overrideReason: string | null
    overriddenBy: bigint | null
  }

  export type PurchaseOrderLineMaxAggregateOutputType = {
    purchaseLineId: bigint | null
    purchaseId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
    priceSource: string | null
    overrideReason: string | null
    overriddenBy: bigint | null
  }

  export type PurchaseOrderLineCountAggregateOutputType = {
    purchaseLineId: number
    purchaseId: number
    itemId: number
    qty: number
    unitPrice: number
    lineTotal: number
    priceSource: number
    overrideReason: number
    overriddenBy: number
    _all: number
  }


  export type PurchaseOrderLineAvgAggregateInputType = {
    purchaseLineId?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    overriddenBy?: true
  }

  export type PurchaseOrderLineSumAggregateInputType = {
    purchaseLineId?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    overriddenBy?: true
  }

  export type PurchaseOrderLineMinAggregateInputType = {
    purchaseLineId?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    priceSource?: true
    overrideReason?: true
    overriddenBy?: true
  }

  export type PurchaseOrderLineMaxAggregateInputType = {
    purchaseLineId?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    priceSource?: true
    overrideReason?: true
    overriddenBy?: true
  }

  export type PurchaseOrderLineCountAggregateInputType = {
    purchaseLineId?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    priceSource?: true
    overrideReason?: true
    overriddenBy?: true
    _all?: true
  }

  export type PurchaseOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLine to aggregate.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderLines
    **/
    _count?: true | PurchaseOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type GetPurchaseOrderLineAggregateType<T extends PurchaseOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
  }




  export type PurchaseOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithAggregationInput | PurchaseOrderLineOrderByWithAggregationInput[]
    by: PurchaseOrderLineScalarFieldEnum[] | PurchaseOrderLineScalarFieldEnum
    having?: PurchaseOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderLineCountAggregateInputType | true
    _avg?: PurchaseOrderLineAvgAggregateInputType
    _sum?: PurchaseOrderLineSumAggregateInputType
    _min?: PurchaseOrderLineMinAggregateInputType
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type PurchaseOrderLineGroupByOutputType = {
    purchaseLineId: bigint
    purchaseId: bigint
    itemId: bigint
    qty: Decimal
    unitPrice: Decimal
    lineTotal: Decimal
    priceSource: string
    overrideReason: string | null
    overriddenBy: bigint | null
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  type GetPurchaseOrderLineGroupByPayload<T extends PurchaseOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purchaseLineId?: boolean
    purchaseId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    priceSource?: boolean
    overrideReason?: boolean
    overriddenBy?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    purchaseLineId?: boolean
    purchaseId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    priceSource?: boolean
    overrideReason?: boolean
    overriddenBy?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectScalar = {
    purchaseLineId?: boolean
    purchaseId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    priceSource?: boolean
    overrideReason?: boolean
    overriddenBy?: boolean
  }

  export type PurchaseOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderLine"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      purchaseLineId: bigint
      purchaseId: bigint
      itemId: bigint
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      lineTotal: Prisma.Decimal
      priceSource: string
      overrideReason: string | null
      overriddenBy: bigint | null
    }, ExtArgs["result"]["purchaseOrderLine"]>
    composites: {}
  }

  type PurchaseOrderLineGetPayload<S extends boolean | null | undefined | PurchaseOrderLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderLinePayload, S>

  type PurchaseOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderLineCountAggregateInputType | true
    }

  export interface PurchaseOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderLine'], meta: { name: 'PurchaseOrderLine' } }
    /**
     * Find zero or one PurchaseOrderLine that matches the filter.
     * @param {PurchaseOrderLineFindUniqueArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderLineFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrderLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderLineFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
     * 
     * // Get first 10 PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `purchaseLineId`
     * const purchaseOrderLineWithPurchaseLineIdOnly = await prisma.purchaseOrderLine.findMany({ select: { purchaseLineId: true } })
     * 
     */
    findMany<T extends PurchaseOrderLineFindManyArgs>(args?: SelectSubset<T, PurchaseOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrderLine.
     * @param {PurchaseOrderLineCreateArgs} args - Arguments to create a PurchaseOrderLine.
     * @example
     * // Create one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.create({
     *   data: {
     *     // ... data to create a PurchaseOrderLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderLineCreateArgs>(args: SelectSubset<T, PurchaseOrderLineCreateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrderLines.
     * @param {PurchaseOrderLineCreateManyArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderLineCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderLines and returns the data saved in the database.
     * @param {PurchaseOrderLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderLines and only return the `purchaseLineId`
     * const purchaseOrderLineWithPurchaseLineIdOnly = await prisma.purchaseOrderLine.createManyAndReturn({ 
     *   select: { purchaseLineId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrderLine.
     * @param {PurchaseOrderLineDeleteArgs} args - Arguments to delete one PurchaseOrderLine.
     * @example
     * // Delete one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderLineDeleteArgs>(args: SelectSubset<T, PurchaseOrderLineDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpdateArgs} args - Arguments to update one PurchaseOrderLine.
     * @example
     * // Update one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderLineUpdateArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrderLines.
     * @param {PurchaseOrderLineDeleteManyArgs} args - Arguments to filter PurchaseOrderLines to delete.
     * @example
     * // Delete a few PurchaseOrderLines
     * const { count } = await prisma.purchaseOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderLineUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpsertArgs} args - Arguments to update or create a PurchaseOrderLine.
     * @example
     * // Update or create a PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderLineUpsertArgs>(args: SelectSubset<T, PurchaseOrderLineUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineCountArgs} args - Arguments to filter PurchaseOrderLines to count.
     * @example
     * // Count the number of PurchaseOrderLines
     * const count = await prisma.purchaseOrderLine.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderLineCountArgs>(
      args?: Subset<T, PurchaseOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderLineAggregateArgs>(args: Subset<T, PurchaseOrderLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderLineAggregateType<T>>

    /**
     * Group by PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderLine model
   */
  readonly fields: PurchaseOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderLine model
   */ 
  interface PurchaseOrderLineFieldRefs {
    readonly purchaseLineId: FieldRef<"PurchaseOrderLine", 'BigInt'>
    readonly purchaseId: FieldRef<"PurchaseOrderLine", 'BigInt'>
    readonly itemId: FieldRef<"PurchaseOrderLine", 'BigInt'>
    readonly qty: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly lineTotal: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly priceSource: FieldRef<"PurchaseOrderLine", 'String'>
    readonly overrideReason: FieldRef<"PurchaseOrderLine", 'String'>
    readonly overriddenBy: FieldRef<"PurchaseOrderLine", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderLine findUnique
   */
  export type PurchaseOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findUniqueOrThrow
   */
  export type PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findFirst
   */
  export type PurchaseOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findFirstOrThrow
   */
  export type PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findMany
   */
  export type PurchaseOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLines to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine create
   */
  export type PurchaseOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
  }

  /**
   * PurchaseOrderLine createMany
   */
  export type PurchaseOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderLine createManyAndReturn
   */
  export type PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine update
   */
  export type PurchaseOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderLine to update.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine updateMany
   */
  export type PurchaseOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseOrderLine upsert
   */
  export type PurchaseOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderLine to update in case it exists.
     */
    where: PurchaseOrderLineWhereUniqueInput
    /**
     * In case the PurchaseOrderLine found by the `where` argument doesn't exist, create a new PurchaseOrderLine with this data.
     */
    create: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
    /**
     * In case the PurchaseOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderLine delete
   */
  export type PurchaseOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderLine to delete.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine deleteMany
   */
  export type PurchaseOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLines to delete
     */
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseOrderLine without action
   */
  export type PurchaseOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrder
   */

  export type AggregateSalesOrder = {
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  export type SalesOrderAvgAggregateOutputType = {
    salesOrderId: number | null
    customerId: number | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    createdBy: number | null
  }

  export type SalesOrderSumAggregateOutputType = {
    salesOrderId: bigint | null
    customerId: bigint | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    createdBy: bigint | null
  }

  export type SalesOrderMinAggregateOutputType = {
    salesOrderId: bigint | null
    orderNo: string | null
    customerId: bigint | null
    orderDate: Date | null
    status: $Enums.DocStatus | null
    notes: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    isEditedAfterConfirm: boolean | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type SalesOrderMaxAggregateOutputType = {
    salesOrderId: bigint | null
    orderNo: string | null
    customerId: bigint | null
    orderDate: Date | null
    status: $Enums.DocStatus | null
    notes: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    isEditedAfterConfirm: boolean | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type SalesOrderCountAggregateOutputType = {
    salesOrderId: number
    orderNo: number
    customerId: number
    orderDate: number
    status: number
    notes: number
    subtotal: number
    discount: number
    tax: number
    total: number
    isEditedAfterConfirm: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type SalesOrderAvgAggregateInputType = {
    salesOrderId?: true
    customerId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
  }

  export type SalesOrderSumAggregateInputType = {
    salesOrderId?: true
    customerId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    createdBy?: true
  }

  export type SalesOrderMinAggregateInputType = {
    salesOrderId?: true
    orderNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    notes?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    isEditedAfterConfirm?: true
    createdBy?: true
    createdAt?: true
  }

  export type SalesOrderMaxAggregateInputType = {
    salesOrderId?: true
    orderNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    notes?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    isEditedAfterConfirm?: true
    createdBy?: true
    createdAt?: true
  }

  export type SalesOrderCountAggregateInputType = {
    salesOrderId?: true
    orderNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    notes?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    isEditedAfterConfirm?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type SalesOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrder to aggregate.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrders
    **/
    _count?: true | SalesOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderMaxAggregateInputType
  }

  export type GetSalesOrderAggregateType<T extends SalesOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrder[P]>
      : GetScalarType<T[P], AggregateSalesOrder[P]>
  }




  export type SalesOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithAggregationInput | SalesOrderOrderByWithAggregationInput[]
    by: SalesOrderScalarFieldEnum[] | SalesOrderScalarFieldEnum
    having?: SalesOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderCountAggregateInputType | true
    _avg?: SalesOrderAvgAggregateInputType
    _sum?: SalesOrderSumAggregateInputType
    _min?: SalesOrderMinAggregateInputType
    _max?: SalesOrderMaxAggregateInputType
  }

  export type SalesOrderGroupByOutputType = {
    salesOrderId: bigint
    orderNo: string
    customerId: bigint
    orderDate: Date
    status: $Enums.DocStatus
    notes: string | null
    subtotal: Decimal
    discount: Decimal
    tax: Decimal
    total: Decimal
    isEditedAfterConfirm: boolean
    createdBy: bigint | null
    createdAt: Date
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  type GetSalesOrderGroupByPayload<T extends SalesOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salesOrderId?: boolean
    orderNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    notes?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    isEditedAfterConfirm?: boolean
    createdBy?: boolean
    createdAt?: boolean
    dispatches?: boolean | SalesOrder$dispatchesArgs<ExtArgs>
    invoices?: boolean | SalesOrder$invoicesArgs<ExtArgs>
    lines?: boolean | SalesOrder$linesArgs<ExtArgs>
    creator?: boolean | SalesOrder$creatorArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salesOrderId?: boolean
    orderNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    notes?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    isEditedAfterConfirm?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | SalesOrder$creatorArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectScalar = {
    salesOrderId?: boolean
    orderNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    notes?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    isEditedAfterConfirm?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type SalesOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispatches?: boolean | SalesOrder$dispatchesArgs<ExtArgs>
    invoices?: boolean | SalesOrder$invoicesArgs<ExtArgs>
    lines?: boolean | SalesOrder$linesArgs<ExtArgs>
    creator?: boolean | SalesOrder$creatorArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | SalesOrder$creatorArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SalesOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrder"
    objects: {
      dispatches: Prisma.$DispatchPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      lines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      salesOrderId: bigint
      orderNo: string
      customerId: bigint
      orderDate: Date
      status: $Enums.DocStatus
      notes: string | null
      subtotal: Prisma.Decimal
      discount: Prisma.Decimal
      tax: Prisma.Decimal
      total: Prisma.Decimal
      isEditedAfterConfirm: boolean
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["salesOrder"]>
    composites: {}
  }

  type SalesOrderGetPayload<S extends boolean | null | undefined | SalesOrderDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderPayload, S>

  type SalesOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesOrderCountAggregateInputType | true
    }

  export interface SalesOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrder'], meta: { name: 'SalesOrder' } }
    /**
     * Find zero or one SalesOrder that matches the filter.
     * @param {SalesOrderFindUniqueArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderFindUniqueArgs>(args: SelectSubset<T, SalesOrderFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesOrderFindUniqueOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderFindFirstArgs>(args?: SelectSubset<T, SalesOrderFindFirstArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany()
     * 
     * // Get first 10 SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany({ take: 10 })
     * 
     * // Only select the `salesOrderId`
     * const salesOrderWithSalesOrderIdOnly = await prisma.salesOrder.findMany({ select: { salesOrderId: true } })
     * 
     */
    findMany<T extends SalesOrderFindManyArgs>(args?: SelectSubset<T, SalesOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesOrder.
     * @param {SalesOrderCreateArgs} args - Arguments to create a SalesOrder.
     * @example
     * // Create one SalesOrder
     * const SalesOrder = await prisma.salesOrder.create({
     *   data: {
     *     // ... data to create a SalesOrder
     *   }
     * })
     * 
     */
    create<T extends SalesOrderCreateArgs>(args: SelectSubset<T, SalesOrderCreateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesOrders.
     * @param {SalesOrderCreateManyArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderCreateManyArgs>(args?: SelectSubset<T, SalesOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrders and returns the data saved in the database.
     * @param {SalesOrderCreateManyAndReturnArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrders and only return the `salesOrderId`
     * const salesOrderWithSalesOrderIdOnly = await prisma.salesOrder.createManyAndReturn({ 
     *   select: { salesOrderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalesOrder.
     * @param {SalesOrderDeleteArgs} args - Arguments to delete one SalesOrder.
     * @example
     * // Delete one SalesOrder
     * const SalesOrder = await prisma.salesOrder.delete({
     *   where: {
     *     // ... filter to delete one SalesOrder
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderDeleteArgs>(args: SelectSubset<T, SalesOrderDeleteArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesOrder.
     * @param {SalesOrderUpdateArgs} args - Arguments to update one SalesOrder.
     * @example
     * // Update one SalesOrder
     * const salesOrder = await prisma.salesOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderUpdateArgs>(args: SelectSubset<T, SalesOrderUpdateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesOrders.
     * @param {SalesOrderDeleteManyArgs} args - Arguments to filter SalesOrders to delete.
     * @example
     * // Delete a few SalesOrders
     * const { count } = await prisma.salesOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderDeleteManyArgs>(args?: SelectSubset<T, SalesOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderUpdateManyArgs>(args: SelectSubset<T, SalesOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesOrder.
     * @param {SalesOrderUpsertArgs} args - Arguments to update or create a SalesOrder.
     * @example
     * // Update or create a SalesOrder
     * const salesOrder = await prisma.salesOrder.upsert({
     *   create: {
     *     // ... data to create a SalesOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrder we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderUpsertArgs>(args: SelectSubset<T, SalesOrderUpsertArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderCountArgs} args - Arguments to filter SalesOrders to count.
     * @example
     * // Count the number of SalesOrders
     * const count = await prisma.salesOrder.count({
     *   where: {
     *     // ... the filter for the SalesOrders we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderCountArgs>(
      args?: Subset<T, SalesOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderAggregateArgs>(args: Subset<T, SalesOrderAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderAggregateType<T>>

    /**
     * Group by SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrder model
   */
  readonly fields: SalesOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dispatches<T extends SalesOrder$dispatchesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$dispatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends SalesOrder$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    lines<T extends SalesOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends SalesOrder$creatorArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrder model
   */ 
  interface SalesOrderFieldRefs {
    readonly salesOrderId: FieldRef<"SalesOrder", 'BigInt'>
    readonly orderNo: FieldRef<"SalesOrder", 'String'>
    readonly customerId: FieldRef<"SalesOrder", 'BigInt'>
    readonly orderDate: FieldRef<"SalesOrder", 'DateTime'>
    readonly status: FieldRef<"SalesOrder", 'DocStatus'>
    readonly notes: FieldRef<"SalesOrder", 'String'>
    readonly subtotal: FieldRef<"SalesOrder", 'Decimal'>
    readonly discount: FieldRef<"SalesOrder", 'Decimal'>
    readonly tax: FieldRef<"SalesOrder", 'Decimal'>
    readonly total: FieldRef<"SalesOrder", 'Decimal'>
    readonly isEditedAfterConfirm: FieldRef<"SalesOrder", 'Boolean'>
    readonly createdBy: FieldRef<"SalesOrder", 'BigInt'>
    readonly createdAt: FieldRef<"SalesOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrder findUnique
   */
  export type SalesOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findUniqueOrThrow
   */
  export type SalesOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findFirst
   */
  export type SalesOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findFirstOrThrow
   */
  export type SalesOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findMany
   */
  export type SalesOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrders to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder create
   */
  export type SalesOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrder.
     */
    data: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
  }

  /**
   * SalesOrder createMany
   */
  export type SalesOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOrder createManyAndReturn
   */
  export type SalesOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrder update
   */
  export type SalesOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrder.
     */
    data: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
    /**
     * Choose, which SalesOrder to update.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder updateMany
   */
  export type SalesOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
  }

  /**
   * SalesOrder upsert
   */
  export type SalesOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrder to update in case it exists.
     */
    where: SalesOrderWhereUniqueInput
    /**
     * In case the SalesOrder found by the `where` argument doesn't exist, create a new SalesOrder with this data.
     */
    create: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
    /**
     * In case the SalesOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
  }

  /**
   * SalesOrder delete
   */
  export type SalesOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter which SalesOrder to delete.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder deleteMany
   */
  export type SalesOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrders to delete
     */
    where?: SalesOrderWhereInput
  }

  /**
   * SalesOrder.dispatches
   */
  export type SalesOrder$dispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    where?: DispatchWhereInput
    orderBy?: DispatchOrderByWithRelationInput | DispatchOrderByWithRelationInput[]
    cursor?: DispatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispatchScalarFieldEnum | DispatchScalarFieldEnum[]
  }

  /**
   * SalesOrder.invoices
   */
  export type SalesOrder$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * SalesOrder.lines
   */
  export type SalesOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrder.creator
   */
  export type SalesOrder$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SalesOrder without action
   */
  export type SalesOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrderLine
   */

  export type AggregateSalesOrderLine = {
    _count: SalesOrderLineCountAggregateOutputType | null
    _avg: SalesOrderLineAvgAggregateOutputType | null
    _sum: SalesOrderLineSumAggregateOutputType | null
    _min: SalesOrderLineMinAggregateOutputType | null
    _max: SalesOrderLineMaxAggregateOutputType | null
  }

  export type SalesOrderLineAvgAggregateOutputType = {
    salesOrderLineId: number | null
    salesOrderId: number | null
    itemId: number | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineSumAggregateOutputType = {
    salesOrderLineId: bigint | null
    salesOrderId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineMinAggregateOutputType = {
    salesOrderLineId: bigint | null
    salesOrderId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineMaxAggregateOutputType = {
    salesOrderLineId: bigint | null
    salesOrderId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineCountAggregateOutputType = {
    salesOrderLineId: number
    salesOrderId: number
    itemId: number
    qty: number
    unitPrice: number
    lineTotal: number
    _all: number
  }


  export type SalesOrderLineAvgAggregateInputType = {
    salesOrderLineId?: true
    salesOrderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SalesOrderLineSumAggregateInputType = {
    salesOrderLineId?: true
    salesOrderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SalesOrderLineMinAggregateInputType = {
    salesOrderLineId?: true
    salesOrderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SalesOrderLineMaxAggregateInputType = {
    salesOrderLineId?: true
    salesOrderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SalesOrderLineCountAggregateInputType = {
    salesOrderLineId?: true
    salesOrderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    _all?: true
  }

  export type SalesOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrderLine to aggregate.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrderLines
    **/
    _count?: true | SalesOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderLineMaxAggregateInputType
  }

  export type GetSalesOrderLineAggregateType<T extends SalesOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrderLine[P]>
      : GetScalarType<T[P], AggregateSalesOrderLine[P]>
  }




  export type SalesOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithAggregationInput | SalesOrderLineOrderByWithAggregationInput[]
    by: SalesOrderLineScalarFieldEnum[] | SalesOrderLineScalarFieldEnum
    having?: SalesOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderLineCountAggregateInputType | true
    _avg?: SalesOrderLineAvgAggregateInputType
    _sum?: SalesOrderLineSumAggregateInputType
    _min?: SalesOrderLineMinAggregateInputType
    _max?: SalesOrderLineMaxAggregateInputType
  }

  export type SalesOrderLineGroupByOutputType = {
    salesOrderLineId: bigint
    salesOrderId: bigint
    itemId: bigint
    qty: Decimal
    unitPrice: Decimal
    lineTotal: Decimal
    _count: SalesOrderLineCountAggregateOutputType | null
    _avg: SalesOrderLineAvgAggregateOutputType | null
    _sum: SalesOrderLineSumAggregateOutputType | null
    _min: SalesOrderLineMinAggregateOutputType | null
    _max: SalesOrderLineMaxAggregateOutputType | null
  }

  type GetSalesOrderLineGroupByPayload<T extends SalesOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salesOrderLineId?: boolean
    salesOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    salesOrderLineId?: boolean
    salesOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectScalar = {
    salesOrderLineId?: boolean
    salesOrderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
  }

  export type SalesOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }
  export type SalesOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }

  export type $SalesOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrderLine"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      salesOrder: Prisma.$SalesOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      salesOrderLineId: bigint
      salesOrderId: bigint
      itemId: bigint
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["salesOrderLine"]>
    composites: {}
  }

  type SalesOrderLineGetPayload<S extends boolean | null | undefined | SalesOrderLineDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderLinePayload, S>

  type SalesOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesOrderLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesOrderLineCountAggregateInputType | true
    }

  export interface SalesOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrderLine'], meta: { name: 'SalesOrderLine' } }
    /**
     * Find zero or one SalesOrderLine that matches the filter.
     * @param {SalesOrderLineFindUniqueArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderLineFindUniqueArgs>(args: SelectSubset<T, SalesOrderLineFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesOrderLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesOrderLineFindUniqueOrThrowArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindFirstArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderLineFindFirstArgs>(args?: SelectSubset<T, SalesOrderLineFindFirstArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindFirstOrThrowArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrderLines
     * const salesOrderLines = await prisma.salesOrderLine.findMany()
     * 
     * // Get first 10 SalesOrderLines
     * const salesOrderLines = await prisma.salesOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `salesOrderLineId`
     * const salesOrderLineWithSalesOrderLineIdOnly = await prisma.salesOrderLine.findMany({ select: { salesOrderLineId: true } })
     * 
     */
    findMany<T extends SalesOrderLineFindManyArgs>(args?: SelectSubset<T, SalesOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesOrderLine.
     * @param {SalesOrderLineCreateArgs} args - Arguments to create a SalesOrderLine.
     * @example
     * // Create one SalesOrderLine
     * const SalesOrderLine = await prisma.salesOrderLine.create({
     *   data: {
     *     // ... data to create a SalesOrderLine
     *   }
     * })
     * 
     */
    create<T extends SalesOrderLineCreateArgs>(args: SelectSubset<T, SalesOrderLineCreateArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesOrderLines.
     * @param {SalesOrderLineCreateManyArgs} args - Arguments to create many SalesOrderLines.
     * @example
     * // Create many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderLineCreateManyArgs>(args?: SelectSubset<T, SalesOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrderLines and returns the data saved in the database.
     * @param {SalesOrderLineCreateManyAndReturnArgs} args - Arguments to create many SalesOrderLines.
     * @example
     * // Create many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrderLines and only return the `salesOrderLineId`
     * const salesOrderLineWithSalesOrderLineIdOnly = await prisma.salesOrderLine.createManyAndReturn({ 
     *   select: { salesOrderLineId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalesOrderLine.
     * @param {SalesOrderLineDeleteArgs} args - Arguments to delete one SalesOrderLine.
     * @example
     * // Delete one SalesOrderLine
     * const SalesOrderLine = await prisma.salesOrderLine.delete({
     *   where: {
     *     // ... filter to delete one SalesOrderLine
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderLineDeleteArgs>(args: SelectSubset<T, SalesOrderLineDeleteArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesOrderLine.
     * @param {SalesOrderLineUpdateArgs} args - Arguments to update one SalesOrderLine.
     * @example
     * // Update one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderLineUpdateArgs>(args: SelectSubset<T, SalesOrderLineUpdateArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesOrderLines.
     * @param {SalesOrderLineDeleteManyArgs} args - Arguments to filter SalesOrderLines to delete.
     * @example
     * // Delete a few SalesOrderLines
     * const { count } = await prisma.salesOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderLineDeleteManyArgs>(args?: SelectSubset<T, SalesOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderLineUpdateManyArgs>(args: SelectSubset<T, SalesOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesOrderLine.
     * @param {SalesOrderLineUpsertArgs} args - Arguments to update or create a SalesOrderLine.
     * @example
     * // Update or create a SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.upsert({
     *   create: {
     *     // ... data to create a SalesOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderLineUpsertArgs>(args: SelectSubset<T, SalesOrderLineUpsertArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineCountArgs} args - Arguments to filter SalesOrderLines to count.
     * @example
     * // Count the number of SalesOrderLines
     * const count = await prisma.salesOrderLine.count({
     *   where: {
     *     // ... the filter for the SalesOrderLines we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderLineCountArgs>(
      args?: Subset<T, SalesOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderLineAggregateArgs>(args: Subset<T, SalesOrderLineAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderLineAggregateType<T>>

    /**
     * Group by SalesOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrderLine model
   */
  readonly fields: SalesOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    salesOrder<T extends SalesOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderDefaultArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrderLine model
   */ 
  interface SalesOrderLineFieldRefs {
    readonly salesOrderLineId: FieldRef<"SalesOrderLine", 'BigInt'>
    readonly salesOrderId: FieldRef<"SalesOrderLine", 'BigInt'>
    readonly itemId: FieldRef<"SalesOrderLine", 'BigInt'>
    readonly qty: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly lineTotal: FieldRef<"SalesOrderLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrderLine findUnique
   */
  export type SalesOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine findUniqueOrThrow
   */
  export type SalesOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine findFirst
   */
  export type SalesOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrderLines.
     */
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine findFirstOrThrow
   */
  export type SalesOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrderLines.
     */
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine findMany
   */
  export type SalesOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLines to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine create
   */
  export type SalesOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrderLine.
     */
    data: XOR<SalesOrderLineCreateInput, SalesOrderLineUncheckedCreateInput>
  }

  /**
   * SalesOrderLine createMany
   */
  export type SalesOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrderLines.
     */
    data: SalesOrderLineCreateManyInput | SalesOrderLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOrderLine createManyAndReturn
   */
  export type SalesOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalesOrderLines.
     */
    data: SalesOrderLineCreateManyInput | SalesOrderLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrderLine update
   */
  export type SalesOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrderLine.
     */
    data: XOR<SalesOrderLineUpdateInput, SalesOrderLineUncheckedUpdateInput>
    /**
     * Choose, which SalesOrderLine to update.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine updateMany
   */
  export type SalesOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrderLines.
     */
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrderLines to update
     */
    where?: SalesOrderLineWhereInput
  }

  /**
   * SalesOrderLine upsert
   */
  export type SalesOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrderLine to update in case it exists.
     */
    where: SalesOrderLineWhereUniqueInput
    /**
     * In case the SalesOrderLine found by the `where` argument doesn't exist, create a new SalesOrderLine with this data.
     */
    create: XOR<SalesOrderLineCreateInput, SalesOrderLineUncheckedCreateInput>
    /**
     * In case the SalesOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderLineUpdateInput, SalesOrderLineUncheckedUpdateInput>
  }

  /**
   * SalesOrderLine delete
   */
  export type SalesOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter which SalesOrderLine to delete.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine deleteMany
   */
  export type SalesOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrderLines to delete
     */
    where?: SalesOrderLineWhereInput
  }

  /**
   * SalesOrderLine without action
   */
  export type SalesOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model Dispatch
   */

  export type AggregateDispatch = {
    _count: DispatchCountAggregateOutputType | null
    _avg: DispatchAvgAggregateOutputType | null
    _sum: DispatchSumAggregateOutputType | null
    _min: DispatchMinAggregateOutputType | null
    _max: DispatchMaxAggregateOutputType | null
  }

  export type DispatchAvgAggregateOutputType = {
    dispatchId: number | null
    salesOrderId: number | null
    createdBy: number | null
  }

  export type DispatchSumAggregateOutputType = {
    dispatchId: bigint | null
    salesOrderId: bigint | null
    createdBy: bigint | null
  }

  export type DispatchMinAggregateOutputType = {
    dispatchId: bigint | null
    dispatchNo: string | null
    salesOrderId: bigint | null
    dispatchDate: Date | null
    vehicleNo: string | null
    driverName: string | null
    status: $Enums.DocStatus | null
    remarks: string | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type DispatchMaxAggregateOutputType = {
    dispatchId: bigint | null
    dispatchNo: string | null
    salesOrderId: bigint | null
    dispatchDate: Date | null
    vehicleNo: string | null
    driverName: string | null
    status: $Enums.DocStatus | null
    remarks: string | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type DispatchCountAggregateOutputType = {
    dispatchId: number
    dispatchNo: number
    salesOrderId: number
    dispatchDate: number
    vehicleNo: number
    driverName: number
    status: number
    remarks: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type DispatchAvgAggregateInputType = {
    dispatchId?: true
    salesOrderId?: true
    createdBy?: true
  }

  export type DispatchSumAggregateInputType = {
    dispatchId?: true
    salesOrderId?: true
    createdBy?: true
  }

  export type DispatchMinAggregateInputType = {
    dispatchId?: true
    dispatchNo?: true
    salesOrderId?: true
    dispatchDate?: true
    vehicleNo?: true
    driverName?: true
    status?: true
    remarks?: true
    createdBy?: true
    createdAt?: true
  }

  export type DispatchMaxAggregateInputType = {
    dispatchId?: true
    dispatchNo?: true
    salesOrderId?: true
    dispatchDate?: true
    vehicleNo?: true
    driverName?: true
    status?: true
    remarks?: true
    createdBy?: true
    createdAt?: true
  }

  export type DispatchCountAggregateInputType = {
    dispatchId?: true
    dispatchNo?: true
    salesOrderId?: true
    dispatchDate?: true
    vehicleNo?: true
    driverName?: true
    status?: true
    remarks?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type DispatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispatch to aggregate.
     */
    where?: DispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispatches to fetch.
     */
    orderBy?: DispatchOrderByWithRelationInput | DispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dispatches
    **/
    _count?: true | DispatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispatchMaxAggregateInputType
  }

  export type GetDispatchAggregateType<T extends DispatchAggregateArgs> = {
        [P in keyof T & keyof AggregateDispatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispatch[P]>
      : GetScalarType<T[P], AggregateDispatch[P]>
  }




  export type DispatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispatchWhereInput
    orderBy?: DispatchOrderByWithAggregationInput | DispatchOrderByWithAggregationInput[]
    by: DispatchScalarFieldEnum[] | DispatchScalarFieldEnum
    having?: DispatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispatchCountAggregateInputType | true
    _avg?: DispatchAvgAggregateInputType
    _sum?: DispatchSumAggregateInputType
    _min?: DispatchMinAggregateInputType
    _max?: DispatchMaxAggregateInputType
  }

  export type DispatchGroupByOutputType = {
    dispatchId: bigint
    dispatchNo: string
    salesOrderId: bigint
    dispatchDate: Date
    vehicleNo: string | null
    driverName: string | null
    status: $Enums.DocStatus
    remarks: string | null
    createdBy: bigint | null
    createdAt: Date
    _count: DispatchCountAggregateOutputType | null
    _avg: DispatchAvgAggregateOutputType | null
    _sum: DispatchSumAggregateOutputType | null
    _min: DispatchMinAggregateOutputType | null
    _max: DispatchMaxAggregateOutputType | null
  }

  type GetDispatchGroupByPayload<T extends DispatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispatchGroupByOutputType[P]>
            : GetScalarType<T[P], DispatchGroupByOutputType[P]>
        }
      >
    >


  export type DispatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dispatchId?: boolean
    dispatchNo?: boolean
    salesOrderId?: boolean
    dispatchDate?: boolean
    vehicleNo?: boolean
    driverName?: boolean
    status?: boolean
    remarks?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | Dispatch$creatorArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatch"]>

  export type DispatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dispatchId?: boolean
    dispatchNo?: boolean
    salesOrderId?: boolean
    dispatchDate?: boolean
    vehicleNo?: boolean
    driverName?: boolean
    status?: boolean
    remarks?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | Dispatch$creatorArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispatch"]>

  export type DispatchSelectScalar = {
    dispatchId?: boolean
    dispatchNo?: boolean
    salesOrderId?: boolean
    dispatchDate?: boolean
    vehicleNo?: boolean
    driverName?: boolean
    status?: boolean
    remarks?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type DispatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Dispatch$creatorArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }
  export type DispatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Dispatch$creatorArgs<ExtArgs>
    salesOrder?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }

  export type $DispatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispatch"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      salesOrder: Prisma.$SalesOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      dispatchId: bigint
      dispatchNo: string
      salesOrderId: bigint
      dispatchDate: Date
      vehicleNo: string | null
      driverName: string | null
      status: $Enums.DocStatus
      remarks: string | null
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["dispatch"]>
    composites: {}
  }

  type DispatchGetPayload<S extends boolean | null | undefined | DispatchDefaultArgs> = $Result.GetResult<Prisma.$DispatchPayload, S>

  type DispatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DispatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DispatchCountAggregateInputType | true
    }

  export interface DispatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispatch'], meta: { name: 'Dispatch' } }
    /**
     * Find zero or one Dispatch that matches the filter.
     * @param {DispatchFindUniqueArgs} args - Arguments to find a Dispatch
     * @example
     * // Get one Dispatch
     * const dispatch = await prisma.dispatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispatchFindUniqueArgs>(args: SelectSubset<T, DispatchFindUniqueArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dispatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DispatchFindUniqueOrThrowArgs} args - Arguments to find a Dispatch
     * @example
     * // Get one Dispatch
     * const dispatch = await prisma.dispatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispatchFindUniqueOrThrowArgs>(args: SelectSubset<T, DispatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dispatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchFindFirstArgs} args - Arguments to find a Dispatch
     * @example
     * // Get one Dispatch
     * const dispatch = await prisma.dispatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispatchFindFirstArgs>(args?: SelectSubset<T, DispatchFindFirstArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dispatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchFindFirstOrThrowArgs} args - Arguments to find a Dispatch
     * @example
     * // Get one Dispatch
     * const dispatch = await prisma.dispatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispatchFindFirstOrThrowArgs>(args?: SelectSubset<T, DispatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dispatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dispatches
     * const dispatches = await prisma.dispatch.findMany()
     * 
     * // Get first 10 Dispatches
     * const dispatches = await prisma.dispatch.findMany({ take: 10 })
     * 
     * // Only select the `dispatchId`
     * const dispatchWithDispatchIdOnly = await prisma.dispatch.findMany({ select: { dispatchId: true } })
     * 
     */
    findMany<T extends DispatchFindManyArgs>(args?: SelectSubset<T, DispatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dispatch.
     * @param {DispatchCreateArgs} args - Arguments to create a Dispatch.
     * @example
     * // Create one Dispatch
     * const Dispatch = await prisma.dispatch.create({
     *   data: {
     *     // ... data to create a Dispatch
     *   }
     * })
     * 
     */
    create<T extends DispatchCreateArgs>(args: SelectSubset<T, DispatchCreateArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dispatches.
     * @param {DispatchCreateManyArgs} args - Arguments to create many Dispatches.
     * @example
     * // Create many Dispatches
     * const dispatch = await prisma.dispatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispatchCreateManyArgs>(args?: SelectSubset<T, DispatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dispatches and returns the data saved in the database.
     * @param {DispatchCreateManyAndReturnArgs} args - Arguments to create many Dispatches.
     * @example
     * // Create many Dispatches
     * const dispatch = await prisma.dispatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dispatches and only return the `dispatchId`
     * const dispatchWithDispatchIdOnly = await prisma.dispatch.createManyAndReturn({ 
     *   select: { dispatchId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispatchCreateManyAndReturnArgs>(args?: SelectSubset<T, DispatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dispatch.
     * @param {DispatchDeleteArgs} args - Arguments to delete one Dispatch.
     * @example
     * // Delete one Dispatch
     * const Dispatch = await prisma.dispatch.delete({
     *   where: {
     *     // ... filter to delete one Dispatch
     *   }
     * })
     * 
     */
    delete<T extends DispatchDeleteArgs>(args: SelectSubset<T, DispatchDeleteArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dispatch.
     * @param {DispatchUpdateArgs} args - Arguments to update one Dispatch.
     * @example
     * // Update one Dispatch
     * const dispatch = await prisma.dispatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispatchUpdateArgs>(args: SelectSubset<T, DispatchUpdateArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dispatches.
     * @param {DispatchDeleteManyArgs} args - Arguments to filter Dispatches to delete.
     * @example
     * // Delete a few Dispatches
     * const { count } = await prisma.dispatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispatchDeleteManyArgs>(args?: SelectSubset<T, DispatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dispatches
     * const dispatch = await prisma.dispatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispatchUpdateManyArgs>(args: SelectSubset<T, DispatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dispatch.
     * @param {DispatchUpsertArgs} args - Arguments to update or create a Dispatch.
     * @example
     * // Update or create a Dispatch
     * const dispatch = await prisma.dispatch.upsert({
     *   create: {
     *     // ... data to create a Dispatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispatch we want to update
     *   }
     * })
     */
    upsert<T extends DispatchUpsertArgs>(args: SelectSubset<T, DispatchUpsertArgs<ExtArgs>>): Prisma__DispatchClient<$Result.GetResult<Prisma.$DispatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dispatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchCountArgs} args - Arguments to filter Dispatches to count.
     * @example
     * // Count the number of Dispatches
     * const count = await prisma.dispatch.count({
     *   where: {
     *     // ... the filter for the Dispatches we want to count
     *   }
     * })
    **/
    count<T extends DispatchCountArgs>(
      args?: Subset<T, DispatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispatchAggregateArgs>(args: Subset<T, DispatchAggregateArgs>): Prisma.PrismaPromise<GetDispatchAggregateType<T>>

    /**
     * Group by Dispatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispatchGroupByArgs['orderBy'] }
        : { orderBy?: DispatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispatch model
   */
  readonly fields: DispatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Dispatch$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Dispatch$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    salesOrder<T extends SalesOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderDefaultArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispatch model
   */ 
  interface DispatchFieldRefs {
    readonly dispatchId: FieldRef<"Dispatch", 'BigInt'>
    readonly dispatchNo: FieldRef<"Dispatch", 'String'>
    readonly salesOrderId: FieldRef<"Dispatch", 'BigInt'>
    readonly dispatchDate: FieldRef<"Dispatch", 'DateTime'>
    readonly vehicleNo: FieldRef<"Dispatch", 'String'>
    readonly driverName: FieldRef<"Dispatch", 'String'>
    readonly status: FieldRef<"Dispatch", 'DocStatus'>
    readonly remarks: FieldRef<"Dispatch", 'String'>
    readonly createdBy: FieldRef<"Dispatch", 'BigInt'>
    readonly createdAt: FieldRef<"Dispatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispatch findUnique
   */
  export type DispatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * Filter, which Dispatch to fetch.
     */
    where: DispatchWhereUniqueInput
  }

  /**
   * Dispatch findUniqueOrThrow
   */
  export type DispatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * Filter, which Dispatch to fetch.
     */
    where: DispatchWhereUniqueInput
  }

  /**
   * Dispatch findFirst
   */
  export type DispatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * Filter, which Dispatch to fetch.
     */
    where?: DispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispatches to fetch.
     */
    orderBy?: DispatchOrderByWithRelationInput | DispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispatches.
     */
    cursor?: DispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispatches.
     */
    distinct?: DispatchScalarFieldEnum | DispatchScalarFieldEnum[]
  }

  /**
   * Dispatch findFirstOrThrow
   */
  export type DispatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * Filter, which Dispatch to fetch.
     */
    where?: DispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispatches to fetch.
     */
    orderBy?: DispatchOrderByWithRelationInput | DispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispatches.
     */
    cursor?: DispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispatches.
     */
    distinct?: DispatchScalarFieldEnum | DispatchScalarFieldEnum[]
  }

  /**
   * Dispatch findMany
   */
  export type DispatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * Filter, which Dispatches to fetch.
     */
    where?: DispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispatches to fetch.
     */
    orderBy?: DispatchOrderByWithRelationInput | DispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dispatches.
     */
    cursor?: DispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispatches.
     */
    skip?: number
    distinct?: DispatchScalarFieldEnum | DispatchScalarFieldEnum[]
  }

  /**
   * Dispatch create
   */
  export type DispatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispatch.
     */
    data: XOR<DispatchCreateInput, DispatchUncheckedCreateInput>
  }

  /**
   * Dispatch createMany
   */
  export type DispatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dispatches.
     */
    data: DispatchCreateManyInput | DispatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispatch createManyAndReturn
   */
  export type DispatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Dispatches.
     */
    data: DispatchCreateManyInput | DispatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispatch update
   */
  export type DispatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispatch.
     */
    data: XOR<DispatchUpdateInput, DispatchUncheckedUpdateInput>
    /**
     * Choose, which Dispatch to update.
     */
    where: DispatchWhereUniqueInput
  }

  /**
   * Dispatch updateMany
   */
  export type DispatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dispatches.
     */
    data: XOR<DispatchUpdateManyMutationInput, DispatchUncheckedUpdateManyInput>
    /**
     * Filter which Dispatches to update
     */
    where?: DispatchWhereInput
  }

  /**
   * Dispatch upsert
   */
  export type DispatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispatch to update in case it exists.
     */
    where: DispatchWhereUniqueInput
    /**
     * In case the Dispatch found by the `where` argument doesn't exist, create a new Dispatch with this data.
     */
    create: XOR<DispatchCreateInput, DispatchUncheckedCreateInput>
    /**
     * In case the Dispatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispatchUpdateInput, DispatchUncheckedUpdateInput>
  }

  /**
   * Dispatch delete
   */
  export type DispatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
    /**
     * Filter which Dispatch to delete.
     */
    where: DispatchWhereUniqueInput
  }

  /**
   * Dispatch deleteMany
   */
  export type DispatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispatches to delete
     */
    where?: DispatchWhereInput
  }

  /**
   * Dispatch.creator
   */
  export type Dispatch$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Dispatch without action
   */
  export type DispatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispatch
     */
    select?: DispatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispatchInclude<ExtArgs> | null
  }


  /**
   * Model ProductionDay
   */

  export type AggregateProductionDay = {
    _count: ProductionDayCountAggregateOutputType | null
    _avg: ProductionDayAvgAggregateOutputType | null
    _sum: ProductionDaySumAggregateOutputType | null
    _min: ProductionDayMinAggregateOutputType | null
    _max: ProductionDayMaxAggregateOutputType | null
  }

  export type ProductionDayAvgAggregateOutputType = {
    productionDayId: number | null
    finishedProductId: number | null
    quantity: Decimal | null
    scrapQuantity: Decimal | null
    closedBy: number | null
    reopenedBy: number | null
    createdBy: number | null
  }

  export type ProductionDaySumAggregateOutputType = {
    productionDayId: bigint | null
    finishedProductId: bigint | null
    quantity: Decimal | null
    scrapQuantity: Decimal | null
    closedBy: bigint | null
    reopenedBy: bigint | null
    createdBy: bigint | null
  }

  export type ProductionDayMinAggregateOutputType = {
    productionDayId: bigint | null
    productionDate: Date | null
    finishedProductId: bigint | null
    quantity: Decimal | null
    scrapQuantity: Decimal | null
    notes: string | null
    isClosed: boolean | null
    closedAt: Date | null
    closedBy: bigint | null
    reopenReason: string | null
    reopenedBy: bigint | null
    reopenedAt: Date | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type ProductionDayMaxAggregateOutputType = {
    productionDayId: bigint | null
    productionDate: Date | null
    finishedProductId: bigint | null
    quantity: Decimal | null
    scrapQuantity: Decimal | null
    notes: string | null
    isClosed: boolean | null
    closedAt: Date | null
    closedBy: bigint | null
    reopenReason: string | null
    reopenedBy: bigint | null
    reopenedAt: Date | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type ProductionDayCountAggregateOutputType = {
    productionDayId: number
    productionDate: number
    finishedProductId: number
    quantity: number
    scrapQuantity: number
    notes: number
    isClosed: number
    closedAt: number
    closedBy: number
    reopenReason: number
    reopenedBy: number
    reopenedAt: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ProductionDayAvgAggregateInputType = {
    productionDayId?: true
    finishedProductId?: true
    quantity?: true
    scrapQuantity?: true
    closedBy?: true
    reopenedBy?: true
    createdBy?: true
  }

  export type ProductionDaySumAggregateInputType = {
    productionDayId?: true
    finishedProductId?: true
    quantity?: true
    scrapQuantity?: true
    closedBy?: true
    reopenedBy?: true
    createdBy?: true
  }

  export type ProductionDayMinAggregateInputType = {
    productionDayId?: true
    productionDate?: true
    finishedProductId?: true
    quantity?: true
    scrapQuantity?: true
    notes?: true
    isClosed?: true
    closedAt?: true
    closedBy?: true
    reopenReason?: true
    reopenedBy?: true
    reopenedAt?: true
    createdBy?: true
    createdAt?: true
  }

  export type ProductionDayMaxAggregateInputType = {
    productionDayId?: true
    productionDate?: true
    finishedProductId?: true
    quantity?: true
    scrapQuantity?: true
    notes?: true
    isClosed?: true
    closedAt?: true
    closedBy?: true
    reopenReason?: true
    reopenedBy?: true
    reopenedAt?: true
    createdBy?: true
    createdAt?: true
  }

  export type ProductionDayCountAggregateInputType = {
    productionDayId?: true
    productionDate?: true
    finishedProductId?: true
    quantity?: true
    scrapQuantity?: true
    notes?: true
    isClosed?: true
    closedAt?: true
    closedBy?: true
    reopenReason?: true
    reopenedBy?: true
    reopenedAt?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ProductionDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionDay to aggregate.
     */
    where?: ProductionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDays to fetch.
     */
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionDays
    **/
    _count?: true | ProductionDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionDayMaxAggregateInputType
  }

  export type GetProductionDayAggregateType<T extends ProductionDayAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionDay[P]>
      : GetScalarType<T[P], AggregateProductionDay[P]>
  }




  export type ProductionDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionDayWhereInput
    orderBy?: ProductionDayOrderByWithAggregationInput | ProductionDayOrderByWithAggregationInput[]
    by: ProductionDayScalarFieldEnum[] | ProductionDayScalarFieldEnum
    having?: ProductionDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionDayCountAggregateInputType | true
    _avg?: ProductionDayAvgAggregateInputType
    _sum?: ProductionDaySumAggregateInputType
    _min?: ProductionDayMinAggregateInputType
    _max?: ProductionDayMaxAggregateInputType
  }

  export type ProductionDayGroupByOutputType = {
    productionDayId: bigint
    productionDate: Date
    finishedProductId: bigint
    quantity: Decimal
    scrapQuantity: Decimal
    notes: string | null
    isClosed: boolean
    closedAt: Date | null
    closedBy: bigint | null
    reopenReason: string | null
    reopenedBy: bigint | null
    reopenedAt: Date | null
    createdBy: bigint | null
    createdAt: Date
    _count: ProductionDayCountAggregateOutputType | null
    _avg: ProductionDayAvgAggregateOutputType | null
    _sum: ProductionDaySumAggregateOutputType | null
    _min: ProductionDayMinAggregateOutputType | null
    _max: ProductionDayMaxAggregateOutputType | null
  }

  type GetProductionDayGroupByPayload<T extends ProductionDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionDayGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionDayGroupByOutputType[P]>
        }
      >
    >


  export type ProductionDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productionDayId?: boolean
    productionDate?: boolean
    finishedProductId?: boolean
    quantity?: boolean
    scrapQuantity?: boolean
    notes?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedBy?: boolean
    reopenReason?: boolean
    reopenedBy?: boolean
    reopenedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    closer?: boolean | ProductionDay$closerArgs<ExtArgs>
    creator?: boolean | ProductionDay$creatorArgs<ExtArgs>
    finishedProduct?: boolean | ItemDefaultArgs<ExtArgs>
    reopener?: boolean | ProductionDay$reopenerArgs<ExtArgs>
  }, ExtArgs["result"]["productionDay"]>

  export type ProductionDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productionDayId?: boolean
    productionDate?: boolean
    finishedProductId?: boolean
    quantity?: boolean
    scrapQuantity?: boolean
    notes?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedBy?: boolean
    reopenReason?: boolean
    reopenedBy?: boolean
    reopenedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    closer?: boolean | ProductionDay$closerArgs<ExtArgs>
    creator?: boolean | ProductionDay$creatorArgs<ExtArgs>
    finishedProduct?: boolean | ItemDefaultArgs<ExtArgs>
    reopener?: boolean | ProductionDay$reopenerArgs<ExtArgs>
  }, ExtArgs["result"]["productionDay"]>

  export type ProductionDaySelectScalar = {
    productionDayId?: boolean
    productionDate?: boolean
    finishedProductId?: boolean
    quantity?: boolean
    scrapQuantity?: boolean
    notes?: boolean
    isClosed?: boolean
    closedAt?: boolean
    closedBy?: boolean
    reopenReason?: boolean
    reopenedBy?: boolean
    reopenedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ProductionDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closer?: boolean | ProductionDay$closerArgs<ExtArgs>
    creator?: boolean | ProductionDay$creatorArgs<ExtArgs>
    finishedProduct?: boolean | ItemDefaultArgs<ExtArgs>
    reopener?: boolean | ProductionDay$reopenerArgs<ExtArgs>
  }
  export type ProductionDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closer?: boolean | ProductionDay$closerArgs<ExtArgs>
    creator?: boolean | ProductionDay$creatorArgs<ExtArgs>
    finishedProduct?: boolean | ItemDefaultArgs<ExtArgs>
    reopener?: boolean | ProductionDay$reopenerArgs<ExtArgs>
  }

  export type $ProductionDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionDay"
    objects: {
      closer: Prisma.$UserPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      finishedProduct: Prisma.$ItemPayload<ExtArgs>
      reopener: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      productionDayId: bigint
      productionDate: Date
      finishedProductId: bigint
      quantity: Prisma.Decimal
      scrapQuantity: Prisma.Decimal
      notes: string | null
      isClosed: boolean
      closedAt: Date | null
      closedBy: bigint | null
      reopenReason: string | null
      reopenedBy: bigint | null
      reopenedAt: Date | null
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["productionDay"]>
    composites: {}
  }

  type ProductionDayGetPayload<S extends boolean | null | undefined | ProductionDayDefaultArgs> = $Result.GetResult<Prisma.$ProductionDayPayload, S>

  type ProductionDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductionDayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductionDayCountAggregateInputType | true
    }

  export interface ProductionDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionDay'], meta: { name: 'ProductionDay' } }
    /**
     * Find zero or one ProductionDay that matches the filter.
     * @param {ProductionDayFindUniqueArgs} args - Arguments to find a ProductionDay
     * @example
     * // Get one ProductionDay
     * const productionDay = await prisma.productionDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionDayFindUniqueArgs>(args: SelectSubset<T, ProductionDayFindUniqueArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductionDay that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductionDayFindUniqueOrThrowArgs} args - Arguments to find a ProductionDay
     * @example
     * // Get one ProductionDay
     * const productionDay = await prisma.productionDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionDayFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductionDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayFindFirstArgs} args - Arguments to find a ProductionDay
     * @example
     * // Get one ProductionDay
     * const productionDay = await prisma.productionDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionDayFindFirstArgs>(args?: SelectSubset<T, ProductionDayFindFirstArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductionDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayFindFirstOrThrowArgs} args - Arguments to find a ProductionDay
     * @example
     * // Get one ProductionDay
     * const productionDay = await prisma.productionDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionDayFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductionDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionDays
     * const productionDays = await prisma.productionDay.findMany()
     * 
     * // Get first 10 ProductionDays
     * const productionDays = await prisma.productionDay.findMany({ take: 10 })
     * 
     * // Only select the `productionDayId`
     * const productionDayWithProductionDayIdOnly = await prisma.productionDay.findMany({ select: { productionDayId: true } })
     * 
     */
    findMany<T extends ProductionDayFindManyArgs>(args?: SelectSubset<T, ProductionDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductionDay.
     * @param {ProductionDayCreateArgs} args - Arguments to create a ProductionDay.
     * @example
     * // Create one ProductionDay
     * const ProductionDay = await prisma.productionDay.create({
     *   data: {
     *     // ... data to create a ProductionDay
     *   }
     * })
     * 
     */
    create<T extends ProductionDayCreateArgs>(args: SelectSubset<T, ProductionDayCreateArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductionDays.
     * @param {ProductionDayCreateManyArgs} args - Arguments to create many ProductionDays.
     * @example
     * // Create many ProductionDays
     * const productionDay = await prisma.productionDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionDayCreateManyArgs>(args?: SelectSubset<T, ProductionDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionDays and returns the data saved in the database.
     * @param {ProductionDayCreateManyAndReturnArgs} args - Arguments to create many ProductionDays.
     * @example
     * // Create many ProductionDays
     * const productionDay = await prisma.productionDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionDays and only return the `productionDayId`
     * const productionDayWithProductionDayIdOnly = await prisma.productionDay.createManyAndReturn({ 
     *   select: { productionDayId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionDayCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductionDay.
     * @param {ProductionDayDeleteArgs} args - Arguments to delete one ProductionDay.
     * @example
     * // Delete one ProductionDay
     * const ProductionDay = await prisma.productionDay.delete({
     *   where: {
     *     // ... filter to delete one ProductionDay
     *   }
     * })
     * 
     */
    delete<T extends ProductionDayDeleteArgs>(args: SelectSubset<T, ProductionDayDeleteArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductionDay.
     * @param {ProductionDayUpdateArgs} args - Arguments to update one ProductionDay.
     * @example
     * // Update one ProductionDay
     * const productionDay = await prisma.productionDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionDayUpdateArgs>(args: SelectSubset<T, ProductionDayUpdateArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductionDays.
     * @param {ProductionDayDeleteManyArgs} args - Arguments to filter ProductionDays to delete.
     * @example
     * // Delete a few ProductionDays
     * const { count } = await prisma.productionDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionDayDeleteManyArgs>(args?: SelectSubset<T, ProductionDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionDays
     * const productionDay = await prisma.productionDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionDayUpdateManyArgs>(args: SelectSubset<T, ProductionDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductionDay.
     * @param {ProductionDayUpsertArgs} args - Arguments to update or create a ProductionDay.
     * @example
     * // Update or create a ProductionDay
     * const productionDay = await prisma.productionDay.upsert({
     *   create: {
     *     // ... data to create a ProductionDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionDay we want to update
     *   }
     * })
     */
    upsert<T extends ProductionDayUpsertArgs>(args: SelectSubset<T, ProductionDayUpsertArgs<ExtArgs>>): Prisma__ProductionDayClient<$Result.GetResult<Prisma.$ProductionDayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductionDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayCountArgs} args - Arguments to filter ProductionDays to count.
     * @example
     * // Count the number of ProductionDays
     * const count = await prisma.productionDay.count({
     *   where: {
     *     // ... the filter for the ProductionDays we want to count
     *   }
     * })
    **/
    count<T extends ProductionDayCountArgs>(
      args?: Subset<T, ProductionDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionDayAggregateArgs>(args: Subset<T, ProductionDayAggregateArgs>): Prisma.PrismaPromise<GetProductionDayAggregateType<T>>

    /**
     * Group by ProductionDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionDayGroupByArgs['orderBy'] }
        : { orderBy?: ProductionDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionDay model
   */
  readonly fields: ProductionDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    closer<T extends ProductionDay$closerArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDay$closerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends ProductionDay$creatorArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDay$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    finishedProduct<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reopener<T extends ProductionDay$reopenerArgs<ExtArgs> = {}>(args?: Subset<T, ProductionDay$reopenerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionDay model
   */ 
  interface ProductionDayFieldRefs {
    readonly productionDayId: FieldRef<"ProductionDay", 'BigInt'>
    readonly productionDate: FieldRef<"ProductionDay", 'DateTime'>
    readonly finishedProductId: FieldRef<"ProductionDay", 'BigInt'>
    readonly quantity: FieldRef<"ProductionDay", 'Decimal'>
    readonly scrapQuantity: FieldRef<"ProductionDay", 'Decimal'>
    readonly notes: FieldRef<"ProductionDay", 'String'>
    readonly isClosed: FieldRef<"ProductionDay", 'Boolean'>
    readonly closedAt: FieldRef<"ProductionDay", 'DateTime'>
    readonly closedBy: FieldRef<"ProductionDay", 'BigInt'>
    readonly reopenReason: FieldRef<"ProductionDay", 'String'>
    readonly reopenedBy: FieldRef<"ProductionDay", 'BigInt'>
    readonly reopenedAt: FieldRef<"ProductionDay", 'DateTime'>
    readonly createdBy: FieldRef<"ProductionDay", 'BigInt'>
    readonly createdAt: FieldRef<"ProductionDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionDay findUnique
   */
  export type ProductionDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDay to fetch.
     */
    where: ProductionDayWhereUniqueInput
  }

  /**
   * ProductionDay findUniqueOrThrow
   */
  export type ProductionDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDay to fetch.
     */
    where: ProductionDayWhereUniqueInput
  }

  /**
   * ProductionDay findFirst
   */
  export type ProductionDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDay to fetch.
     */
    where?: ProductionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDays to fetch.
     */
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionDays.
     */
    cursor?: ProductionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionDays.
     */
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * ProductionDay findFirstOrThrow
   */
  export type ProductionDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDay to fetch.
     */
    where?: ProductionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDays to fetch.
     */
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionDays.
     */
    cursor?: ProductionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionDays.
     */
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * ProductionDay findMany
   */
  export type ProductionDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * Filter, which ProductionDays to fetch.
     */
    where?: ProductionDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionDays to fetch.
     */
    orderBy?: ProductionDayOrderByWithRelationInput | ProductionDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionDays.
     */
    cursor?: ProductionDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionDays.
     */
    skip?: number
    distinct?: ProductionDayScalarFieldEnum | ProductionDayScalarFieldEnum[]
  }

  /**
   * ProductionDay create
   */
  export type ProductionDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionDay.
     */
    data: XOR<ProductionDayCreateInput, ProductionDayUncheckedCreateInput>
  }

  /**
   * ProductionDay createMany
   */
  export type ProductionDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionDays.
     */
    data: ProductionDayCreateManyInput | ProductionDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionDay createManyAndReturn
   */
  export type ProductionDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductionDays.
     */
    data: ProductionDayCreateManyInput | ProductionDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionDay update
   */
  export type ProductionDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionDay.
     */
    data: XOR<ProductionDayUpdateInput, ProductionDayUncheckedUpdateInput>
    /**
     * Choose, which ProductionDay to update.
     */
    where: ProductionDayWhereUniqueInput
  }

  /**
   * ProductionDay updateMany
   */
  export type ProductionDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionDays.
     */
    data: XOR<ProductionDayUpdateManyMutationInput, ProductionDayUncheckedUpdateManyInput>
    /**
     * Filter which ProductionDays to update
     */
    where?: ProductionDayWhereInput
  }

  /**
   * ProductionDay upsert
   */
  export type ProductionDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionDay to update in case it exists.
     */
    where: ProductionDayWhereUniqueInput
    /**
     * In case the ProductionDay found by the `where` argument doesn't exist, create a new ProductionDay with this data.
     */
    create: XOR<ProductionDayCreateInput, ProductionDayUncheckedCreateInput>
    /**
     * In case the ProductionDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionDayUpdateInput, ProductionDayUncheckedUpdateInput>
  }

  /**
   * ProductionDay delete
   */
  export type ProductionDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
    /**
     * Filter which ProductionDay to delete.
     */
    where: ProductionDayWhereUniqueInput
  }

  /**
   * ProductionDay deleteMany
   */
  export type ProductionDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionDays to delete
     */
    where?: ProductionDayWhereInput
  }

  /**
   * ProductionDay.closer
   */
  export type ProductionDay$closerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductionDay.creator
   */
  export type ProductionDay$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductionDay.reopener
   */
  export type ProductionDay$reopenerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProductionDay without action
   */
  export type ProductionDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionDay
     */
    select?: ProductionDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionDayInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    stockMovementId: number | null
    itemId: number | null
    qtyIn: Decimal | null
    qtyOut: Decimal | null
    unitCost: Decimal | null
    refId: number | null
    purchaseId: number | null
    createdBy: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    stockMovementId: bigint | null
    itemId: bigint | null
    qtyIn: Decimal | null
    qtyOut: Decimal | null
    unitCost: Decimal | null
    refId: bigint | null
    purchaseId: bigint | null
    createdBy: bigint | null
  }

  export type StockMovementMinAggregateOutputType = {
    stockMovementId: bigint | null
    movementDate: Date | null
    movementType: $Enums.MovementType | null
    itemId: bigint | null
    qtyIn: Decimal | null
    qtyOut: Decimal | null
    unitCost: Decimal | null
    refTable: string | null
    refId: bigint | null
    purchaseId: bigint | null
    notes: string | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    stockMovementId: bigint | null
    movementDate: Date | null
    movementType: $Enums.MovementType | null
    itemId: bigint | null
    qtyIn: Decimal | null
    qtyOut: Decimal | null
    unitCost: Decimal | null
    refTable: string | null
    refId: bigint | null
    purchaseId: bigint | null
    notes: string | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    stockMovementId: number
    movementDate: number
    movementType: number
    itemId: number
    qtyIn: number
    qtyOut: number
    unitCost: number
    refTable: number
    refId: number
    purchaseId: number
    notes: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    stockMovementId?: true
    itemId?: true
    qtyIn?: true
    qtyOut?: true
    unitCost?: true
    refId?: true
    purchaseId?: true
    createdBy?: true
  }

  export type StockMovementSumAggregateInputType = {
    stockMovementId?: true
    itemId?: true
    qtyIn?: true
    qtyOut?: true
    unitCost?: true
    refId?: true
    purchaseId?: true
    createdBy?: true
  }

  export type StockMovementMinAggregateInputType = {
    stockMovementId?: true
    movementDate?: true
    movementType?: true
    itemId?: true
    qtyIn?: true
    qtyOut?: true
    unitCost?: true
    refTable?: true
    refId?: true
    purchaseId?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    stockMovementId?: true
    movementDate?: true
    movementType?: true
    itemId?: true
    qtyIn?: true
    qtyOut?: true
    unitCost?: true
    refTable?: true
    refId?: true
    purchaseId?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    stockMovementId?: true
    movementDate?: true
    movementType?: true
    itemId?: true
    qtyIn?: true
    qtyOut?: true
    unitCost?: true
    refTable?: true
    refId?: true
    purchaseId?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    stockMovementId: bigint
    movementDate: Date
    movementType: $Enums.MovementType
    itemId: bigint
    qtyIn: Decimal
    qtyOut: Decimal
    unitCost: Decimal
    refTable: string | null
    refId: bigint | null
    purchaseId: bigint | null
    notes: string | null
    createdBy: bigint | null
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stockMovementId?: boolean
    movementDate?: boolean
    movementType?: boolean
    itemId?: boolean
    qtyIn?: boolean
    qtyOut?: boolean
    unitCost?: boolean
    refTable?: boolean
    refId?: boolean
    purchaseId?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | StockMovement$creatorArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockMovement$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stockMovementId?: boolean
    movementDate?: boolean
    movementType?: boolean
    itemId?: boolean
    qtyIn?: boolean
    qtyOut?: boolean
    unitCost?: boolean
    refTable?: boolean
    refId?: boolean
    purchaseId?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | StockMovement$creatorArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockMovement$purchaseOrderArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    stockMovementId?: boolean
    movementDate?: boolean
    movementType?: boolean
    itemId?: boolean
    qtyIn?: boolean
    qtyOut?: boolean
    unitCost?: boolean
    refTable?: boolean
    refId?: boolean
    purchaseId?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | StockMovement$creatorArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockMovement$purchaseOrderArgs<ExtArgs>
  }
  export type StockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | StockMovement$creatorArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | StockMovement$purchaseOrderArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      item: Prisma.$ItemPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      stockMovementId: bigint
      movementDate: Date
      movementType: $Enums.MovementType
      itemId: bigint
      qtyIn: Prisma.Decimal
      qtyOut: Prisma.Decimal
      unitCost: Prisma.Decimal
      refTable: string | null
      refId: bigint | null
      purchaseId: bigint | null
      notes: string | null
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `stockMovementId`
     * const stockMovementWithStockMovementIdOnly = await prisma.stockMovement.findMany({ select: { stockMovementId: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMovements and returns the data saved in the database.
     * @param {StockMovementCreateManyAndReturnArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMovements and only return the `stockMovementId`
     * const stockMovementWithStockMovementIdOnly = await prisma.stockMovement.createManyAndReturn({ 
     *   select: { stockMovementId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends StockMovement$creatorArgs<ExtArgs> = {}>(args?: Subset<T, StockMovement$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchaseOrder<T extends StockMovement$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, StockMovement$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */ 
  interface StockMovementFieldRefs {
    readonly stockMovementId: FieldRef<"StockMovement", 'BigInt'>
    readonly movementDate: FieldRef<"StockMovement", 'DateTime'>
    readonly movementType: FieldRef<"StockMovement", 'MovementType'>
    readonly itemId: FieldRef<"StockMovement", 'BigInt'>
    readonly qtyIn: FieldRef<"StockMovement", 'Decimal'>
    readonly qtyOut: FieldRef<"StockMovement", 'Decimal'>
    readonly unitCost: FieldRef<"StockMovement", 'Decimal'>
    readonly refTable: FieldRef<"StockMovement", 'String'>
    readonly refId: FieldRef<"StockMovement", 'BigInt'>
    readonly purchaseId: FieldRef<"StockMovement", 'BigInt'>
    readonly notes: FieldRef<"StockMovement", 'String'>
    readonly createdBy: FieldRef<"StockMovement", 'BigInt'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMovement createManyAndReturn
   */
  export type StockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement.creator
   */
  export type StockMovement$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StockMovement.purchaseOrder
   */
  export type StockMovement$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model StockBalance
   */

  export type AggregateStockBalance = {
    _count: StockBalanceCountAggregateOutputType | null
    _avg: StockBalanceAvgAggregateOutputType | null
    _sum: StockBalanceSumAggregateOutputType | null
    _min: StockBalanceMinAggregateOutputType | null
    _max: StockBalanceMaxAggregateOutputType | null
  }

  export type StockBalanceAvgAggregateOutputType = {
    itemId: number | null
    qtyOnHand: Decimal | null
  }

  export type StockBalanceSumAggregateOutputType = {
    itemId: bigint | null
    qtyOnHand: Decimal | null
  }

  export type StockBalanceMinAggregateOutputType = {
    itemId: bigint | null
    qtyOnHand: Decimal | null
    updatedAt: Date | null
  }

  export type StockBalanceMaxAggregateOutputType = {
    itemId: bigint | null
    qtyOnHand: Decimal | null
    updatedAt: Date | null
  }

  export type StockBalanceCountAggregateOutputType = {
    itemId: number
    qtyOnHand: number
    updatedAt: number
    _all: number
  }


  export type StockBalanceAvgAggregateInputType = {
    itemId?: true
    qtyOnHand?: true
  }

  export type StockBalanceSumAggregateInputType = {
    itemId?: true
    qtyOnHand?: true
  }

  export type StockBalanceMinAggregateInputType = {
    itemId?: true
    qtyOnHand?: true
    updatedAt?: true
  }

  export type StockBalanceMaxAggregateInputType = {
    itemId?: true
    qtyOnHand?: true
    updatedAt?: true
  }

  export type StockBalanceCountAggregateInputType = {
    itemId?: true
    qtyOnHand?: true
    updatedAt?: true
    _all?: true
  }

  export type StockBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockBalance to aggregate.
     */
    where?: StockBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBalances to fetch.
     */
    orderBy?: StockBalanceOrderByWithRelationInput | StockBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockBalances
    **/
    _count?: true | StockBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockBalanceMaxAggregateInputType
  }

  export type GetStockBalanceAggregateType<T extends StockBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStockBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockBalance[P]>
      : GetScalarType<T[P], AggregateStockBalance[P]>
  }




  export type StockBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockBalanceWhereInput
    orderBy?: StockBalanceOrderByWithAggregationInput | StockBalanceOrderByWithAggregationInput[]
    by: StockBalanceScalarFieldEnum[] | StockBalanceScalarFieldEnum
    having?: StockBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockBalanceCountAggregateInputType | true
    _avg?: StockBalanceAvgAggregateInputType
    _sum?: StockBalanceSumAggregateInputType
    _min?: StockBalanceMinAggregateInputType
    _max?: StockBalanceMaxAggregateInputType
  }

  export type StockBalanceGroupByOutputType = {
    itemId: bigint
    qtyOnHand: Decimal
    updatedAt: Date
    _count: StockBalanceCountAggregateOutputType | null
    _avg: StockBalanceAvgAggregateOutputType | null
    _sum: StockBalanceSumAggregateOutputType | null
    _min: StockBalanceMinAggregateOutputType | null
    _max: StockBalanceMaxAggregateOutputType | null
  }

  type GetStockBalanceGroupByPayload<T extends StockBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], StockBalanceGroupByOutputType[P]>
        }
      >
    >


  export type StockBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    qtyOnHand?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockBalance"]>

  export type StockBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    qtyOnHand?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockBalance"]>

  export type StockBalanceSelectScalar = {
    itemId?: boolean
    qtyOnHand?: boolean
    updatedAt?: boolean
  }

  export type StockBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type StockBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $StockBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockBalance"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemId: bigint
      qtyOnHand: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["stockBalance"]>
    composites: {}
  }

  type StockBalanceGetPayload<S extends boolean | null | undefined | StockBalanceDefaultArgs> = $Result.GetResult<Prisma.$StockBalancePayload, S>

  type StockBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockBalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockBalanceCountAggregateInputType | true
    }

  export interface StockBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockBalance'], meta: { name: 'StockBalance' } }
    /**
     * Find zero or one StockBalance that matches the filter.
     * @param {StockBalanceFindUniqueArgs} args - Arguments to find a StockBalance
     * @example
     * // Get one StockBalance
     * const stockBalance = await prisma.stockBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockBalanceFindUniqueArgs>(args: SelectSubset<T, StockBalanceFindUniqueArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockBalance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockBalanceFindUniqueOrThrowArgs} args - Arguments to find a StockBalance
     * @example
     * // Get one StockBalance
     * const stockBalance = await prisma.stockBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StockBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceFindFirstArgs} args - Arguments to find a StockBalance
     * @example
     * // Get one StockBalance
     * const stockBalance = await prisma.stockBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockBalanceFindFirstArgs>(args?: SelectSubset<T, StockBalanceFindFirstArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceFindFirstOrThrowArgs} args - Arguments to find a StockBalance
     * @example
     * // Get one StockBalance
     * const stockBalance = await prisma.stockBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StockBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockBalances
     * const stockBalances = await prisma.stockBalance.findMany()
     * 
     * // Get first 10 StockBalances
     * const stockBalances = await prisma.stockBalance.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const stockBalanceWithItemIdOnly = await prisma.stockBalance.findMany({ select: { itemId: true } })
     * 
     */
    findMany<T extends StockBalanceFindManyArgs>(args?: SelectSubset<T, StockBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockBalance.
     * @param {StockBalanceCreateArgs} args - Arguments to create a StockBalance.
     * @example
     * // Create one StockBalance
     * const StockBalance = await prisma.stockBalance.create({
     *   data: {
     *     // ... data to create a StockBalance
     *   }
     * })
     * 
     */
    create<T extends StockBalanceCreateArgs>(args: SelectSubset<T, StockBalanceCreateArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockBalances.
     * @param {StockBalanceCreateManyArgs} args - Arguments to create many StockBalances.
     * @example
     * // Create many StockBalances
     * const stockBalance = await prisma.stockBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockBalanceCreateManyArgs>(args?: SelectSubset<T, StockBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockBalances and returns the data saved in the database.
     * @param {StockBalanceCreateManyAndReturnArgs} args - Arguments to create many StockBalances.
     * @example
     * // Create many StockBalances
     * const stockBalance = await prisma.stockBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockBalances and only return the `itemId`
     * const stockBalanceWithItemIdOnly = await prisma.stockBalance.createManyAndReturn({ 
     *   select: { itemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, StockBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockBalance.
     * @param {StockBalanceDeleteArgs} args - Arguments to delete one StockBalance.
     * @example
     * // Delete one StockBalance
     * const StockBalance = await prisma.stockBalance.delete({
     *   where: {
     *     // ... filter to delete one StockBalance
     *   }
     * })
     * 
     */
    delete<T extends StockBalanceDeleteArgs>(args: SelectSubset<T, StockBalanceDeleteArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockBalance.
     * @param {StockBalanceUpdateArgs} args - Arguments to update one StockBalance.
     * @example
     * // Update one StockBalance
     * const stockBalance = await prisma.stockBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockBalanceUpdateArgs>(args: SelectSubset<T, StockBalanceUpdateArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockBalances.
     * @param {StockBalanceDeleteManyArgs} args - Arguments to filter StockBalances to delete.
     * @example
     * // Delete a few StockBalances
     * const { count } = await prisma.stockBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockBalanceDeleteManyArgs>(args?: SelectSubset<T, StockBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockBalances
     * const stockBalance = await prisma.stockBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockBalanceUpdateManyArgs>(args: SelectSubset<T, StockBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockBalance.
     * @param {StockBalanceUpsertArgs} args - Arguments to update or create a StockBalance.
     * @example
     * // Update or create a StockBalance
     * const stockBalance = await prisma.stockBalance.upsert({
     *   create: {
     *     // ... data to create a StockBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockBalance we want to update
     *   }
     * })
     */
    upsert<T extends StockBalanceUpsertArgs>(args: SelectSubset<T, StockBalanceUpsertArgs<ExtArgs>>): Prisma__StockBalanceClient<$Result.GetResult<Prisma.$StockBalancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceCountArgs} args - Arguments to filter StockBalances to count.
     * @example
     * // Count the number of StockBalances
     * const count = await prisma.stockBalance.count({
     *   where: {
     *     // ... the filter for the StockBalances we want to count
     *   }
     * })
    **/
    count<T extends StockBalanceCountArgs>(
      args?: Subset<T, StockBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockBalanceAggregateArgs>(args: Subset<T, StockBalanceAggregateArgs>): Prisma.PrismaPromise<GetStockBalanceAggregateType<T>>

    /**
     * Group by StockBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockBalanceGroupByArgs['orderBy'] }
        : { orderBy?: StockBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockBalance model
   */
  readonly fields: StockBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockBalance model
   */ 
  interface StockBalanceFieldRefs {
    readonly itemId: FieldRef<"StockBalance", 'BigInt'>
    readonly qtyOnHand: FieldRef<"StockBalance", 'Decimal'>
    readonly updatedAt: FieldRef<"StockBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockBalance findUnique
   */
  export type StockBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * Filter, which StockBalance to fetch.
     */
    where: StockBalanceWhereUniqueInput
  }

  /**
   * StockBalance findUniqueOrThrow
   */
  export type StockBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * Filter, which StockBalance to fetch.
     */
    where: StockBalanceWhereUniqueInput
  }

  /**
   * StockBalance findFirst
   */
  export type StockBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * Filter, which StockBalance to fetch.
     */
    where?: StockBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBalances to fetch.
     */
    orderBy?: StockBalanceOrderByWithRelationInput | StockBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockBalances.
     */
    cursor?: StockBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockBalances.
     */
    distinct?: StockBalanceScalarFieldEnum | StockBalanceScalarFieldEnum[]
  }

  /**
   * StockBalance findFirstOrThrow
   */
  export type StockBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * Filter, which StockBalance to fetch.
     */
    where?: StockBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBalances to fetch.
     */
    orderBy?: StockBalanceOrderByWithRelationInput | StockBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockBalances.
     */
    cursor?: StockBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockBalances.
     */
    distinct?: StockBalanceScalarFieldEnum | StockBalanceScalarFieldEnum[]
  }

  /**
   * StockBalance findMany
   */
  export type StockBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * Filter, which StockBalances to fetch.
     */
    where?: StockBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBalances to fetch.
     */
    orderBy?: StockBalanceOrderByWithRelationInput | StockBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockBalances.
     */
    cursor?: StockBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBalances.
     */
    skip?: number
    distinct?: StockBalanceScalarFieldEnum | StockBalanceScalarFieldEnum[]
  }

  /**
   * StockBalance create
   */
  export type StockBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StockBalance.
     */
    data: XOR<StockBalanceCreateInput, StockBalanceUncheckedCreateInput>
  }

  /**
   * StockBalance createMany
   */
  export type StockBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockBalances.
     */
    data: StockBalanceCreateManyInput | StockBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockBalance createManyAndReturn
   */
  export type StockBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockBalances.
     */
    data: StockBalanceCreateManyInput | StockBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockBalance update
   */
  export type StockBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StockBalance.
     */
    data: XOR<StockBalanceUpdateInput, StockBalanceUncheckedUpdateInput>
    /**
     * Choose, which StockBalance to update.
     */
    where: StockBalanceWhereUniqueInput
  }

  /**
   * StockBalance updateMany
   */
  export type StockBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockBalances.
     */
    data: XOR<StockBalanceUpdateManyMutationInput, StockBalanceUncheckedUpdateManyInput>
    /**
     * Filter which StockBalances to update
     */
    where?: StockBalanceWhereInput
  }

  /**
   * StockBalance upsert
   */
  export type StockBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StockBalance to update in case it exists.
     */
    where: StockBalanceWhereUniqueInput
    /**
     * In case the StockBalance found by the `where` argument doesn't exist, create a new StockBalance with this data.
     */
    create: XOR<StockBalanceCreateInput, StockBalanceUncheckedCreateInput>
    /**
     * In case the StockBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockBalanceUpdateInput, StockBalanceUncheckedUpdateInput>
  }

  /**
   * StockBalance delete
   */
  export type StockBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
    /**
     * Filter which StockBalance to delete.
     */
    where: StockBalanceWhereUniqueInput
  }

  /**
   * StockBalance deleteMany
   */
  export type StockBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockBalances to delete
     */
    where?: StockBalanceWhereInput
  }

  /**
   * StockBalance without action
   */
  export type StockBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBalance
     */
    select?: StockBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBalanceInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    invoiceId: number | null
    customerId: number | null
    supplierId: number | null
    salesOrderId: number | null
    purchaseId: number | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    vendorInvoiceTotal: Decimal | null
    mismatchAmount: Decimal | null
    matchCheckedBy: number | null
    createdBy: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    invoiceId: bigint | null
    customerId: bigint | null
    supplierId: bigint | null
    salesOrderId: bigint | null
    purchaseId: bigint | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    vendorInvoiceTotal: Decimal | null
    mismatchAmount: Decimal | null
    matchCheckedBy: bigint | null
    createdBy: bigint | null
  }

  export type InvoiceMinAggregateOutputType = {
    invoiceId: bigint | null
    invoiceNo: string | null
    invoiceType: $Enums.InvoiceType | null
    invoiceDate: Date | null
    dueDate: Date | null
    customerId: bigint | null
    supplierId: bigint | null
    salesOrderId: bigint | null
    purchaseId: bigint | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    status: $Enums.DocStatus | null
    printTemplate: string | null
    vendorInvoiceNo: string | null
    vendorInvoiceDate: Date | null
    vendorInvoiceTotal: Decimal | null
    matchStatus: $Enums.MatchStatus | null
    mismatchAmount: Decimal | null
    matchCheckedBy: bigint | null
    matchCheckedAt: Date | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    invoiceId: bigint | null
    invoiceNo: string | null
    invoiceType: $Enums.InvoiceType | null
    invoiceDate: Date | null
    dueDate: Date | null
    customerId: bigint | null
    supplierId: bigint | null
    salesOrderId: bigint | null
    purchaseId: bigint | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    status: $Enums.DocStatus | null
    printTemplate: string | null
    vendorInvoiceNo: string | null
    vendorInvoiceDate: Date | null
    vendorInvoiceTotal: Decimal | null
    matchStatus: $Enums.MatchStatus | null
    mismatchAmount: Decimal | null
    matchCheckedBy: bigint | null
    matchCheckedAt: Date | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    invoiceId: number
    invoiceNo: number
    invoiceType: number
    invoiceDate: number
    dueDate: number
    customerId: number
    supplierId: number
    salesOrderId: number
    purchaseId: number
    subtotal: number
    discount: number
    tax: number
    total: number
    status: number
    printTemplate: number
    vendorInvoiceNo: number
    vendorInvoiceDate: number
    vendorInvoiceTotal: number
    matchStatus: number
    mismatchAmount: number
    matchCheckedBy: number
    matchCheckedAt: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    invoiceId?: true
    customerId?: true
    supplierId?: true
    salesOrderId?: true
    purchaseId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    vendorInvoiceTotal?: true
    mismatchAmount?: true
    matchCheckedBy?: true
    createdBy?: true
  }

  export type InvoiceSumAggregateInputType = {
    invoiceId?: true
    customerId?: true
    supplierId?: true
    salesOrderId?: true
    purchaseId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    vendorInvoiceTotal?: true
    mismatchAmount?: true
    matchCheckedBy?: true
    createdBy?: true
  }

  export type InvoiceMinAggregateInputType = {
    invoiceId?: true
    invoiceNo?: true
    invoiceType?: true
    invoiceDate?: true
    dueDate?: true
    customerId?: true
    supplierId?: true
    salesOrderId?: true
    purchaseId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    status?: true
    printTemplate?: true
    vendorInvoiceNo?: true
    vendorInvoiceDate?: true
    vendorInvoiceTotal?: true
    matchStatus?: true
    mismatchAmount?: true
    matchCheckedBy?: true
    matchCheckedAt?: true
    createdBy?: true
    createdAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    invoiceId?: true
    invoiceNo?: true
    invoiceType?: true
    invoiceDate?: true
    dueDate?: true
    customerId?: true
    supplierId?: true
    salesOrderId?: true
    purchaseId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    status?: true
    printTemplate?: true
    vendorInvoiceNo?: true
    vendorInvoiceDate?: true
    vendorInvoiceTotal?: true
    matchStatus?: true
    mismatchAmount?: true
    matchCheckedBy?: true
    matchCheckedAt?: true
    createdBy?: true
    createdAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    invoiceId?: true
    invoiceNo?: true
    invoiceType?: true
    invoiceDate?: true
    dueDate?: true
    customerId?: true
    supplierId?: true
    salesOrderId?: true
    purchaseId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    status?: true
    printTemplate?: true
    vendorInvoiceNo?: true
    vendorInvoiceDate?: true
    vendorInvoiceTotal?: true
    matchStatus?: true
    mismatchAmount?: true
    matchCheckedBy?: true
    matchCheckedAt?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    invoiceId: bigint
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate: Date
    dueDate: Date | null
    customerId: bigint | null
    supplierId: bigint | null
    salesOrderId: bigint | null
    purchaseId: bigint | null
    subtotal: Decimal
    discount: Decimal
    tax: Decimal
    total: Decimal
    status: $Enums.DocStatus
    printTemplate: string
    vendorInvoiceNo: string | null
    vendorInvoiceDate: Date | null
    vendorInvoiceTotal: Decimal | null
    matchStatus: $Enums.MatchStatus
    mismatchAmount: Decimal
    matchCheckedBy: bigint | null
    matchCheckedAt: Date | null
    createdBy: bigint | null
    createdAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceId?: boolean
    invoiceNo?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    customerId?: boolean
    supplierId?: boolean
    salesOrderId?: boolean
    purchaseId?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    printTemplate?: boolean
    vendorInvoiceNo?: boolean
    vendorInvoiceDate?: boolean
    vendorInvoiceTotal?: boolean
    matchStatus?: boolean
    mismatchAmount?: boolean
    matchCheckedBy?: boolean
    matchCheckedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    creator?: boolean | Invoice$creatorArgs<ExtArgs>
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    matchChecker?: boolean | Invoice$matchCheckerArgs<ExtArgs>
    purchaseOrder?: boolean | Invoice$purchaseOrderArgs<ExtArgs>
    salesOrder?: boolean | Invoice$salesOrderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceId?: boolean
    invoiceNo?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    customerId?: boolean
    supplierId?: boolean
    salesOrderId?: boolean
    purchaseId?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    printTemplate?: boolean
    vendorInvoiceNo?: boolean
    vendorInvoiceDate?: boolean
    vendorInvoiceTotal?: boolean
    matchStatus?: boolean
    mismatchAmount?: boolean
    matchCheckedBy?: boolean
    matchCheckedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | Invoice$creatorArgs<ExtArgs>
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    matchChecker?: boolean | Invoice$matchCheckerArgs<ExtArgs>
    purchaseOrder?: boolean | Invoice$purchaseOrderArgs<ExtArgs>
    salesOrder?: boolean | Invoice$salesOrderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    invoiceId?: boolean
    invoiceNo?: boolean
    invoiceType?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    customerId?: boolean
    supplierId?: boolean
    salesOrderId?: boolean
    purchaseId?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    status?: boolean
    printTemplate?: boolean
    vendorInvoiceNo?: boolean
    vendorInvoiceDate?: boolean
    vendorInvoiceTotal?: boolean
    matchStatus?: boolean
    mismatchAmount?: boolean
    matchCheckedBy?: boolean
    matchCheckedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    creator?: boolean | Invoice$creatorArgs<ExtArgs>
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    matchChecker?: boolean | Invoice$matchCheckerArgs<ExtArgs>
    purchaseOrder?: boolean | Invoice$purchaseOrderArgs<ExtArgs>
    salesOrder?: boolean | Invoice$salesOrderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Invoice$creatorArgs<ExtArgs>
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    matchChecker?: boolean | Invoice$matchCheckerArgs<ExtArgs>
    purchaseOrder?: boolean | Invoice$purchaseOrderArgs<ExtArgs>
    salesOrder?: boolean | Invoice$salesOrderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      matchChecker: Prisma.$UserPayload<ExtArgs> | null
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      salesOrder: Prisma.$SalesOrderPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      invoiceId: bigint
      invoiceNo: string
      invoiceType: $Enums.InvoiceType
      invoiceDate: Date
      dueDate: Date | null
      customerId: bigint | null
      supplierId: bigint | null
      salesOrderId: bigint | null
      purchaseId: bigint | null
      subtotal: Prisma.Decimal
      discount: Prisma.Decimal
      tax: Prisma.Decimal
      total: Prisma.Decimal
      status: $Enums.DocStatus
      printTemplate: string
      vendorInvoiceNo: string | null
      vendorInvoiceDate: Date | null
      vendorInvoiceTotal: Prisma.Decimal | null
      matchStatus: $Enums.MatchStatus
      mismatchAmount: Prisma.Decimal
      matchCheckedBy: bigint | null
      matchCheckedAt: Date | null
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `invoiceId`
     * const invoiceWithInvoiceIdOnly = await prisma.invoice.findMany({ select: { invoiceId: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `invoiceId`
     * const invoiceWithInvoiceIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { invoiceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lines<T extends Invoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends Invoice$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends Invoice$customerArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    matchChecker<T extends Invoice$matchCheckerArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$matchCheckerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    purchaseOrder<T extends Invoice$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    salesOrder<T extends Invoice$salesOrderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$salesOrderArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    supplier<T extends Invoice$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly invoiceId: FieldRef<"Invoice", 'BigInt'>
    readonly invoiceNo: FieldRef<"Invoice", 'String'>
    readonly invoiceType: FieldRef<"Invoice", 'InvoiceType'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly customerId: FieldRef<"Invoice", 'BigInt'>
    readonly supplierId: FieldRef<"Invoice", 'BigInt'>
    readonly salesOrderId: FieldRef<"Invoice", 'BigInt'>
    readonly purchaseId: FieldRef<"Invoice", 'BigInt'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly discount: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'DocStatus'>
    readonly printTemplate: FieldRef<"Invoice", 'String'>
    readonly vendorInvoiceNo: FieldRef<"Invoice", 'String'>
    readonly vendorInvoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly vendorInvoiceTotal: FieldRef<"Invoice", 'Decimal'>
    readonly matchStatus: FieldRef<"Invoice", 'MatchStatus'>
    readonly mismatchAmount: FieldRef<"Invoice", 'Decimal'>
    readonly matchCheckedBy: FieldRef<"Invoice", 'BigInt'>
    readonly matchCheckedAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdBy: FieldRef<"Invoice", 'BigInt'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.lines
   */
  export type Invoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.creator
   */
  export type Invoice$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invoice.customer
   */
  export type Invoice$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Invoice.matchChecker
   */
  export type Invoice$matchCheckerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Invoice.purchaseOrder
   */
  export type Invoice$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * Invoice.salesOrder
   */
  export type Invoice$salesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
  }

  /**
   * Invoice.supplier
   */
  export type Invoice$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    invoiceLineId: number | null
    invoiceId: number | null
    itemId: number | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    invoiceLineId: bigint | null
    invoiceId: bigint | null
    itemId: bigint | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    invoiceLineId: bigint | null
    invoiceId: bigint | null
    itemId: bigint | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    invoiceLineId: bigint | null
    invoiceId: bigint | null
    itemId: bigint | null
    description: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    invoiceLineId: number
    invoiceId: number
    itemId: number
    description: number
    qty: number
    unitPrice: number
    lineTotal: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    invoiceLineId?: true
    invoiceId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    invoiceLineId?: true
    invoiceId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    invoiceLineId?: true
    invoiceId?: true
    itemId?: true
    description?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    invoiceLineId?: true
    invoiceId?: true
    itemId?: true
    description?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    invoiceLineId?: true
    invoiceId?: true
    itemId?: true
    description?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    invoiceLineId: bigint
    invoiceId: bigint
    itemId: bigint | null
    description: string | null
    qty: Decimal
    unitPrice: Decimal
    lineTotal: Decimal
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceLineId?: boolean
    invoiceId?: boolean
    itemId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    item?: boolean | InvoiceLine$itemArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceLineId?: boolean
    invoiceId?: boolean
    itemId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    item?: boolean | InvoiceLine$itemArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    invoiceLineId?: boolean
    invoiceId?: boolean
    itemId?: boolean
    description?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
  }

  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    item?: boolean | InvoiceLine$itemArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    item?: boolean | InvoiceLine$itemArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      invoiceLineId: bigint
      invoiceId: bigint
      itemId: bigint | null
      description: string | null
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `invoiceLineId`
     * const invoiceLineWithInvoiceLineIdOnly = await prisma.invoiceLine.findMany({ select: { invoiceLineId: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `invoiceLineId`
     * const invoiceLineWithInvoiceLineIdOnly = await prisma.invoiceLine.createManyAndReturn({ 
     *   select: { invoiceLineId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends InvoiceLine$itemArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceLine$itemArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */ 
  interface InvoiceLineFieldRefs {
    readonly invoiceLineId: FieldRef<"InvoiceLine", 'BigInt'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'BigInt'>
    readonly itemId: FieldRef<"InvoiceLine", 'BigInt'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly qty: FieldRef<"InvoiceLine", 'Decimal'>
    readonly unitPrice: FieldRef<"InvoiceLine", 'Decimal'>
    readonly lineTotal: FieldRef<"InvoiceLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine.item
   */
  export type InvoiceLine$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    paymentId: number | null
    invoiceId: number | null
    amount: Decimal | null
    receivedBy: number | null
  }

  export type PaymentSumAggregateOutputType = {
    paymentId: bigint | null
    invoiceId: bigint | null
    amount: Decimal | null
    receivedBy: bigint | null
  }

  export type PaymentMinAggregateOutputType = {
    paymentId: bigint | null
    paymentNo: string | null
    invoiceId: bigint | null
    paymentDate: Date | null
    amount: Decimal | null
    method: $Enums.PayMethod | null
    referenceNo: string | null
    notes: string | null
    receivedBy: bigint | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    paymentId: bigint | null
    paymentNo: string | null
    invoiceId: bigint | null
    paymentDate: Date | null
    amount: Decimal | null
    method: $Enums.PayMethod | null
    referenceNo: string | null
    notes: string | null
    receivedBy: bigint | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    paymentId: number
    paymentNo: number
    invoiceId: number
    paymentDate: number
    amount: number
    method: number
    referenceNo: number
    notes: number
    receivedBy: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    paymentId?: true
    invoiceId?: true
    amount?: true
    receivedBy?: true
  }

  export type PaymentSumAggregateInputType = {
    paymentId?: true
    invoiceId?: true
    amount?: true
    receivedBy?: true
  }

  export type PaymentMinAggregateInputType = {
    paymentId?: true
    paymentNo?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    method?: true
    referenceNo?: true
    notes?: true
    receivedBy?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    paymentId?: true
    paymentNo?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    method?: true
    referenceNo?: true
    notes?: true
    receivedBy?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    paymentId?: true
    paymentNo?: true
    invoiceId?: true
    paymentDate?: true
    amount?: true
    method?: true
    referenceNo?: true
    notes?: true
    receivedBy?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    paymentId: bigint
    paymentNo: string
    invoiceId: bigint
    paymentDate: Date
    amount: Decimal
    method: $Enums.PayMethod
    referenceNo: string | null
    notes: string | null
    receivedBy: bigint | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paymentId?: boolean
    paymentNo?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    method?: boolean
    referenceNo?: boolean
    notes?: boolean
    receivedBy?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receiver?: boolean | Payment$receiverArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paymentId?: boolean
    paymentNo?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    method?: boolean
    referenceNo?: boolean
    notes?: boolean
    receivedBy?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receiver?: boolean | Payment$receiverArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    paymentId?: boolean
    paymentNo?: boolean
    invoiceId?: boolean
    paymentDate?: boolean
    amount?: boolean
    method?: boolean
    referenceNo?: boolean
    notes?: boolean
    receivedBy?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receiver?: boolean | Payment$receiverArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receiver?: boolean | Payment$receiverArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      paymentId: bigint
      paymentNo: string
      invoiceId: bigint
      paymentDate: Date
      amount: Prisma.Decimal
      method: $Enums.PayMethod
      referenceNo: string | null
      notes: string | null
      receivedBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `paymentId`
     * const paymentWithPaymentIdOnly = await prisma.payment.findMany({ select: { paymentId: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `paymentId`
     * const paymentWithPaymentIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { paymentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends Payment$receiverArgs<ExtArgs> = {}>(args?: Subset<T, Payment$receiverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly paymentId: FieldRef<"Payment", 'BigInt'>
    readonly paymentNo: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'BigInt'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'PayMethod'>
    readonly referenceNo: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly receivedBy: FieldRef<"Payment", 'BigInt'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.receiver
   */
  export type Payment$receiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    expenseId: number | null
    amount: Decimal | null
    supplierId: number | null
    createdBy: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    expenseId: bigint | null
    amount: Decimal | null
    supplierId: bigint | null
    createdBy: bigint | null
  }

  export type ExpenseMinAggregateOutputType = {
    expenseId: bigint | null
    expenseNo: string | null
    expenseDate: Date | null
    category: string | null
    description: string | null
    amount: Decimal | null
    method: $Enums.PayMethod | null
    paidTo: string | null
    supplierId: bigint | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    expenseId: bigint | null
    expenseNo: string | null
    expenseDate: Date | null
    category: string | null
    description: string | null
    amount: Decimal | null
    method: $Enums.PayMethod | null
    paidTo: string | null
    supplierId: bigint | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    expenseId: number
    expenseNo: number
    expenseDate: number
    category: number
    description: number
    amount: number
    method: number
    paidTo: number
    supplierId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    expenseId?: true
    amount?: true
    supplierId?: true
    createdBy?: true
  }

  export type ExpenseSumAggregateInputType = {
    expenseId?: true
    amount?: true
    supplierId?: true
    createdBy?: true
  }

  export type ExpenseMinAggregateInputType = {
    expenseId?: true
    expenseNo?: true
    expenseDate?: true
    category?: true
    description?: true
    amount?: true
    method?: true
    paidTo?: true
    supplierId?: true
    createdBy?: true
    createdAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    expenseId?: true
    expenseNo?: true
    expenseDate?: true
    category?: true
    description?: true
    amount?: true
    method?: true
    paidTo?: true
    supplierId?: true
    createdBy?: true
    createdAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    expenseId?: true
    expenseNo?: true
    expenseDate?: true
    category?: true
    description?: true
    amount?: true
    method?: true
    paidTo?: true
    supplierId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    expenseId: bigint
    expenseNo: string
    expenseDate: Date
    category: string
    description: string | null
    amount: Decimal
    method: $Enums.PayMethod
    paidTo: string | null
    supplierId: bigint | null
    createdBy: bigint | null
    createdAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    expenseId?: boolean
    expenseNo?: boolean
    expenseDate?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    method?: boolean
    paidTo?: boolean
    supplierId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | Expense$creatorArgs<ExtArgs>
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    expenseId?: boolean
    expenseNo?: boolean
    expenseDate?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    method?: boolean
    paidTo?: boolean
    supplierId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | Expense$creatorArgs<ExtArgs>
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    expenseId?: boolean
    expenseNo?: boolean
    expenseDate?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    method?: boolean
    paidTo?: boolean
    supplierId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Expense$creatorArgs<ExtArgs>
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Expense$creatorArgs<ExtArgs>
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      expenseId: bigint
      expenseNo: string
      expenseDate: Date
      category: string
      description: string | null
      amount: Prisma.Decimal
      method: $Enums.PayMethod
      paidTo: string | null
      supplierId: bigint | null
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `expenseId`
     * const expenseWithExpenseIdOnly = await prisma.expense.findMany({ select: { expenseId: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `expenseId`
     * const expenseWithExpenseIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { expenseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Expense$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Expense$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    supplier<T extends Expense$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Expense$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly expenseId: FieldRef<"Expense", 'BigInt'>
    readonly expenseNo: FieldRef<"Expense", 'String'>
    readonly expenseDate: FieldRef<"Expense", 'DateTime'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly method: FieldRef<"Expense", 'PayMethod'>
    readonly paidTo: FieldRef<"Expense", 'String'>
    readonly supplierId: FieldRef<"Expense", 'BigInt'>
    readonly createdBy: FieldRef<"Expense", 'BigInt'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense.creator
   */
  export type Expense$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Expense.supplier
   */
  export type Expense$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model CashTransaction
   */

  export type AggregateCashTransaction = {
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  export type CashTransactionAvgAggregateOutputType = {
    txId: number | null
    refId: number | null
    amountIn: Decimal | null
    amountOut: Decimal | null
    createdBy: number | null
  }

  export type CashTransactionSumAggregateOutputType = {
    txId: bigint | null
    refId: bigint | null
    amountIn: Decimal | null
    amountOut: Decimal | null
    createdBy: bigint | null
  }

  export type CashTransactionMinAggregateOutputType = {
    txId: bigint | null
    txDate: Date | null
    txType: $Enums.TxType | null
    sourceModule: string | null
    refTable: string | null
    refId: bigint | null
    amountIn: Decimal | null
    amountOut: Decimal | null
    method: $Enums.PayMethod | null
    note: string | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type CashTransactionMaxAggregateOutputType = {
    txId: bigint | null
    txDate: Date | null
    txType: $Enums.TxType | null
    sourceModule: string | null
    refTable: string | null
    refId: bigint | null
    amountIn: Decimal | null
    amountOut: Decimal | null
    method: $Enums.PayMethod | null
    note: string | null
    createdBy: bigint | null
    createdAt: Date | null
  }

  export type CashTransactionCountAggregateOutputType = {
    txId: number
    txDate: number
    txType: number
    sourceModule: number
    refTable: number
    refId: number
    amountIn: number
    amountOut: number
    method: number
    note: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type CashTransactionAvgAggregateInputType = {
    txId?: true
    refId?: true
    amountIn?: true
    amountOut?: true
    createdBy?: true
  }

  export type CashTransactionSumAggregateInputType = {
    txId?: true
    refId?: true
    amountIn?: true
    amountOut?: true
    createdBy?: true
  }

  export type CashTransactionMinAggregateInputType = {
    txId?: true
    txDate?: true
    txType?: true
    sourceModule?: true
    refTable?: true
    refId?: true
    amountIn?: true
    amountOut?: true
    method?: true
    note?: true
    createdBy?: true
    createdAt?: true
  }

  export type CashTransactionMaxAggregateInputType = {
    txId?: true
    txDate?: true
    txType?: true
    sourceModule?: true
    refTable?: true
    refId?: true
    amountIn?: true
    amountOut?: true
    method?: true
    note?: true
    createdBy?: true
    createdAt?: true
  }

  export type CashTransactionCountAggregateInputType = {
    txId?: true
    txDate?: true
    txType?: true
    sourceModule?: true
    refTable?: true
    refId?: true
    amountIn?: true
    amountOut?: true
    method?: true
    note?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type CashTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransaction to aggregate.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashTransactions
    **/
    _count?: true | CashTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashTransactionMaxAggregateInputType
  }

  export type GetCashTransactionAggregateType<T extends CashTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashTransaction[P]>
      : GetScalarType<T[P], AggregateCashTransaction[P]>
  }




  export type CashTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithAggregationInput | CashTransactionOrderByWithAggregationInput[]
    by: CashTransactionScalarFieldEnum[] | CashTransactionScalarFieldEnum
    having?: CashTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashTransactionCountAggregateInputType | true
    _avg?: CashTransactionAvgAggregateInputType
    _sum?: CashTransactionSumAggregateInputType
    _min?: CashTransactionMinAggregateInputType
    _max?: CashTransactionMaxAggregateInputType
  }

  export type CashTransactionGroupByOutputType = {
    txId: bigint
    txDate: Date
    txType: $Enums.TxType
    sourceModule: string | null
    refTable: string | null
    refId: bigint | null
    amountIn: Decimal
    amountOut: Decimal
    method: $Enums.PayMethod
    note: string | null
    createdBy: bigint | null
    createdAt: Date
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  type GetCashTransactionGroupByPayload<T extends CashTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CashTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    txId?: boolean
    txDate?: boolean
    txType?: boolean
    sourceModule?: boolean
    refTable?: boolean
    refId?: boolean
    amountIn?: boolean
    amountOut?: boolean
    method?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | CashTransaction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    txId?: boolean
    txDate?: boolean
    txType?: boolean
    sourceModule?: boolean
    refTable?: boolean
    refId?: boolean
    amountIn?: boolean
    amountOut?: boolean
    method?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | CashTransaction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectScalar = {
    txId?: boolean
    txDate?: boolean
    txType?: boolean
    sourceModule?: boolean
    refTable?: boolean
    refId?: boolean
    amountIn?: boolean
    amountOut?: boolean
    method?: boolean
    note?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type CashTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CashTransaction$creatorArgs<ExtArgs>
  }
  export type CashTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | CashTransaction$creatorArgs<ExtArgs>
  }

  export type $CashTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashTransaction"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      txId: bigint
      txDate: Date
      txType: $Enums.TxType
      sourceModule: string | null
      refTable: string | null
      refId: bigint | null
      amountIn: Prisma.Decimal
      amountOut: Prisma.Decimal
      method: $Enums.PayMethod
      note: string | null
      createdBy: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["cashTransaction"]>
    composites: {}
  }

  type CashTransactionGetPayload<S extends boolean | null | undefined | CashTransactionDefaultArgs> = $Result.GetResult<Prisma.$CashTransactionPayload, S>

  type CashTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashTransactionCountAggregateInputType | true
    }

  export interface CashTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashTransaction'], meta: { name: 'CashTransaction' } }
    /**
     * Find zero or one CashTransaction that matches the filter.
     * @param {CashTransactionFindUniqueArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashTransactionFindUniqueArgs>(args: SelectSubset<T, CashTransactionFindUniqueArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashTransactionFindUniqueOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashTransactionFindFirstArgs>(args?: SelectSubset<T, CashTransactionFindFirstArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany()
     * 
     * // Get first 10 CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany({ take: 10 })
     * 
     * // Only select the `txId`
     * const cashTransactionWithTxIdOnly = await prisma.cashTransaction.findMany({ select: { txId: true } })
     * 
     */
    findMany<T extends CashTransactionFindManyArgs>(args?: SelectSubset<T, CashTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashTransaction.
     * @param {CashTransactionCreateArgs} args - Arguments to create a CashTransaction.
     * @example
     * // Create one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.create({
     *   data: {
     *     // ... data to create a CashTransaction
     *   }
     * })
     * 
     */
    create<T extends CashTransactionCreateArgs>(args: SelectSubset<T, CashTransactionCreateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashTransactions.
     * @param {CashTransactionCreateManyArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashTransactionCreateManyArgs>(args?: SelectSubset<T, CashTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashTransactions and returns the data saved in the database.
     * @param {CashTransactionCreateManyAndReturnArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashTransactions and only return the `txId`
     * const cashTransactionWithTxIdOnly = await prisma.cashTransaction.createManyAndReturn({ 
     *   select: { txId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashTransaction.
     * @param {CashTransactionDeleteArgs} args - Arguments to delete one CashTransaction.
     * @example
     * // Delete one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.delete({
     *   where: {
     *     // ... filter to delete one CashTransaction
     *   }
     * })
     * 
     */
    delete<T extends CashTransactionDeleteArgs>(args: SelectSubset<T, CashTransactionDeleteArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashTransaction.
     * @param {CashTransactionUpdateArgs} args - Arguments to update one CashTransaction.
     * @example
     * // Update one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashTransactionUpdateArgs>(args: SelectSubset<T, CashTransactionUpdateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashTransactions.
     * @param {CashTransactionDeleteManyArgs} args - Arguments to filter CashTransactions to delete.
     * @example
     * // Delete a few CashTransactions
     * const { count } = await prisma.cashTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashTransactionDeleteManyArgs>(args?: SelectSubset<T, CashTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashTransactionUpdateManyArgs>(args: SelectSubset<T, CashTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashTransaction.
     * @param {CashTransactionUpsertArgs} args - Arguments to update or create a CashTransaction.
     * @example
     * // Update or create a CashTransaction
     * const cashTransaction = await prisma.cashTransaction.upsert({
     *   create: {
     *     // ... data to create a CashTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CashTransactionUpsertArgs>(args: SelectSubset<T, CashTransactionUpsertArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionCountArgs} args - Arguments to filter CashTransactions to count.
     * @example
     * // Count the number of CashTransactions
     * const count = await prisma.cashTransaction.count({
     *   where: {
     *     // ... the filter for the CashTransactions we want to count
     *   }
     * })
    **/
    count<T extends CashTransactionCountArgs>(
      args?: Subset<T, CashTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashTransactionAggregateArgs>(args: Subset<T, CashTransactionAggregateArgs>): Prisma.PrismaPromise<GetCashTransactionAggregateType<T>>

    /**
     * Group by CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CashTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashTransaction model
   */
  readonly fields: CashTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends CashTransaction$creatorArgs<ExtArgs> = {}>(args?: Subset<T, CashTransaction$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashTransaction model
   */ 
  interface CashTransactionFieldRefs {
    readonly txId: FieldRef<"CashTransaction", 'BigInt'>
    readonly txDate: FieldRef<"CashTransaction", 'DateTime'>
    readonly txType: FieldRef<"CashTransaction", 'TxType'>
    readonly sourceModule: FieldRef<"CashTransaction", 'String'>
    readonly refTable: FieldRef<"CashTransaction", 'String'>
    readonly refId: FieldRef<"CashTransaction", 'BigInt'>
    readonly amountIn: FieldRef<"CashTransaction", 'Decimal'>
    readonly amountOut: FieldRef<"CashTransaction", 'Decimal'>
    readonly method: FieldRef<"CashTransaction", 'PayMethod'>
    readonly note: FieldRef<"CashTransaction", 'String'>
    readonly createdBy: FieldRef<"CashTransaction", 'BigInt'>
    readonly createdAt: FieldRef<"CashTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashTransaction findUnique
   */
  export type CashTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findUniqueOrThrow
   */
  export type CashTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findFirst
   */
  export type CashTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findFirstOrThrow
   */
  export type CashTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findMany
   */
  export type CashTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransactions to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction create
   */
  export type CashTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashTransaction.
     */
    data: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
  }

  /**
   * CashTransaction createMany
   */
  export type CashTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashTransaction createManyAndReturn
   */
  export type CashTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashTransaction update
   */
  export type CashTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashTransaction.
     */
    data: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
    /**
     * Choose, which CashTransaction to update.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction updateMany
   */
  export type CashTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashTransactions.
     */
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CashTransactions to update
     */
    where?: CashTransactionWhereInput
  }

  /**
   * CashTransaction upsert
   */
  export type CashTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashTransaction to update in case it exists.
     */
    where: CashTransactionWhereUniqueInput
    /**
     * In case the CashTransaction found by the `where` argument doesn't exist, create a new CashTransaction with this data.
     */
    create: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
    /**
     * In case the CashTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
  }

  /**
   * CashTransaction delete
   */
  export type CashTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter which CashTransaction to delete.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction deleteMany
   */
  export type CashTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransactions to delete
     */
    where?: CashTransactionWhereInput
  }

  /**
   * CashTransaction.creator
   */
  export type CashTransaction$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CashTransaction without action
   */
  export type CashTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    roleId: 'roleId',
    roleName: 'roleName',
    idPrefix: 'idPrefix',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    userId: 'userId',
    userCode: 'userCode',
    roleId: 'roleId',
    fullName: 'fullName',
    username: 'username',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SalaryRangeScalarFieldEnum: {
    salaryRangeId: 'salaryRangeId',
    rangeName: 'rangeName',
    minSalary: 'minSalary',
    maxSalary: 'maxSalary',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type SalaryRangeScalarFieldEnum = (typeof SalaryRangeScalarFieldEnum)[keyof typeof SalaryRangeScalarFieldEnum]


  export const EmployeeProfileScalarFieldEnum: {
    userId: 'userId',
    nic: 'nic',
    address: 'address',
    joinedDate: 'joinedDate',
    designation: 'designation',
    basicSalary: 'basicSalary',
    salaryRangeId: 'salaryRangeId',
    otRate: 'otRate',
    notes: 'notes'
  };

  export type EmployeeProfileScalarFieldEnum = (typeof EmployeeProfileScalarFieldEnum)[keyof typeof EmployeeProfileScalarFieldEnum]


  export const AttendanceDailyScalarFieldEnum: {
    attendanceId: 'attendanceId',
    userId: 'userId',
    workDate: 'workDate',
    timeIn: 'timeIn',
    timeOut: 'timeOut',
    systemHours: 'systemHours',
    systemOtHours: 'systemOtHours',
    manualOtHours: 'manualOtHours',
    remarks: 'remarks',
    recordedBy: 'recordedBy',
    createdAt: 'createdAt'
  };

  export type AttendanceDailyScalarFieldEnum = (typeof AttendanceDailyScalarFieldEnum)[keyof typeof AttendanceDailyScalarFieldEnum]


  export const SalaryPeriodScalarFieldEnum: {
    periodId: 'periodId',
    year: 'year',
    month: 'month',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status'
  };

  export type SalaryPeriodScalarFieldEnum = (typeof SalaryPeriodScalarFieldEnum)[keyof typeof SalaryPeriodScalarFieldEnum]


  export const SalaryRecordScalarFieldEnum: {
    salaryRecordId: 'salaryRecordId',
    periodId: 'periodId',
    userId: 'userId',
    baseSalary: 'baseSalary',
    otHours: 'otHours',
    otAmount: 'otAmount',
    allowances: 'allowances',
    deductions: 'deductions',
    totalPay: 'totalPay',
    status: 'status'
  };

  export type SalaryRecordScalarFieldEnum = (typeof SalaryRecordScalarFieldEnum)[keyof typeof SalaryRecordScalarFieldEnum]


  export const SalaryPaymentScalarFieldEnum: {
    salaryPaymentId: 'salaryPaymentId',
    salaryRecordId: 'salaryRecordId',
    payDate: 'payDate',
    amount: 'amount',
    method: 'method',
    referenceNo: 'referenceNo',
    paidBy: 'paidBy',
    createdAt: 'createdAt'
  };

  export type SalaryPaymentScalarFieldEnum = (typeof SalaryPaymentScalarFieldEnum)[keyof typeof SalaryPaymentScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    unitId: 'unitId',
    unitName: 'unitName',
    symbol: 'symbol'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const ItemCategoryScalarFieldEnum: {
    categoryId: 'categoryId',
    categoryName: 'categoryName'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    itemId: 'itemId',
    itemCode: 'itemCode',
    itemName: 'itemName',
    itemType: 'itemType',
    categoryId: 'categoryId',
    unitId: 'unitId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    supplierId: 'supplierId',
    supplierCode: 'supplierCode',
    supplierName: 'supplierName',
    contactName: 'contactName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deactivatedAt: 'deactivatedAt',
    deactivatedBy: 'deactivatedBy'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    customerId: 'customerId',
    customerCode: 'customerCode',
    customerName: 'customerName',
    contactName: 'contactName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deactivatedAt: 'deactivatedAt',
    deactivatedBy: 'deactivatedBy'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SupplierItemPriceScalarFieldEnum: {
    supplierItemPriceId: 'supplierItemPriceId',
    supplierId: 'supplierId',
    itemId: 'itemId',
    unitPrice: 'unitPrice',
    effectiveFrom: 'effectiveFrom',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type SupplierItemPriceScalarFieldEnum = (typeof SupplierItemPriceScalarFieldEnum)[keyof typeof SupplierItemPriceScalarFieldEnum]


  export const CustomerItemPriceScalarFieldEnum: {
    customerItemPriceId: 'customerItemPriceId',
    customerId: 'customerId',
    itemId: 'itemId',
    unitPrice: 'unitPrice',
    effectiveFrom: 'effectiveFrom',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type CustomerItemPriceScalarFieldEnum = (typeof CustomerItemPriceScalarFieldEnum)[keyof typeof CustomerItemPriceScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    purchaseId: 'purchaseId',
    purchaseNo: 'purchaseNo',
    supplierId: 'supplierId',
    purchaseDate: 'purchaseDate',
    status: 'status',
    notes: 'notes',
    subtotal: 'subtotal',
    discount: 'discount',
    tax: 'tax',
    total: 'total',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedBy: 'updatedBy',
    updatedAt: 'updatedAt',
    confirmedAt: 'confirmedAt',
    confirmedBy: 'confirmedBy',
    receivedAt: 'receivedAt',
    receivedBy: 'receivedBy',
    cancelledAt: 'cancelledAt',
    cancelledBy: 'cancelledBy',
    cancelReason: 'cancelReason'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderLineScalarFieldEnum: {
    purchaseLineId: 'purchaseLineId',
    purchaseId: 'purchaseId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal',
    priceSource: 'priceSource',
    overrideReason: 'overrideReason',
    overriddenBy: 'overriddenBy'
  };

  export type PurchaseOrderLineScalarFieldEnum = (typeof PurchaseOrderLineScalarFieldEnum)[keyof typeof PurchaseOrderLineScalarFieldEnum]


  export const SalesOrderScalarFieldEnum: {
    salesOrderId: 'salesOrderId',
    orderNo: 'orderNo',
    customerId: 'customerId',
    orderDate: 'orderDate',
    status: 'status',
    notes: 'notes',
    subtotal: 'subtotal',
    discount: 'discount',
    tax: 'tax',
    total: 'total',
    isEditedAfterConfirm: 'isEditedAfterConfirm',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


  export const SalesOrderLineScalarFieldEnum: {
    salesOrderLineId: 'salesOrderLineId',
    salesOrderId: 'salesOrderId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal'
  };

  export type SalesOrderLineScalarFieldEnum = (typeof SalesOrderLineScalarFieldEnum)[keyof typeof SalesOrderLineScalarFieldEnum]


  export const DispatchScalarFieldEnum: {
    dispatchId: 'dispatchId',
    dispatchNo: 'dispatchNo',
    salesOrderId: 'salesOrderId',
    dispatchDate: 'dispatchDate',
    vehicleNo: 'vehicleNo',
    driverName: 'driverName',
    status: 'status',
    remarks: 'remarks',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type DispatchScalarFieldEnum = (typeof DispatchScalarFieldEnum)[keyof typeof DispatchScalarFieldEnum]


  export const ProductionDayScalarFieldEnum: {
    productionDayId: 'productionDayId',
    productionDate: 'productionDate',
    finishedProductId: 'finishedProductId',
    quantity: 'quantity',
    scrapQuantity: 'scrapQuantity',
    notes: 'notes',
    isClosed: 'isClosed',
    closedAt: 'closedAt',
    closedBy: 'closedBy',
    reopenReason: 'reopenReason',
    reopenedBy: 'reopenedBy',
    reopenedAt: 'reopenedAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ProductionDayScalarFieldEnum = (typeof ProductionDayScalarFieldEnum)[keyof typeof ProductionDayScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    stockMovementId: 'stockMovementId',
    movementDate: 'movementDate',
    movementType: 'movementType',
    itemId: 'itemId',
    qtyIn: 'qtyIn',
    qtyOut: 'qtyOut',
    unitCost: 'unitCost',
    refTable: 'refTable',
    refId: 'refId',
    purchaseId: 'purchaseId',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const StockBalanceScalarFieldEnum: {
    itemId: 'itemId',
    qtyOnHand: 'qtyOnHand',
    updatedAt: 'updatedAt'
  };

  export type StockBalanceScalarFieldEnum = (typeof StockBalanceScalarFieldEnum)[keyof typeof StockBalanceScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    invoiceId: 'invoiceId',
    invoiceNo: 'invoiceNo',
    invoiceType: 'invoiceType',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    customerId: 'customerId',
    supplierId: 'supplierId',
    salesOrderId: 'salesOrderId',
    purchaseId: 'purchaseId',
    subtotal: 'subtotal',
    discount: 'discount',
    tax: 'tax',
    total: 'total',
    status: 'status',
    printTemplate: 'printTemplate',
    vendorInvoiceNo: 'vendorInvoiceNo',
    vendorInvoiceDate: 'vendorInvoiceDate',
    vendorInvoiceTotal: 'vendorInvoiceTotal',
    matchStatus: 'matchStatus',
    mismatchAmount: 'mismatchAmount',
    matchCheckedBy: 'matchCheckedBy',
    matchCheckedAt: 'matchCheckedAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    invoiceLineId: 'invoiceLineId',
    invoiceId: 'invoiceId',
    itemId: 'itemId',
    description: 'description',
    qty: 'qty',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    paymentId: 'paymentId',
    paymentNo: 'paymentNo',
    invoiceId: 'invoiceId',
    paymentDate: 'paymentDate',
    amount: 'amount',
    method: 'method',
    referenceNo: 'referenceNo',
    notes: 'notes',
    receivedBy: 'receivedBy',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    expenseId: 'expenseId',
    expenseNo: 'expenseNo',
    expenseDate: 'expenseDate',
    category: 'category',
    description: 'description',
    amount: 'amount',
    method: 'method',
    paidTo: 'paidTo',
    supplierId: 'supplierId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const CashTransactionScalarFieldEnum: {
    txId: 'txId',
    txDate: 'txDate',
    txType: 'txType',
    sourceModule: 'sourceModule',
    refTable: 'refTable',
    refId: 'refId',
    amountIn: 'amountIn',
    amountOut: 'amountOut',
    method: 'method',
    note: 'note',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type CashTransactionScalarFieldEnum = (typeof CashTransactionScalarFieldEnum)[keyof typeof CashTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>
    


  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PayMethod'
   */
  export type EnumPayMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayMethod'>
    


  /**
   * Reference to a field of type 'PayMethod[]'
   */
  export type ListEnumPayMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayMethod[]'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'DocStatus'
   */
  export type EnumDocStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocStatus'>
    


  /**
   * Reference to a field of type 'DocStatus[]'
   */
  export type ListEnumDocStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocStatus[]'>
    


  /**
   * Reference to a field of type 'MovementType'
   */
  export type EnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType'>
    


  /**
   * Reference to a field of type 'MovementType[]'
   */
  export type ListEnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'TxType'
   */
  export type EnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType'>
    


  /**
   * Reference to a field of type 'TxType[]'
   */
  export type ListEnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    roleId?: IntFilter<"Role"> | number
    roleName?: EnumRoleNameFilter<"Role"> | $Enums.RoleName
    idPrefix?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    idPrefix?: SortOrder
    description?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    roleId?: number
    roleName?: $Enums.RoleName
    idPrefix?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserListRelationFilter
  }, "roleId" | "roleName" | "idPrefix">

  export type RoleOrderByWithAggregationInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    idPrefix?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"Role"> | number
    roleName?: EnumRoleNameWithAggregatesFilter<"Role"> | $Enums.RoleName
    idPrefix?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userId?: BigIntFilter<"User"> | bigint | number
    userCode?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    recordedAttendances?: AttendanceDailyListRelationFilter
    attendances?: AttendanceDailyListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    dispatches?: DispatchListRelationFilter
    employeeProfile?: XOR<EmployeeProfileNullableRelationFilter, EmployeeProfileWhereInput> | null
    expenses?: ExpenseListRelationFilter
    invoicesCreated?: InvoiceListRelationFilter
    invoicesMatched?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    productionDaysClosed?: ProductionDayListRelationFilter
    productionDaysCreated?: ProductionDayListRelationFilter
    productionDaysReopened?: ProductionDayListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    salaryPaymentsPaid?: SalaryPaymentListRelationFilter
    salaryRecords?: SalaryRecordListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    userId?: SortOrder
    userCode?: SortOrder
    roleId?: SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recordedAttendances?: AttendanceDailyOrderByRelationAggregateInput
    attendances?: AttendanceDailyOrderByRelationAggregateInput
    cashTransactions?: CashTransactionOrderByRelationAggregateInput
    dispatches?: DispatchOrderByRelationAggregateInput
    employeeProfile?: EmployeeProfileOrderByWithRelationInput
    expenses?: ExpenseOrderByRelationAggregateInput
    invoicesCreated?: InvoiceOrderByRelationAggregateInput
    invoicesMatched?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    productionDaysClosed?: ProductionDayOrderByRelationAggregateInput
    productionDaysCreated?: ProductionDayOrderByRelationAggregateInput
    productionDaysReopened?: ProductionDayOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    salaryPaymentsPaid?: SalaryPaymentOrderByRelationAggregateInput
    salaryRecords?: SalaryRecordOrderByRelationAggregateInput
    salesOrders?: SalesOrderOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    userId?: bigint | number
    userCode?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    roleId?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    recordedAttendances?: AttendanceDailyListRelationFilter
    attendances?: AttendanceDailyListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    dispatches?: DispatchListRelationFilter
    employeeProfile?: XOR<EmployeeProfileNullableRelationFilter, EmployeeProfileWhereInput> | null
    expenses?: ExpenseListRelationFilter
    invoicesCreated?: InvoiceListRelationFilter
    invoicesMatched?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    productionDaysClosed?: ProductionDayListRelationFilter
    productionDaysCreated?: ProductionDayListRelationFilter
    productionDaysReopened?: ProductionDayListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    salaryPaymentsPaid?: SalaryPaymentListRelationFilter
    salaryRecords?: SalaryRecordListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "userId" | "userCode" | "username">

  export type UserOrderByWithAggregationInput = {
    userId?: SortOrder
    userCode?: SortOrder
    roleId?: SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    userId?: BigIntWithAggregatesFilter<"User"> | bigint | number
    userCode?: StringWithAggregatesFilter<"User"> | string
    roleId?: IntWithAggregatesFilter<"User"> | number
    fullName?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SalaryRangeWhereInput = {
    AND?: SalaryRangeWhereInput | SalaryRangeWhereInput[]
    OR?: SalaryRangeWhereInput[]
    NOT?: SalaryRangeWhereInput | SalaryRangeWhereInput[]
    salaryRangeId?: BigIntFilter<"SalaryRange"> | bigint | number
    rangeName?: StringFilter<"SalaryRange"> | string
    minSalary?: DecimalFilter<"SalaryRange"> | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFilter<"SalaryRange"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"SalaryRange"> | boolean
    createdAt?: DateTimeFilter<"SalaryRange"> | Date | string
    employeeProfiles?: EmployeeProfileListRelationFilter
  }

  export type SalaryRangeOrderByWithRelationInput = {
    salaryRangeId?: SortOrder
    rangeName?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    employeeProfiles?: EmployeeProfileOrderByRelationAggregateInput
  }

  export type SalaryRangeWhereUniqueInput = Prisma.AtLeast<{
    salaryRangeId?: bigint | number
    AND?: SalaryRangeWhereInput | SalaryRangeWhereInput[]
    OR?: SalaryRangeWhereInput[]
    NOT?: SalaryRangeWhereInput | SalaryRangeWhereInput[]
    rangeName?: StringFilter<"SalaryRange"> | string
    minSalary?: DecimalFilter<"SalaryRange"> | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFilter<"SalaryRange"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"SalaryRange"> | boolean
    createdAt?: DateTimeFilter<"SalaryRange"> | Date | string
    employeeProfiles?: EmployeeProfileListRelationFilter
  }, "salaryRangeId">

  export type SalaryRangeOrderByWithAggregationInput = {
    salaryRangeId?: SortOrder
    rangeName?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: SalaryRangeCountOrderByAggregateInput
    _avg?: SalaryRangeAvgOrderByAggregateInput
    _max?: SalaryRangeMaxOrderByAggregateInput
    _min?: SalaryRangeMinOrderByAggregateInput
    _sum?: SalaryRangeSumOrderByAggregateInput
  }

  export type SalaryRangeScalarWhereWithAggregatesInput = {
    AND?: SalaryRangeScalarWhereWithAggregatesInput | SalaryRangeScalarWhereWithAggregatesInput[]
    OR?: SalaryRangeScalarWhereWithAggregatesInput[]
    NOT?: SalaryRangeScalarWhereWithAggregatesInput | SalaryRangeScalarWhereWithAggregatesInput[]
    salaryRangeId?: BigIntWithAggregatesFilter<"SalaryRange"> | bigint | number
    rangeName?: StringWithAggregatesFilter<"SalaryRange"> | string
    minSalary?: DecimalWithAggregatesFilter<"SalaryRange"> | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalWithAggregatesFilter<"SalaryRange"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"SalaryRange"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SalaryRange"> | Date | string
  }

  export type EmployeeProfileWhereInput = {
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    userId?: BigIntFilter<"EmployeeProfile"> | bigint | number
    nic?: StringNullableFilter<"EmployeeProfile"> | string | null
    address?: StringNullableFilter<"EmployeeProfile"> | string | null
    joinedDate?: DateTimeNullableFilter<"EmployeeProfile"> | Date | string | null
    designation?: StringNullableFilter<"EmployeeProfile"> | string | null
    basicSalary?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    salaryRangeId?: BigIntNullableFilter<"EmployeeProfile"> | bigint | number | null
    otRate?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"EmployeeProfile"> | string | null
    salaryRange?: XOR<SalaryRangeNullableRelationFilter, SalaryRangeWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmployeeProfileOrderByWithRelationInput = {
    userId?: SortOrder
    nic?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    joinedDate?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrderInput | SortOrder
    otRate?: SortOrder
    notes?: SortOrderInput | SortOrder
    salaryRange?: SalaryRangeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EmployeeProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: bigint | number
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    nic?: StringNullableFilter<"EmployeeProfile"> | string | null
    address?: StringNullableFilter<"EmployeeProfile"> | string | null
    joinedDate?: DateTimeNullableFilter<"EmployeeProfile"> | Date | string | null
    designation?: StringNullableFilter<"EmployeeProfile"> | string | null
    basicSalary?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    salaryRangeId?: BigIntNullableFilter<"EmployeeProfile"> | bigint | number | null
    otRate?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"EmployeeProfile"> | string | null
    salaryRange?: XOR<SalaryRangeNullableRelationFilter, SalaryRangeWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId">

  export type EmployeeProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    nic?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    joinedDate?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrderInput | SortOrder
    otRate?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: EmployeeProfileCountOrderByAggregateInput
    _avg?: EmployeeProfileAvgOrderByAggregateInput
    _max?: EmployeeProfileMaxOrderByAggregateInput
    _min?: EmployeeProfileMinOrderByAggregateInput
    _sum?: EmployeeProfileSumOrderByAggregateInput
  }

  export type EmployeeProfileScalarWhereWithAggregatesInput = {
    AND?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    OR?: EmployeeProfileScalarWhereWithAggregatesInput[]
    NOT?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    userId?: BigIntWithAggregatesFilter<"EmployeeProfile"> | bigint | number
    nic?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    address?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    joinedDate?: DateTimeNullableWithAggregatesFilter<"EmployeeProfile"> | Date | string | null
    designation?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    basicSalary?: DecimalWithAggregatesFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    salaryRangeId?: BigIntNullableWithAggregatesFilter<"EmployeeProfile"> | bigint | number | null
    otRate?: DecimalWithAggregatesFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
  }

  export type AttendanceDailyWhereInput = {
    AND?: AttendanceDailyWhereInput | AttendanceDailyWhereInput[]
    OR?: AttendanceDailyWhereInput[]
    NOT?: AttendanceDailyWhereInput | AttendanceDailyWhereInput[]
    attendanceId?: BigIntFilter<"AttendanceDaily"> | bigint | number
    userId?: BigIntFilter<"AttendanceDaily"> | bigint | number
    workDate?: DateTimeFilter<"AttendanceDaily"> | Date | string
    timeIn?: DateTimeNullableFilter<"AttendanceDaily"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"AttendanceDaily"> | Date | string | null
    systemHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableFilter<"AttendanceDaily"> | string | null
    recordedBy?: BigIntNullableFilter<"AttendanceDaily"> | bigint | number | null
    createdAt?: DateTimeFilter<"AttendanceDaily"> | Date | string
    recorder?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AttendanceDailyOrderByWithRelationInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    workDate?: SortOrder
    timeIn?: SortOrderInput | SortOrder
    timeOut?: SortOrderInput | SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    remarks?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    recorder?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceDailyWhereUniqueInput = Prisma.AtLeast<{
    attendanceId?: bigint | number
    userId_workDate?: AttendanceDailyUserIdWorkDateCompoundUniqueInput
    AND?: AttendanceDailyWhereInput | AttendanceDailyWhereInput[]
    OR?: AttendanceDailyWhereInput[]
    NOT?: AttendanceDailyWhereInput | AttendanceDailyWhereInput[]
    userId?: BigIntFilter<"AttendanceDaily"> | bigint | number
    workDate?: DateTimeFilter<"AttendanceDaily"> | Date | string
    timeIn?: DateTimeNullableFilter<"AttendanceDaily"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"AttendanceDaily"> | Date | string | null
    systemHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableFilter<"AttendanceDaily"> | string | null
    recordedBy?: BigIntNullableFilter<"AttendanceDaily"> | bigint | number | null
    createdAt?: DateTimeFilter<"AttendanceDaily"> | Date | string
    recorder?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "attendanceId" | "userId_workDate">

  export type AttendanceDailyOrderByWithAggregationInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    workDate?: SortOrder
    timeIn?: SortOrderInput | SortOrder
    timeOut?: SortOrderInput | SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    remarks?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceDailyCountOrderByAggregateInput
    _avg?: AttendanceDailyAvgOrderByAggregateInput
    _max?: AttendanceDailyMaxOrderByAggregateInput
    _min?: AttendanceDailyMinOrderByAggregateInput
    _sum?: AttendanceDailySumOrderByAggregateInput
  }

  export type AttendanceDailyScalarWhereWithAggregatesInput = {
    AND?: AttendanceDailyScalarWhereWithAggregatesInput | AttendanceDailyScalarWhereWithAggregatesInput[]
    OR?: AttendanceDailyScalarWhereWithAggregatesInput[]
    NOT?: AttendanceDailyScalarWhereWithAggregatesInput | AttendanceDailyScalarWhereWithAggregatesInput[]
    attendanceId?: BigIntWithAggregatesFilter<"AttendanceDaily"> | bigint | number
    userId?: BigIntWithAggregatesFilter<"AttendanceDaily"> | bigint | number
    workDate?: DateTimeWithAggregatesFilter<"AttendanceDaily"> | Date | string
    timeIn?: DateTimeNullableWithAggregatesFilter<"AttendanceDaily"> | Date | string | null
    timeOut?: DateTimeNullableWithAggregatesFilter<"AttendanceDaily"> | Date | string | null
    systemHours?: DecimalWithAggregatesFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalWithAggregatesFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalWithAggregatesFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableWithAggregatesFilter<"AttendanceDaily"> | string | null
    recordedBy?: BigIntNullableWithAggregatesFilter<"AttendanceDaily"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceDaily"> | Date | string
  }

  export type SalaryPeriodWhereInput = {
    AND?: SalaryPeriodWhereInput | SalaryPeriodWhereInput[]
    OR?: SalaryPeriodWhereInput[]
    NOT?: SalaryPeriodWhereInput | SalaryPeriodWhereInput[]
    periodId?: BigIntFilter<"SalaryPeriod"> | bigint | number
    year?: IntFilter<"SalaryPeriod"> | number
    month?: IntFilter<"SalaryPeriod"> | number
    startDate?: DateTimeFilter<"SalaryPeriod"> | Date | string
    endDate?: DateTimeFilter<"SalaryPeriod"> | Date | string
    status?: StringFilter<"SalaryPeriod"> | string
    salaryRecords?: SalaryRecordListRelationFilter
  }

  export type SalaryPeriodOrderByWithRelationInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    salaryRecords?: SalaryRecordOrderByRelationAggregateInput
  }

  export type SalaryPeriodWhereUniqueInput = Prisma.AtLeast<{
    periodId?: bigint | number
    year_month?: SalaryPeriodYearMonthCompoundUniqueInput
    AND?: SalaryPeriodWhereInput | SalaryPeriodWhereInput[]
    OR?: SalaryPeriodWhereInput[]
    NOT?: SalaryPeriodWhereInput | SalaryPeriodWhereInput[]
    year?: IntFilter<"SalaryPeriod"> | number
    month?: IntFilter<"SalaryPeriod"> | number
    startDate?: DateTimeFilter<"SalaryPeriod"> | Date | string
    endDate?: DateTimeFilter<"SalaryPeriod"> | Date | string
    status?: StringFilter<"SalaryPeriod"> | string
    salaryRecords?: SalaryRecordListRelationFilter
  }, "periodId" | "year_month">

  export type SalaryPeriodOrderByWithAggregationInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    _count?: SalaryPeriodCountOrderByAggregateInput
    _avg?: SalaryPeriodAvgOrderByAggregateInput
    _max?: SalaryPeriodMaxOrderByAggregateInput
    _min?: SalaryPeriodMinOrderByAggregateInput
    _sum?: SalaryPeriodSumOrderByAggregateInput
  }

  export type SalaryPeriodScalarWhereWithAggregatesInput = {
    AND?: SalaryPeriodScalarWhereWithAggregatesInput | SalaryPeriodScalarWhereWithAggregatesInput[]
    OR?: SalaryPeriodScalarWhereWithAggregatesInput[]
    NOT?: SalaryPeriodScalarWhereWithAggregatesInput | SalaryPeriodScalarWhereWithAggregatesInput[]
    periodId?: BigIntWithAggregatesFilter<"SalaryPeriod"> | bigint | number
    year?: IntWithAggregatesFilter<"SalaryPeriod"> | number
    month?: IntWithAggregatesFilter<"SalaryPeriod"> | number
    startDate?: DateTimeWithAggregatesFilter<"SalaryPeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"SalaryPeriod"> | Date | string
    status?: StringWithAggregatesFilter<"SalaryPeriod"> | string
  }

  export type SalaryRecordWhereInput = {
    AND?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    OR?: SalaryRecordWhereInput[]
    NOT?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    salaryRecordId?: BigIntFilter<"SalaryRecord"> | bigint | number
    periodId?: BigIntFilter<"SalaryRecord"> | bigint | number
    userId?: BigIntFilter<"SalaryRecord"> | bigint | number
    baseSalary?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SalaryRecord"> | string
    payments?: SalaryPaymentListRelationFilter
    period?: XOR<SalaryPeriodRelationFilter, SalaryPeriodWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SalaryRecordOrderByWithRelationInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
    status?: SortOrder
    payments?: SalaryPaymentOrderByRelationAggregateInput
    period?: SalaryPeriodOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SalaryRecordWhereUniqueInput = Prisma.AtLeast<{
    salaryRecordId?: bigint | number
    periodId_userId?: SalaryRecordPeriodIdUserIdCompoundUniqueInput
    AND?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    OR?: SalaryRecordWhereInput[]
    NOT?: SalaryRecordWhereInput | SalaryRecordWhereInput[]
    periodId?: BigIntFilter<"SalaryRecord"> | bigint | number
    userId?: BigIntFilter<"SalaryRecord"> | bigint | number
    baseSalary?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SalaryRecord"> | string
    payments?: SalaryPaymentListRelationFilter
    period?: XOR<SalaryPeriodRelationFilter, SalaryPeriodWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "salaryRecordId" | "periodId_userId">

  export type SalaryRecordOrderByWithAggregationInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
    status?: SortOrder
    _count?: SalaryRecordCountOrderByAggregateInput
    _avg?: SalaryRecordAvgOrderByAggregateInput
    _max?: SalaryRecordMaxOrderByAggregateInput
    _min?: SalaryRecordMinOrderByAggregateInput
    _sum?: SalaryRecordSumOrderByAggregateInput
  }

  export type SalaryRecordScalarWhereWithAggregatesInput = {
    AND?: SalaryRecordScalarWhereWithAggregatesInput | SalaryRecordScalarWhereWithAggregatesInput[]
    OR?: SalaryRecordScalarWhereWithAggregatesInput[]
    NOT?: SalaryRecordScalarWhereWithAggregatesInput | SalaryRecordScalarWhereWithAggregatesInput[]
    salaryRecordId?: BigIntWithAggregatesFilter<"SalaryRecord"> | bigint | number
    periodId?: BigIntWithAggregatesFilter<"SalaryRecord"> | bigint | number
    userId?: BigIntWithAggregatesFilter<"SalaryRecord"> | bigint | number
    baseSalary?: DecimalWithAggregatesFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otHours?: DecimalWithAggregatesFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalWithAggregatesFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalWithAggregatesFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalWithAggregatesFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalWithAggregatesFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"SalaryRecord"> | string
  }

  export type SalaryPaymentWhereInput = {
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    salaryPaymentId?: BigIntFilter<"SalaryPayment"> | bigint | number
    salaryRecordId?: BigIntFilter<"SalaryPayment"> | bigint | number
    payDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    amount?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"SalaryPayment"> | $Enums.PayMethod
    referenceNo?: StringNullableFilter<"SalaryPayment"> | string | null
    paidBy?: BigIntNullableFilter<"SalaryPayment"> | bigint | number | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    payer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    salaryRecord?: XOR<SalaryRecordRelationFilter, SalaryRecordWhereInput>
  }

  export type SalaryPaymentOrderByWithRelationInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    payDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    paidBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    payer?: UserOrderByWithRelationInput
    salaryRecord?: SalaryRecordOrderByWithRelationInput
  }

  export type SalaryPaymentWhereUniqueInput = Prisma.AtLeast<{
    salaryPaymentId?: bigint | number
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    salaryRecordId?: BigIntFilter<"SalaryPayment"> | bigint | number
    payDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    amount?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"SalaryPayment"> | $Enums.PayMethod
    referenceNo?: StringNullableFilter<"SalaryPayment"> | string | null
    paidBy?: BigIntNullableFilter<"SalaryPayment"> | bigint | number | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    payer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    salaryRecord?: XOR<SalaryRecordRelationFilter, SalaryRecordWhereInput>
  }, "salaryPaymentId">

  export type SalaryPaymentOrderByWithAggregationInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    payDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    paidBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SalaryPaymentCountOrderByAggregateInput
    _avg?: SalaryPaymentAvgOrderByAggregateInput
    _max?: SalaryPaymentMaxOrderByAggregateInput
    _min?: SalaryPaymentMinOrderByAggregateInput
    _sum?: SalaryPaymentSumOrderByAggregateInput
  }

  export type SalaryPaymentScalarWhereWithAggregatesInput = {
    AND?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    OR?: SalaryPaymentScalarWhereWithAggregatesInput[]
    NOT?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    salaryPaymentId?: BigIntWithAggregatesFilter<"SalaryPayment"> | bigint | number
    salaryRecordId?: BigIntWithAggregatesFilter<"SalaryPayment"> | bigint | number
    payDate?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodWithAggregatesFilter<"SalaryPayment"> | $Enums.PayMethod
    referenceNo?: StringNullableWithAggregatesFilter<"SalaryPayment"> | string | null
    paidBy?: BigIntNullableWithAggregatesFilter<"SalaryPayment"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    unitId?: IntFilter<"Unit"> | number
    unitName?: StringFilter<"Unit"> | string
    symbol?: StringNullableFilter<"Unit"> | string | null
    items?: ItemListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    unitId?: SortOrder
    unitName?: SortOrder
    symbol?: SortOrderInput | SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    unitId?: number
    unitName?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    symbol?: StringNullableFilter<"Unit"> | string | null
    items?: ItemListRelationFilter
  }, "unitId" | "unitName">

  export type UnitOrderByWithAggregationInput = {
    unitId?: SortOrder
    unitName?: SortOrder
    symbol?: SortOrderInput | SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    unitId?: IntWithAggregatesFilter<"Unit"> | number
    unitName?: StringWithAggregatesFilter<"Unit"> | string
    symbol?: StringNullableWithAggregatesFilter<"Unit"> | string | null
  }

  export type ItemCategoryWhereInput = {
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    categoryId?: IntFilter<"ItemCategory"> | number
    categoryName?: StringFilter<"ItemCategory"> | string
    items?: ItemListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationInput = {
    categoryId?: SortOrder
    categoryName?: SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemCategoryWhereUniqueInput = Prisma.AtLeast<{
    categoryId?: number
    categoryName?: string
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    items?: ItemListRelationFilter
  }, "categoryId" | "categoryName">

  export type ItemCategoryOrderByWithAggregationInput = {
    categoryId?: SortOrder
    categoryName?: SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _avg?: ItemCategoryAvgOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
    _sum?: ItemCategorySumOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    categoryId?: IntWithAggregatesFilter<"ItemCategory"> | number
    categoryName?: StringWithAggregatesFilter<"ItemCategory"> | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    itemId?: BigIntFilter<"Item"> | bigint | number
    itemCode?: StringFilter<"Item"> | string
    itemName?: StringFilter<"Item"> | string
    itemType?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    categoryId?: IntNullableFilter<"Item"> | number | null
    unitId?: IntNullableFilter<"Item"> | number | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    customerPrices?: CustomerItemPriceListRelationFilter
    invoiceLines?: InvoiceLineListRelationFilter
    category?: XOR<ItemCategoryNullableRelationFilter, ItemCategoryWhereInput> | null
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    productionDays?: ProductionDayListRelationFilter
    purchaseOrderLines?: PurchaseOrderLineListRelationFilter
    salesOrderLines?: SalesOrderLineListRelationFilter
    stockBalance?: XOR<StockBalanceNullableRelationFilter, StockBalanceWhereInput> | null
    stockMovements?: StockMovementListRelationFilter
    supplierPrices?: SupplierItemPriceListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    itemId?: SortOrder
    itemCode?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerPrices?: CustomerItemPriceOrderByRelationAggregateInput
    invoiceLines?: InvoiceLineOrderByRelationAggregateInput
    category?: ItemCategoryOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    productionDays?: ProductionDayOrderByRelationAggregateInput
    purchaseOrderLines?: PurchaseOrderLineOrderByRelationAggregateInput
    salesOrderLines?: SalesOrderLineOrderByRelationAggregateInput
    stockBalance?: StockBalanceOrderByWithRelationInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    supplierPrices?: SupplierItemPriceOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    itemId?: bigint | number
    itemCode?: string
    itemName_itemType?: ItemItemNameItemTypeCompoundUniqueInput
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    itemName?: StringFilter<"Item"> | string
    itemType?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    categoryId?: IntNullableFilter<"Item"> | number | null
    unitId?: IntNullableFilter<"Item"> | number | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    customerPrices?: CustomerItemPriceListRelationFilter
    invoiceLines?: InvoiceLineListRelationFilter
    category?: XOR<ItemCategoryNullableRelationFilter, ItemCategoryWhereInput> | null
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    productionDays?: ProductionDayListRelationFilter
    purchaseOrderLines?: PurchaseOrderLineListRelationFilter
    salesOrderLines?: SalesOrderLineListRelationFilter
    stockBalance?: XOR<StockBalanceNullableRelationFilter, StockBalanceWhereInput> | null
    stockMovements?: StockMovementListRelationFilter
    supplierPrices?: SupplierItemPriceListRelationFilter
  }, "itemId" | "itemCode" | "itemName_itemType">

  export type ItemOrderByWithAggregationInput = {
    itemId?: SortOrder
    itemCode?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    itemId?: BigIntWithAggregatesFilter<"Item"> | bigint | number
    itemCode?: StringWithAggregatesFilter<"Item"> | string
    itemName?: StringWithAggregatesFilter<"Item"> | string
    itemType?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    categoryId?: IntNullableWithAggregatesFilter<"Item"> | number | null
    unitId?: IntNullableWithAggregatesFilter<"Item"> | number | null
    isActive?: BoolWithAggregatesFilter<"Item"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    supplierId?: BigIntFilter<"Supplier"> | bigint | number
    supplierCode?: StringFilter<"Supplier"> | string
    supplierName?: StringFilter<"Supplier"> | string
    contactName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    createdBy?: BigIntNullableFilter<"Supplier"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"Supplier"> | bigint | number | null
    deactivatedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    deactivatedBy?: BigIntNullableFilter<"Supplier"> | bigint | number | null
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    itemPrices?: SupplierItemPriceListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    supplierId?: SortOrder
    supplierCode?: SortOrder
    supplierName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    itemPrices?: SupplierItemPriceOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    supplierId?: bigint | number
    supplierCode?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    supplierName?: StringFilter<"Supplier"> | string
    contactName?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    createdBy?: BigIntNullableFilter<"Supplier"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"Supplier"> | bigint | number | null
    deactivatedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    deactivatedBy?: BigIntNullableFilter<"Supplier"> | bigint | number | null
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    itemPrices?: SupplierItemPriceListRelationFilter
  }, "supplierId" | "supplierCode">

  export type SupplierOrderByWithAggregationInput = {
    supplierId?: SortOrder
    supplierCode?: SortOrder
    supplierName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    supplierId?: BigIntWithAggregatesFilter<"Supplier"> | bigint | number
    supplierCode?: StringWithAggregatesFilter<"Supplier"> | string
    supplierName?: StringWithAggregatesFilter<"Supplier"> | string
    contactName?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    createdBy?: BigIntNullableWithAggregatesFilter<"Supplier"> | bigint | number | null
    updatedBy?: BigIntNullableWithAggregatesFilter<"Supplier"> | bigint | number | null
    deactivatedAt?: DateTimeNullableWithAggregatesFilter<"Supplier"> | Date | string | null
    deactivatedBy?: BigIntNullableWithAggregatesFilter<"Supplier"> | bigint | number | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customerId?: BigIntFilter<"Customer"> | bigint | number
    customerCode?: StringFilter<"Customer"> | string
    customerName?: StringFilter<"Customer"> | string
    contactName?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: BigIntNullableFilter<"Customer"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"Customer"> | bigint | number | null
    deactivatedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deactivatedBy?: BigIntNullableFilter<"Customer"> | bigint | number | null
    itemPrices?: CustomerItemPriceListRelationFilter
    invoices?: InvoiceListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    customerId?: SortOrder
    customerCode?: SortOrder
    customerName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    itemPrices?: CustomerItemPriceOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    salesOrders?: SalesOrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    customerId?: bigint | number
    customerCode?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customerName?: StringFilter<"Customer"> | string
    contactName?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: BigIntNullableFilter<"Customer"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"Customer"> | bigint | number | null
    deactivatedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deactivatedBy?: BigIntNullableFilter<"Customer"> | bigint | number | null
    itemPrices?: CustomerItemPriceListRelationFilter
    invoices?: InvoiceListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
  }, "customerId" | "customerCode">

  export type CustomerOrderByWithAggregationInput = {
    customerId?: SortOrder
    customerCode?: SortOrder
    customerName?: SortOrder
    contactName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deactivatedAt?: SortOrderInput | SortOrder
    deactivatedBy?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    customerId?: BigIntWithAggregatesFilter<"Customer"> | bigint | number
    customerCode?: StringWithAggregatesFilter<"Customer"> | string
    customerName?: StringWithAggregatesFilter<"Customer"> | string
    contactName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    createdBy?: BigIntNullableWithAggregatesFilter<"Customer"> | bigint | number | null
    updatedBy?: BigIntNullableWithAggregatesFilter<"Customer"> | bigint | number | null
    deactivatedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    deactivatedBy?: BigIntNullableWithAggregatesFilter<"Customer"> | bigint | number | null
  }

  export type SupplierItemPriceWhereInput = {
    AND?: SupplierItemPriceWhereInput | SupplierItemPriceWhereInput[]
    OR?: SupplierItemPriceWhereInput[]
    NOT?: SupplierItemPriceWhereInput | SupplierItemPriceWhereInput[]
    supplierItemPriceId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    supplierId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    itemId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    unitPrice?: DecimalFilter<"SupplierItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierItemPrice"> | Date | string | null
    isActive?: BoolFilter<"SupplierItemPrice"> | boolean
    createdAt?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    createdBy?: BigIntNullableFilter<"SupplierItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"SupplierItemPrice"> | bigint | number | null
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }

  export type SupplierItemPriceOrderByWithRelationInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierItemPriceWhereUniqueInput = Prisma.AtLeast<{
    supplierItemPriceId?: bigint | number
    supplierId_itemId_effectiveFrom?: SupplierItemPriceSupplierIdItemIdEffectiveFromCompoundUniqueInput
    AND?: SupplierItemPriceWhereInput | SupplierItemPriceWhereInput[]
    OR?: SupplierItemPriceWhereInput[]
    NOT?: SupplierItemPriceWhereInput | SupplierItemPriceWhereInput[]
    supplierId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    itemId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    unitPrice?: DecimalFilter<"SupplierItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierItemPrice"> | Date | string | null
    isActive?: BoolFilter<"SupplierItemPrice"> | boolean
    createdAt?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    createdBy?: BigIntNullableFilter<"SupplierItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"SupplierItemPrice"> | bigint | number | null
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }, "supplierItemPriceId" | "supplierId_itemId_effectiveFrom">

  export type SupplierItemPriceOrderByWithAggregationInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SupplierItemPriceCountOrderByAggregateInput
    _avg?: SupplierItemPriceAvgOrderByAggregateInput
    _max?: SupplierItemPriceMaxOrderByAggregateInput
    _min?: SupplierItemPriceMinOrderByAggregateInput
    _sum?: SupplierItemPriceSumOrderByAggregateInput
  }

  export type SupplierItemPriceScalarWhereWithAggregatesInput = {
    AND?: SupplierItemPriceScalarWhereWithAggregatesInput | SupplierItemPriceScalarWhereWithAggregatesInput[]
    OR?: SupplierItemPriceScalarWhereWithAggregatesInput[]
    NOT?: SupplierItemPriceScalarWhereWithAggregatesInput | SupplierItemPriceScalarWhereWithAggregatesInput[]
    supplierItemPriceId?: BigIntWithAggregatesFilter<"SupplierItemPrice"> | bigint | number
    supplierId?: BigIntWithAggregatesFilter<"SupplierItemPrice"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"SupplierItemPrice"> | bigint | number
    unitPrice?: DecimalWithAggregatesFilter<"SupplierItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"SupplierItemPrice"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"SupplierItemPrice"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"SupplierItemPrice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SupplierItemPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierItemPrice"> | Date | string
    createdBy?: BigIntNullableWithAggregatesFilter<"SupplierItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableWithAggregatesFilter<"SupplierItemPrice"> | bigint | number | null
  }

  export type CustomerItemPriceWhereInput = {
    AND?: CustomerItemPriceWhereInput | CustomerItemPriceWhereInput[]
    OR?: CustomerItemPriceWhereInput[]
    NOT?: CustomerItemPriceWhereInput | CustomerItemPriceWhereInput[]
    customerItemPriceId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    customerId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    itemId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    unitPrice?: DecimalFilter<"CustomerItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    endDate?: DateTimeNullableFilter<"CustomerItemPrice"> | Date | string | null
    isActive?: BoolFilter<"CustomerItemPrice"> | boolean
    createdAt?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    createdBy?: BigIntNullableFilter<"CustomerItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"CustomerItemPrice"> | bigint | number | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type CustomerItemPriceOrderByWithRelationInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type CustomerItemPriceWhereUniqueInput = Prisma.AtLeast<{
    customerItemPriceId?: bigint | number
    customerId_itemId_effectiveFrom?: CustomerItemPriceCustomerIdItemIdEffectiveFromCompoundUniqueInput
    AND?: CustomerItemPriceWhereInput | CustomerItemPriceWhereInput[]
    OR?: CustomerItemPriceWhereInput[]
    NOT?: CustomerItemPriceWhereInput | CustomerItemPriceWhereInput[]
    customerId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    itemId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    unitPrice?: DecimalFilter<"CustomerItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    endDate?: DateTimeNullableFilter<"CustomerItemPrice"> | Date | string | null
    isActive?: BoolFilter<"CustomerItemPrice"> | boolean
    createdAt?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    createdBy?: BigIntNullableFilter<"CustomerItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"CustomerItemPrice"> | bigint | number | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "customerItemPriceId" | "customerId_itemId_effectiveFrom">

  export type CustomerItemPriceOrderByWithAggregationInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: CustomerItemPriceCountOrderByAggregateInput
    _avg?: CustomerItemPriceAvgOrderByAggregateInput
    _max?: CustomerItemPriceMaxOrderByAggregateInput
    _min?: CustomerItemPriceMinOrderByAggregateInput
    _sum?: CustomerItemPriceSumOrderByAggregateInput
  }

  export type CustomerItemPriceScalarWhereWithAggregatesInput = {
    AND?: CustomerItemPriceScalarWhereWithAggregatesInput | CustomerItemPriceScalarWhereWithAggregatesInput[]
    OR?: CustomerItemPriceScalarWhereWithAggregatesInput[]
    NOT?: CustomerItemPriceScalarWhereWithAggregatesInput | CustomerItemPriceScalarWhereWithAggregatesInput[]
    customerItemPriceId?: BigIntWithAggregatesFilter<"CustomerItemPrice"> | bigint | number
    customerId?: BigIntWithAggregatesFilter<"CustomerItemPrice"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"CustomerItemPrice"> | bigint | number
    unitPrice?: DecimalWithAggregatesFilter<"CustomerItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"CustomerItemPrice"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"CustomerItemPrice"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"CustomerItemPrice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerItemPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerItemPrice"> | Date | string
    createdBy?: BigIntNullableWithAggregatesFilter<"CustomerItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableWithAggregatesFilter<"CustomerItemPrice"> | bigint | number | null
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    purchaseId?: BigIntFilter<"PurchaseOrder"> | bigint | number
    purchaseNo?: StringFilter<"PurchaseOrder"> | string
    supplierId?: BigIntFilter<"PurchaseOrder"> | bigint | number
    purchaseDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: EnumDocStatusFilter<"PurchaseOrder"> | $Enums.DocStatus
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    subtotal?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    confirmedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    receivedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    cancelledAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    cancelledBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    cancelReason?: StringNullableFilter<"PurchaseOrder"> | string | null
    invoices?: InvoiceListRelationFilter
    lines?: PurchaseOrderLineListRelationFilter
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    stockMovements?: StockMovementListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    purchaseId?: SortOrder
    purchaseNo?: SortOrder
    supplierId?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    lines?: PurchaseOrderLineOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    purchaseId?: bigint | number
    purchaseNo?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    supplierId?: BigIntFilter<"PurchaseOrder"> | bigint | number
    purchaseDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: EnumDocStatusFilter<"PurchaseOrder"> | $Enums.DocStatus
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    subtotal?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    confirmedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    receivedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    cancelledAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    cancelledBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    cancelReason?: StringNullableFilter<"PurchaseOrder"> | string | null
    invoices?: InvoiceListRelationFilter
    lines?: PurchaseOrderLineListRelationFilter
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    stockMovements?: StockMovementListRelationFilter
  }, "purchaseId" | "purchaseNo">

  export type PurchaseOrderOrderByWithAggregationInput = {
    purchaseId?: SortOrder
    purchaseNo?: SortOrder
    supplierId?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    purchaseId?: BigIntWithAggregatesFilter<"PurchaseOrder"> | bigint | number
    purchaseNo?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: BigIntWithAggregatesFilter<"PurchaseOrder"> | bigint | number
    purchaseDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    status?: EnumDocStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.DocStatus
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdBy?: BigIntNullableWithAggregatesFilter<"PurchaseOrder"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedBy?: BigIntNullableWithAggregatesFilter<"PurchaseOrder"> | bigint | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    confirmedBy?: BigIntNullableWithAggregatesFilter<"PurchaseOrder"> | bigint | number | null
    receivedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    receivedBy?: BigIntNullableWithAggregatesFilter<"PurchaseOrder"> | bigint | number | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    cancelledBy?: BigIntNullableWithAggregatesFilter<"PurchaseOrder"> | bigint | number | null
    cancelReason?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
  }

  export type PurchaseOrderLineWhereInput = {
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    purchaseLineId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    purchaseId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    itemId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    priceSource?: StringFilter<"PurchaseOrderLine"> | string
    overrideReason?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    overriddenBy?: BigIntNullableFilter<"PurchaseOrderLine"> | bigint | number | null
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }

  export type PurchaseOrderLineOrderByWithRelationInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    priceSource?: SortOrder
    overrideReason?: SortOrderInput | SortOrder
    overriddenBy?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type PurchaseOrderLineWhereUniqueInput = Prisma.AtLeast<{
    purchaseLineId?: bigint | number
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    purchaseId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    itemId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    priceSource?: StringFilter<"PurchaseOrderLine"> | string
    overrideReason?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    overriddenBy?: BigIntNullableFilter<"PurchaseOrderLine"> | bigint | number | null
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    purchaseOrder?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }, "purchaseLineId">

  export type PurchaseOrderLineOrderByWithAggregationInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    priceSource?: SortOrder
    overrideReason?: SortOrderInput | SortOrder
    overriddenBy?: SortOrderInput | SortOrder
    _count?: PurchaseOrderLineCountOrderByAggregateInput
    _avg?: PurchaseOrderLineAvgOrderByAggregateInput
    _max?: PurchaseOrderLineMaxOrderByAggregateInput
    _min?: PurchaseOrderLineMinOrderByAggregateInput
    _sum?: PurchaseOrderLineSumOrderByAggregateInput
  }

  export type PurchaseOrderLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    purchaseLineId?: BigIntWithAggregatesFilter<"PurchaseOrderLine"> | bigint | number
    purchaseId?: BigIntWithAggregatesFilter<"PurchaseOrderLine"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"PurchaseOrderLine"> | bigint | number
    qty?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    priceSource?: StringWithAggregatesFilter<"PurchaseOrderLine"> | string
    overrideReason?: StringNullableWithAggregatesFilter<"PurchaseOrderLine"> | string | null
    overriddenBy?: BigIntNullableWithAggregatesFilter<"PurchaseOrderLine"> | bigint | number | null
  }

  export type SalesOrderWhereInput = {
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    salesOrderId?: BigIntFilter<"SalesOrder"> | bigint | number
    orderNo?: StringFilter<"SalesOrder"> | string
    customerId?: BigIntFilter<"SalesOrder"> | bigint | number
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    status?: EnumDocStatusFilter<"SalesOrder"> | $Enums.DocStatus
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    subtotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFilter<"SalesOrder"> | boolean
    createdBy?: BigIntNullableFilter<"SalesOrder"> | bigint | number | null
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    dispatches?: DispatchListRelationFilter
    invoices?: InvoiceListRelationFilter
    lines?: SalesOrderLineListRelationFilter
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type SalesOrderOrderByWithRelationInput = {
    salesOrderId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    isEditedAfterConfirm?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    dispatches?: DispatchOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    lines?: SalesOrderLineOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type SalesOrderWhereUniqueInput = Prisma.AtLeast<{
    salesOrderId?: bigint | number
    orderNo?: string
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    customerId?: BigIntFilter<"SalesOrder"> | bigint | number
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    status?: EnumDocStatusFilter<"SalesOrder"> | $Enums.DocStatus
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    subtotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFilter<"SalesOrder"> | boolean
    createdBy?: BigIntNullableFilter<"SalesOrder"> | bigint | number | null
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    dispatches?: DispatchListRelationFilter
    invoices?: InvoiceListRelationFilter
    lines?: SalesOrderLineListRelationFilter
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }, "salesOrderId" | "orderNo">

  export type SalesOrderOrderByWithAggregationInput = {
    salesOrderId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    isEditedAfterConfirm?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SalesOrderCountOrderByAggregateInput
    _avg?: SalesOrderAvgOrderByAggregateInput
    _max?: SalesOrderMaxOrderByAggregateInput
    _min?: SalesOrderMinOrderByAggregateInput
    _sum?: SalesOrderSumOrderByAggregateInput
  }

  export type SalesOrderScalarWhereWithAggregatesInput = {
    AND?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    OR?: SalesOrderScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    salesOrderId?: BigIntWithAggregatesFilter<"SalesOrder"> | bigint | number
    orderNo?: StringWithAggregatesFilter<"SalesOrder"> | string
    customerId?: BigIntWithAggregatesFilter<"SalesOrder"> | bigint | number
    orderDate?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
    status?: EnumDocStatusWithAggregatesFilter<"SalesOrder"> | $Enums.DocStatus
    notes?: StringNullableWithAggregatesFilter<"SalesOrder"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolWithAggregatesFilter<"SalesOrder"> | boolean
    createdBy?: BigIntNullableWithAggregatesFilter<"SalesOrder"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
  }

  export type SalesOrderLineWhereInput = {
    AND?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    OR?: SalesOrderLineWhereInput[]
    NOT?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    salesOrderLineId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    salesOrderId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    itemId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    salesOrder?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
  }

  export type SalesOrderLineOrderByWithRelationInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    item?: ItemOrderByWithRelationInput
    salesOrder?: SalesOrderOrderByWithRelationInput
  }

  export type SalesOrderLineWhereUniqueInput = Prisma.AtLeast<{
    salesOrderLineId?: bigint | number
    AND?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    OR?: SalesOrderLineWhereInput[]
    NOT?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    salesOrderId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    itemId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    salesOrder?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
  }, "salesOrderLineId">

  export type SalesOrderLineOrderByWithAggregationInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    _count?: SalesOrderLineCountOrderByAggregateInput
    _avg?: SalesOrderLineAvgOrderByAggregateInput
    _max?: SalesOrderLineMaxOrderByAggregateInput
    _min?: SalesOrderLineMinOrderByAggregateInput
    _sum?: SalesOrderLineSumOrderByAggregateInput
  }

  export type SalesOrderLineScalarWhereWithAggregatesInput = {
    AND?: SalesOrderLineScalarWhereWithAggregatesInput | SalesOrderLineScalarWhereWithAggregatesInput[]
    OR?: SalesOrderLineScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderLineScalarWhereWithAggregatesInput | SalesOrderLineScalarWhereWithAggregatesInput[]
    salesOrderLineId?: BigIntWithAggregatesFilter<"SalesOrderLine"> | bigint | number
    salesOrderId?: BigIntWithAggregatesFilter<"SalesOrderLine"> | bigint | number
    itemId?: BigIntWithAggregatesFilter<"SalesOrderLine"> | bigint | number
    qty?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type DispatchWhereInput = {
    AND?: DispatchWhereInput | DispatchWhereInput[]
    OR?: DispatchWhereInput[]
    NOT?: DispatchWhereInput | DispatchWhereInput[]
    dispatchId?: BigIntFilter<"Dispatch"> | bigint | number
    dispatchNo?: StringFilter<"Dispatch"> | string
    salesOrderId?: BigIntFilter<"Dispatch"> | bigint | number
    dispatchDate?: DateTimeFilter<"Dispatch"> | Date | string
    vehicleNo?: StringNullableFilter<"Dispatch"> | string | null
    driverName?: StringNullableFilter<"Dispatch"> | string | null
    status?: EnumDocStatusFilter<"Dispatch"> | $Enums.DocStatus
    remarks?: StringNullableFilter<"Dispatch"> | string | null
    createdBy?: BigIntNullableFilter<"Dispatch"> | bigint | number | null
    createdAt?: DateTimeFilter<"Dispatch"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    salesOrder?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
  }

  export type DispatchOrderByWithRelationInput = {
    dispatchId?: SortOrder
    dispatchNo?: SortOrder
    salesOrderId?: SortOrder
    dispatchDate?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    driverName?: SortOrderInput | SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    salesOrder?: SalesOrderOrderByWithRelationInput
  }

  export type DispatchWhereUniqueInput = Prisma.AtLeast<{
    dispatchId?: bigint | number
    dispatchNo?: string
    AND?: DispatchWhereInput | DispatchWhereInput[]
    OR?: DispatchWhereInput[]
    NOT?: DispatchWhereInput | DispatchWhereInput[]
    salesOrderId?: BigIntFilter<"Dispatch"> | bigint | number
    dispatchDate?: DateTimeFilter<"Dispatch"> | Date | string
    vehicleNo?: StringNullableFilter<"Dispatch"> | string | null
    driverName?: StringNullableFilter<"Dispatch"> | string | null
    status?: EnumDocStatusFilter<"Dispatch"> | $Enums.DocStatus
    remarks?: StringNullableFilter<"Dispatch"> | string | null
    createdBy?: BigIntNullableFilter<"Dispatch"> | bigint | number | null
    createdAt?: DateTimeFilter<"Dispatch"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    salesOrder?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
  }, "dispatchId" | "dispatchNo">

  export type DispatchOrderByWithAggregationInput = {
    dispatchId?: SortOrder
    dispatchNo?: SortOrder
    salesOrderId?: SortOrder
    dispatchDate?: SortOrder
    vehicleNo?: SortOrderInput | SortOrder
    driverName?: SortOrderInput | SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DispatchCountOrderByAggregateInput
    _avg?: DispatchAvgOrderByAggregateInput
    _max?: DispatchMaxOrderByAggregateInput
    _min?: DispatchMinOrderByAggregateInput
    _sum?: DispatchSumOrderByAggregateInput
  }

  export type DispatchScalarWhereWithAggregatesInput = {
    AND?: DispatchScalarWhereWithAggregatesInput | DispatchScalarWhereWithAggregatesInput[]
    OR?: DispatchScalarWhereWithAggregatesInput[]
    NOT?: DispatchScalarWhereWithAggregatesInput | DispatchScalarWhereWithAggregatesInput[]
    dispatchId?: BigIntWithAggregatesFilter<"Dispatch"> | bigint | number
    dispatchNo?: StringWithAggregatesFilter<"Dispatch"> | string
    salesOrderId?: BigIntWithAggregatesFilter<"Dispatch"> | bigint | number
    dispatchDate?: DateTimeWithAggregatesFilter<"Dispatch"> | Date | string
    vehicleNo?: StringNullableWithAggregatesFilter<"Dispatch"> | string | null
    driverName?: StringNullableWithAggregatesFilter<"Dispatch"> | string | null
    status?: EnumDocStatusWithAggregatesFilter<"Dispatch"> | $Enums.DocStatus
    remarks?: StringNullableWithAggregatesFilter<"Dispatch"> | string | null
    createdBy?: BigIntNullableWithAggregatesFilter<"Dispatch"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Dispatch"> | Date | string
  }

  export type ProductionDayWhereInput = {
    AND?: ProductionDayWhereInput | ProductionDayWhereInput[]
    OR?: ProductionDayWhereInput[]
    NOT?: ProductionDayWhereInput | ProductionDayWhereInput[]
    productionDayId?: BigIntFilter<"ProductionDay"> | bigint | number
    productionDate?: DateTimeFilter<"ProductionDay"> | Date | string
    finishedProductId?: BigIntFilter<"ProductionDay"> | bigint | number
    quantity?: DecimalFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ProductionDay"> | string | null
    isClosed?: BoolFilter<"ProductionDay"> | boolean
    closedAt?: DateTimeNullableFilter<"ProductionDay"> | Date | string | null
    closedBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    reopenReason?: StringNullableFilter<"ProductionDay"> | string | null
    reopenedBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    reopenedAt?: DateTimeNullableFilter<"ProductionDay"> | Date | string | null
    createdBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    createdAt?: DateTimeFilter<"ProductionDay"> | Date | string
    closer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    finishedProduct?: XOR<ItemRelationFilter, ItemWhereInput>
    reopener?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ProductionDayOrderByWithRelationInput = {
    productionDayId?: SortOrder
    productionDate?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedBy?: SortOrderInput | SortOrder
    reopenReason?: SortOrderInput | SortOrder
    reopenedBy?: SortOrderInput | SortOrder
    reopenedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    closer?: UserOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    finishedProduct?: ItemOrderByWithRelationInput
    reopener?: UserOrderByWithRelationInput
  }

  export type ProductionDayWhereUniqueInput = Prisma.AtLeast<{
    productionDayId?: bigint | number
    productionDate_finishedProductId?: ProductionDayProductionDateFinishedProductIdCompoundUniqueInput
    AND?: ProductionDayWhereInput | ProductionDayWhereInput[]
    OR?: ProductionDayWhereInput[]
    NOT?: ProductionDayWhereInput | ProductionDayWhereInput[]
    productionDate?: DateTimeFilter<"ProductionDay"> | Date | string
    finishedProductId?: BigIntFilter<"ProductionDay"> | bigint | number
    quantity?: DecimalFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ProductionDay"> | string | null
    isClosed?: BoolFilter<"ProductionDay"> | boolean
    closedAt?: DateTimeNullableFilter<"ProductionDay"> | Date | string | null
    closedBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    reopenReason?: StringNullableFilter<"ProductionDay"> | string | null
    reopenedBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    reopenedAt?: DateTimeNullableFilter<"ProductionDay"> | Date | string | null
    createdBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    createdAt?: DateTimeFilter<"ProductionDay"> | Date | string
    closer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    finishedProduct?: XOR<ItemRelationFilter, ItemWhereInput>
    reopener?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "productionDayId" | "productionDate_finishedProductId">

  export type ProductionDayOrderByWithAggregationInput = {
    productionDayId?: SortOrder
    productionDate?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedBy?: SortOrderInput | SortOrder
    reopenReason?: SortOrderInput | SortOrder
    reopenedBy?: SortOrderInput | SortOrder
    reopenedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductionDayCountOrderByAggregateInput
    _avg?: ProductionDayAvgOrderByAggregateInput
    _max?: ProductionDayMaxOrderByAggregateInput
    _min?: ProductionDayMinOrderByAggregateInput
    _sum?: ProductionDaySumOrderByAggregateInput
  }

  export type ProductionDayScalarWhereWithAggregatesInput = {
    AND?: ProductionDayScalarWhereWithAggregatesInput | ProductionDayScalarWhereWithAggregatesInput[]
    OR?: ProductionDayScalarWhereWithAggregatesInput[]
    NOT?: ProductionDayScalarWhereWithAggregatesInput | ProductionDayScalarWhereWithAggregatesInput[]
    productionDayId?: BigIntWithAggregatesFilter<"ProductionDay"> | bigint | number
    productionDate?: DateTimeWithAggregatesFilter<"ProductionDay"> | Date | string
    finishedProductId?: BigIntWithAggregatesFilter<"ProductionDay"> | bigint | number
    quantity?: DecimalWithAggregatesFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalWithAggregatesFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"ProductionDay"> | string | null
    isClosed?: BoolWithAggregatesFilter<"ProductionDay"> | boolean
    closedAt?: DateTimeNullableWithAggregatesFilter<"ProductionDay"> | Date | string | null
    closedBy?: BigIntNullableWithAggregatesFilter<"ProductionDay"> | bigint | number | null
    reopenReason?: StringNullableWithAggregatesFilter<"ProductionDay"> | string | null
    reopenedBy?: BigIntNullableWithAggregatesFilter<"ProductionDay"> | bigint | number | null
    reopenedAt?: DateTimeNullableWithAggregatesFilter<"ProductionDay"> | Date | string | null
    createdBy?: BigIntNullableWithAggregatesFilter<"ProductionDay"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionDay"> | Date | string
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    stockMovementId?: BigIntFilter<"StockMovement"> | bigint | number
    movementDate?: DateTimeFilter<"StockMovement"> | Date | string
    movementType?: EnumMovementTypeFilter<"StockMovement"> | $Enums.MovementType
    itemId?: BigIntFilter<"StockMovement"> | bigint | number
    qtyIn?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    refTable?: StringNullableFilter<"StockMovement"> | string | null
    refId?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    purchaseId?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    notes?: StringNullableFilter<"StockMovement"> | string | null
    createdBy?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
  }

  export type StockMovementOrderByWithRelationInput = {
    stockMovementId?: SortOrder
    movementDate?: SortOrder
    movementType?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refTable?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    stockMovementId?: bigint | number
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    movementDate?: DateTimeFilter<"StockMovement"> | Date | string
    movementType?: EnumMovementTypeFilter<"StockMovement"> | $Enums.MovementType
    itemId?: BigIntFilter<"StockMovement"> | bigint | number
    qtyIn?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    refTable?: StringNullableFilter<"StockMovement"> | string | null
    refId?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    purchaseId?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    notes?: StringNullableFilter<"StockMovement"> | string | null
    createdBy?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
  }, "stockMovementId">

  export type StockMovementOrderByWithAggregationInput = {
    stockMovementId?: SortOrder
    movementDate?: SortOrder
    movementType?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refTable?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    stockMovementId?: BigIntWithAggregatesFilter<"StockMovement"> | bigint | number
    movementDate?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
    movementType?: EnumMovementTypeWithAggregatesFilter<"StockMovement"> | $Enums.MovementType
    itemId?: BigIntWithAggregatesFilter<"StockMovement"> | bigint | number
    qtyIn?: DecimalWithAggregatesFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalWithAggregatesFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalWithAggregatesFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    refTable?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    refId?: BigIntNullableWithAggregatesFilter<"StockMovement"> | bigint | number | null
    purchaseId?: BigIntNullableWithAggregatesFilter<"StockMovement"> | bigint | number | null
    notes?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdBy?: BigIntNullableWithAggregatesFilter<"StockMovement"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type StockBalanceWhereInput = {
    AND?: StockBalanceWhereInput | StockBalanceWhereInput[]
    OR?: StockBalanceWhereInput[]
    NOT?: StockBalanceWhereInput | StockBalanceWhereInput[]
    itemId?: BigIntFilter<"StockBalance"> | bigint | number
    qtyOnHand?: DecimalFilter<"StockBalance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"StockBalance"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type StockBalanceOrderByWithRelationInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
    updatedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
  }

  export type StockBalanceWhereUniqueInput = Prisma.AtLeast<{
    itemId?: bigint | number
    AND?: StockBalanceWhereInput | StockBalanceWhereInput[]
    OR?: StockBalanceWhereInput[]
    NOT?: StockBalanceWhereInput | StockBalanceWhereInput[]
    qtyOnHand?: DecimalFilter<"StockBalance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"StockBalance"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "itemId">

  export type StockBalanceOrderByWithAggregationInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
    updatedAt?: SortOrder
    _count?: StockBalanceCountOrderByAggregateInput
    _avg?: StockBalanceAvgOrderByAggregateInput
    _max?: StockBalanceMaxOrderByAggregateInput
    _min?: StockBalanceMinOrderByAggregateInput
    _sum?: StockBalanceSumOrderByAggregateInput
  }

  export type StockBalanceScalarWhereWithAggregatesInput = {
    AND?: StockBalanceScalarWhereWithAggregatesInput | StockBalanceScalarWhereWithAggregatesInput[]
    OR?: StockBalanceScalarWhereWithAggregatesInput[]
    NOT?: StockBalanceScalarWhereWithAggregatesInput | StockBalanceScalarWhereWithAggregatesInput[]
    itemId?: BigIntWithAggregatesFilter<"StockBalance"> | bigint | number
    qtyOnHand?: DecimalWithAggregatesFilter<"StockBalance"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockBalance"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceId?: BigIntFilter<"Invoice"> | bigint | number
    invoiceNo?: StringFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customerId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    supplierId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    salesOrderId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    purchaseId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFilter<"Invoice"> | $Enums.DocStatus
    printTemplate?: StringFilter<"Invoice"> | string
    vendorInvoiceNo?: StringNullableFilter<"Invoice"> | string | null
    vendorInvoiceDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    vendorInvoiceTotal?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFilter<"Invoice"> | $Enums.MatchStatus
    mismatchAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    matchCheckedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdBy?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    lines?: InvoiceLineListRelationFilter
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    matchChecker?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
    salesOrder?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    invoiceId?: SortOrder
    invoiceNo?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    salesOrderId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    printTemplate?: SortOrder
    vendorInvoiceNo?: SortOrderInput | SortOrder
    vendorInvoiceDate?: SortOrderInput | SortOrder
    vendorInvoiceTotal?: SortOrderInput | SortOrder
    matchStatus?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrderInput | SortOrder
    matchCheckedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lines?: InvoiceLineOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    matchChecker?: UserOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    salesOrder?: SalesOrderOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    invoiceId?: bigint | number
    invoiceNo?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceType?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customerId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    supplierId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    salesOrderId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    purchaseId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFilter<"Invoice"> | $Enums.DocStatus
    printTemplate?: StringFilter<"Invoice"> | string
    vendorInvoiceNo?: StringNullableFilter<"Invoice"> | string | null
    vendorInvoiceDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    vendorInvoiceTotal?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFilter<"Invoice"> | $Enums.MatchStatus
    mismatchAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    matchCheckedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdBy?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    lines?: InvoiceLineListRelationFilter
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    matchChecker?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    purchaseOrder?: XOR<PurchaseOrderNullableRelationFilter, PurchaseOrderWhereInput> | null
    salesOrder?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    payments?: PaymentListRelationFilter
  }, "invoiceId" | "invoiceNo">

  export type InvoiceOrderByWithAggregationInput = {
    invoiceId?: SortOrder
    invoiceNo?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    salesOrderId?: SortOrderInput | SortOrder
    purchaseId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    printTemplate?: SortOrder
    vendorInvoiceNo?: SortOrderInput | SortOrder
    vendorInvoiceDate?: SortOrderInput | SortOrder
    vendorInvoiceTotal?: SortOrderInput | SortOrder
    matchStatus?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrderInput | SortOrder
    matchCheckedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    invoiceId?: BigIntWithAggregatesFilter<"Invoice"> | bigint | number
    invoiceNo?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    customerId?: BigIntNullableWithAggregatesFilter<"Invoice"> | bigint | number | null
    supplierId?: BigIntNullableWithAggregatesFilter<"Invoice"> | bigint | number | null
    salesOrderId?: BigIntNullableWithAggregatesFilter<"Invoice"> | bigint | number | null
    purchaseId?: BigIntNullableWithAggregatesFilter<"Invoice"> | bigint | number | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusWithAggregatesFilter<"Invoice"> | $Enums.DocStatus
    printTemplate?: StringWithAggregatesFilter<"Invoice"> | string
    vendorInvoiceNo?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    vendorInvoiceDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    vendorInvoiceTotal?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusWithAggregatesFilter<"Invoice"> | $Enums.MatchStatus
    mismatchAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: BigIntNullableWithAggregatesFilter<"Invoice"> | bigint | number | null
    matchCheckedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdBy?: BigIntNullableWithAggregatesFilter<"Invoice"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceLineId?: BigIntFilter<"InvoiceLine"> | bigint | number
    invoiceId?: BigIntFilter<"InvoiceLine"> | bigint | number
    itemId?: BigIntNullableFilter<"InvoiceLine"> | bigint | number | null
    description?: StringNullableFilter<"InvoiceLine"> | string | null
    qty?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
  }

  export type InvoiceLineOrderByWithRelationInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    invoiceLineId?: bigint | number
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: BigIntFilter<"InvoiceLine"> | bigint | number
    itemId?: BigIntNullableFilter<"InvoiceLine"> | bigint | number | null
    description?: StringNullableFilter<"InvoiceLine"> | string | null
    qty?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    item?: XOR<ItemNullableRelationFilter, ItemWhereInput> | null
  }, "invoiceLineId">

  export type InvoiceLineOrderByWithAggregationInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    invoiceLineId?: BigIntWithAggregatesFilter<"InvoiceLine"> | bigint | number
    invoiceId?: BigIntWithAggregatesFilter<"InvoiceLine"> | bigint | number
    itemId?: BigIntNullableWithAggregatesFilter<"InvoiceLine"> | bigint | number | null
    description?: StringNullableWithAggregatesFilter<"InvoiceLine"> | string | null
    qty?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    paymentId?: BigIntFilter<"Payment"> | bigint | number
    paymentNo?: StringFilter<"Payment"> | string
    invoiceId?: BigIntFilter<"Payment"> | bigint | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"Payment"> | $Enums.PayMethod
    referenceNo?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    receivedBy?: BigIntNullableFilter<"Payment"> | bigint | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    receiver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    paymentId?: SortOrder
    paymentNo?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    paymentId?: bigint | number
    paymentNo?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: BigIntFilter<"Payment"> | bigint | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"Payment"> | $Enums.PayMethod
    referenceNo?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    receivedBy?: BigIntNullableFilter<"Payment"> | bigint | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    receiver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "paymentId" | "paymentNo">

  export type PaymentOrderByWithAggregationInput = {
    paymentId?: SortOrder
    paymentNo?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    receivedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    paymentId?: BigIntWithAggregatesFilter<"Payment"> | bigint | number
    paymentNo?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: BigIntWithAggregatesFilter<"Payment"> | bigint | number
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodWithAggregatesFilter<"Payment"> | $Enums.PayMethod
    referenceNo?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receivedBy?: BigIntNullableWithAggregatesFilter<"Payment"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    expenseId?: BigIntFilter<"Expense"> | bigint | number
    expenseNo?: StringFilter<"Expense"> | string
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"Expense"> | $Enums.PayMethod
    paidTo?: StringNullableFilter<"Expense"> | string | null
    supplierId?: BigIntNullableFilter<"Expense"> | bigint | number | null
    createdBy?: BigIntNullableFilter<"Expense"> | bigint | number | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    expenseId?: SortOrder
    expenseNo?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    paidTo?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    expenseId?: bigint | number
    expenseNo?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"Expense"> | $Enums.PayMethod
    paidTo?: StringNullableFilter<"Expense"> | string | null
    supplierId?: BigIntNullableFilter<"Expense"> | bigint | number | null
    createdBy?: BigIntNullableFilter<"Expense"> | bigint | number | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
  }, "expenseId" | "expenseNo">

  export type ExpenseOrderByWithAggregationInput = {
    expenseId?: SortOrder
    expenseNo?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    paidTo?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    expenseId?: BigIntWithAggregatesFilter<"Expense"> | bigint | number
    expenseNo?: StringWithAggregatesFilter<"Expense"> | string
    expenseDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    category?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodWithAggregatesFilter<"Expense"> | $Enums.PayMethod
    paidTo?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    supplierId?: BigIntNullableWithAggregatesFilter<"Expense"> | bigint | number | null
    createdBy?: BigIntNullableWithAggregatesFilter<"Expense"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type CashTransactionWhereInput = {
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    txId?: BigIntFilter<"CashTransaction"> | bigint | number
    txDate?: DateTimeFilter<"CashTransaction"> | Date | string
    txType?: EnumTxTypeFilter<"CashTransaction"> | $Enums.TxType
    sourceModule?: StringNullableFilter<"CashTransaction"> | string | null
    refTable?: StringNullableFilter<"CashTransaction"> | string | null
    refId?: BigIntNullableFilter<"CashTransaction"> | bigint | number | null
    amountIn?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"CashTransaction"> | $Enums.PayMethod
    note?: StringNullableFilter<"CashTransaction"> | string | null
    createdBy?: BigIntNullableFilter<"CashTransaction"> | bigint | number | null
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CashTransactionOrderByWithRelationInput = {
    txId?: SortOrder
    txDate?: SortOrder
    txType?: SortOrder
    sourceModule?: SortOrderInput | SortOrder
    refTable?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    method?: SortOrder
    note?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type CashTransactionWhereUniqueInput = Prisma.AtLeast<{
    txId?: bigint | number
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    txDate?: DateTimeFilter<"CashTransaction"> | Date | string
    txType?: EnumTxTypeFilter<"CashTransaction"> | $Enums.TxType
    sourceModule?: StringNullableFilter<"CashTransaction"> | string | null
    refTable?: StringNullableFilter<"CashTransaction"> | string | null
    refId?: BigIntNullableFilter<"CashTransaction"> | bigint | number | null
    amountIn?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"CashTransaction"> | $Enums.PayMethod
    note?: StringNullableFilter<"CashTransaction"> | string | null
    createdBy?: BigIntNullableFilter<"CashTransaction"> | bigint | number | null
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "txId">

  export type CashTransactionOrderByWithAggregationInput = {
    txId?: SortOrder
    txDate?: SortOrder
    txType?: SortOrder
    sourceModule?: SortOrderInput | SortOrder
    refTable?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    method?: SortOrder
    note?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CashTransactionCountOrderByAggregateInput
    _avg?: CashTransactionAvgOrderByAggregateInput
    _max?: CashTransactionMaxOrderByAggregateInput
    _min?: CashTransactionMinOrderByAggregateInput
    _sum?: CashTransactionSumOrderByAggregateInput
  }

  export type CashTransactionScalarWhereWithAggregatesInput = {
    AND?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    OR?: CashTransactionScalarWhereWithAggregatesInput[]
    NOT?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    txId?: BigIntWithAggregatesFilter<"CashTransaction"> | bigint | number
    txDate?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
    txType?: EnumTxTypeWithAggregatesFilter<"CashTransaction"> | $Enums.TxType
    sourceModule?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    refTable?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    refId?: BigIntNullableWithAggregatesFilter<"CashTransaction"> | bigint | number | null
    amountIn?: DecimalWithAggregatesFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalWithAggregatesFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodWithAggregatesFilter<"CashTransaction"> | $Enums.PayMethod
    note?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    createdBy?: BigIntNullableWithAggregatesFilter<"CashTransaction"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
  }

  export type RoleCreateInput = {
    roleName: $Enums.RoleName
    idPrefix: string
    description?: string | null
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    roleId?: number
    roleName: $Enums.RoleName
    idPrefix: string
    description?: string | null
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    idPrefix?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    idPrefix?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    roleId?: number
    roleName: $Enums.RoleName
    idPrefix: string
    description?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    idPrefix?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    idPrefix?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRangeCreateInput = {
    salaryRangeId?: bigint | number
    rangeName: string
    minSalary?: Decimal | DecimalJsLike | number | string
    maxSalary?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    employeeProfiles?: EmployeeProfileCreateNestedManyWithoutSalaryRangeInput
  }

  export type SalaryRangeUncheckedCreateInput = {
    salaryRangeId?: bigint | number
    rangeName: string
    minSalary?: Decimal | DecimalJsLike | number | string
    maxSalary?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    employeeProfiles?: EmployeeProfileUncheckedCreateNestedManyWithoutSalaryRangeInput
  }

  export type SalaryRangeUpdateInput = {
    salaryRangeId?: BigIntFieldUpdateOperationsInput | bigint | number
    rangeName?: StringFieldUpdateOperationsInput | string
    minSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfiles?: EmployeeProfileUpdateManyWithoutSalaryRangeNestedInput
  }

  export type SalaryRangeUncheckedUpdateInput = {
    salaryRangeId?: BigIntFieldUpdateOperationsInput | bigint | number
    rangeName?: StringFieldUpdateOperationsInput | string
    minSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfiles?: EmployeeProfileUncheckedUpdateManyWithoutSalaryRangeNestedInput
  }

  export type SalaryRangeCreateManyInput = {
    salaryRangeId?: bigint | number
    rangeName: string
    minSalary?: Decimal | DecimalJsLike | number | string
    maxSalary?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SalaryRangeUpdateManyMutationInput = {
    salaryRangeId?: BigIntFieldUpdateOperationsInput | bigint | number
    rangeName?: StringFieldUpdateOperationsInput | string
    minSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRangeUncheckedUpdateManyInput = {
    salaryRangeId?: BigIntFieldUpdateOperationsInput | bigint | number
    rangeName?: StringFieldUpdateOperationsInput | string
    minSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateInput = {
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    salaryRange?: SalaryRangeCreateNestedOneWithoutEmployeeProfilesInput
    user: UserCreateNestedOneWithoutEmployeeProfileInput
  }

  export type EmployeeProfileUncheckedCreateInput = {
    userId: bigint | number
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    salaryRangeId?: bigint | number | null
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type EmployeeProfileUpdateInput = {
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    salaryRange?: SalaryRangeUpdateOneWithoutEmployeeProfilesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
  }

  export type EmployeeProfileUncheckedUpdateInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaryRangeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeProfileCreateManyInput = {
    userId: bigint | number
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    salaryRangeId?: bigint | number | null
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type EmployeeProfileUpdateManyMutationInput = {
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeProfileUncheckedUpdateManyInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaryRangeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceDailyCreateInput = {
    attendanceId?: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    createdAt?: Date | string
    recorder?: UserCreateNestedOneWithoutRecordedAttendancesInput
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceDailyUncheckedCreateInput = {
    attendanceId?: bigint | number
    userId: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    recordedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type AttendanceDailyUpdateInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recorder?: UserUpdateOneWithoutRecordedAttendancesNestedInput
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceDailyUncheckedUpdateInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailyCreateManyInput = {
    attendanceId?: bigint | number
    userId: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    recordedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type AttendanceDailyUpdateManyMutationInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailyUncheckedUpdateManyInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPeriodCreateInput = {
    periodId?: bigint | number
    year: number
    month: number
    startDate: Date | string
    endDate: Date | string
    status?: string
    salaryRecords?: SalaryRecordCreateNestedManyWithoutPeriodInput
  }

  export type SalaryPeriodUncheckedCreateInput = {
    periodId?: bigint | number
    year: number
    month: number
    startDate: Date | string
    endDate: Date | string
    status?: string
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type SalaryPeriodUpdateInput = {
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    salaryRecords?: SalaryRecordUpdateManyWithoutPeriodNestedInput
  }

  export type SalaryPeriodUncheckedUpdateInput = {
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type SalaryPeriodCreateManyInput = {
    periodId?: bigint | number
    year: number
    month: number
    startDate: Date | string
    endDate: Date | string
    status?: string
  }

  export type SalaryPeriodUpdateManyMutationInput = {
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPeriodUncheckedUpdateManyInput = {
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryRecordCreateInput = {
    salaryRecordId?: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    payments?: SalaryPaymentCreateNestedManyWithoutSalaryRecordInput
    period: SalaryPeriodCreateNestedOneWithoutSalaryRecordsInput
    user: UserCreateNestedOneWithoutSalaryRecordsInput
  }

  export type SalaryRecordUncheckedCreateInput = {
    salaryRecordId?: bigint | number
    periodId: bigint | number
    userId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    payments?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryRecordInput
  }

  export type SalaryRecordUpdateInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: SalaryPaymentUpdateManyWithoutSalaryRecordNestedInput
    period?: SalaryPeriodUpdateOneRequiredWithoutSalaryRecordsNestedInput
    user?: UserUpdateOneRequiredWithoutSalaryRecordsNestedInput
  }

  export type SalaryRecordUncheckedUpdateInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: SalaryPaymentUncheckedUpdateManyWithoutSalaryRecordNestedInput
  }

  export type SalaryRecordCreateManyInput = {
    salaryRecordId?: bigint | number
    periodId: bigint | number
    userId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type SalaryRecordUpdateManyMutationInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryRecordUncheckedUpdateManyInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPaymentCreateInput = {
    salaryPaymentId?: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    createdAt?: Date | string
    payer?: UserCreateNestedOneWithoutSalaryPaymentsPaidInput
    salaryRecord: SalaryRecordCreateNestedOneWithoutPaymentsInput
  }

  export type SalaryPaymentUncheckedCreateInput = {
    salaryPaymentId?: bigint | number
    salaryRecordId: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    paidBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalaryPaymentUpdateInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payer?: UserUpdateOneWithoutSalaryPaymentsPaidNestedInput
    salaryRecord?: SalaryRecordUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SalaryPaymentUncheckedUpdateInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentCreateManyInput = {
    salaryPaymentId?: bigint | number
    salaryRecordId: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    paidBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalaryPaymentUpdateManyMutationInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    unitName: string
    symbol?: string | null
    items?: ItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    unitId?: number
    unitName: string
    symbol?: string | null
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    unitId?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    unitId?: number
    unitName: string
    symbol?: string | null
  }

  export type UnitUpdateManyMutationInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitUncheckedUpdateManyInput = {
    unitId?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCategoryCreateInput = {
    categoryName: string
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    categoryId?: number
    categoryName: string
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUpdateInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    categoryId?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    categoryId?: number
    categoryName: string
  }

  export type ItemCategoryUpdateManyMutationInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    categoryId?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
  }

  export type SupplierUpdateManyMutationInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerCreateInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    itemPrices?: CustomerItemPriceCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    itemPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemPrices?: CustomerItemPriceUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemPrices?: CustomerItemPriceUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
  }

  export type CustomerUpdateManyMutationInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SupplierItemPriceCreateInput = {
    supplierItemPriceId?: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    item: ItemCreateNestedOneWithoutSupplierPricesInput
    supplier: SupplierCreateNestedOneWithoutItemPricesInput
  }

  export type SupplierItemPriceUncheckedCreateInput = {
    supplierItemPriceId?: bigint | number
    supplierId: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type SupplierItemPriceUpdateInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    item?: ItemUpdateOneRequiredWithoutSupplierPricesNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutItemPricesNestedInput
  }

  export type SupplierItemPriceUncheckedUpdateInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SupplierItemPriceCreateManyInput = {
    supplierItemPriceId?: bigint | number
    supplierId: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type SupplierItemPriceUpdateManyMutationInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SupplierItemPriceUncheckedUpdateManyInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerItemPriceCreateInput = {
    customerItemPriceId?: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    customer: CustomerCreateNestedOneWithoutItemPricesInput
    item: ItemCreateNestedOneWithoutCustomerPricesInput
  }

  export type CustomerItemPriceUncheckedCreateInput = {
    customerItemPriceId?: bigint | number
    customerId: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type CustomerItemPriceUpdateInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customer?: CustomerUpdateOneRequiredWithoutItemPricesNestedInput
    item?: ItemUpdateOneRequiredWithoutCustomerPricesNestedInput
  }

  export type CustomerItemPriceUncheckedUpdateInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerItemPriceCreateManyInput = {
    customerItemPriceId?: bigint | number
    customerId: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type CustomerItemPriceUpdateManyMutationInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerItemPriceUncheckedUpdateManyInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PurchaseOrderCreateInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    creator?: UserCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    stockMovements?: StockMovementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    creator?: UserUpdateOneWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    stockMovements?: StockMovementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderLineCreateInput = {
    purchaseLineId?: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
    item: ItemCreateNestedOneWithoutPurchaseOrderLinesInput
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateInput = {
    purchaseLineId?: bigint | number
    purchaseId: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
  }

  export type PurchaseOrderLineUpdateInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    item?: ItemUpdateOneRequiredWithoutPurchaseOrderLinesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PurchaseOrderLineCreateManyInput = {
    purchaseLineId?: bigint | number
    purchaseId: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
  }

  export type PurchaseOrderLineUpdateManyMutationInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PurchaseOrderLineUncheckedUpdateManyInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SalesOrderCreateInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    dispatches?: DispatchCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    creator?: UserCreateNestedOneWithoutSalesOrdersInput
    customer: CustomerCreateNestedOneWithoutSalesOrdersInput
  }

  export type SalesOrderUncheckedCreateInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
    dispatches?: DispatchUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderUpdateInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    creator?: UserUpdateOneWithoutSalesOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type SalesOrderCreateManyInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalesOrderUpdateManyMutationInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUncheckedUpdateManyInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderLineCreateInput = {
    salesOrderLineId?: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutSalesOrderLinesInput
    salesOrder: SalesOrderCreateNestedOneWithoutLinesInput
  }

  export type SalesOrderLineUncheckedCreateInput = {
    salesOrderLineId?: bigint | number
    salesOrderId: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutSalesOrderLinesNestedInput
    salesOrder?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateManyInput = {
    salesOrderLineId?: bigint | number
    salesOrderId: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateManyMutationInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DispatchCreateInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutDispatchesInput
    salesOrder: SalesOrderCreateNestedOneWithoutDispatchesInput
  }

  export type DispatchUncheckedCreateInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    salesOrderId: bigint | number
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type DispatchUpdateInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutDispatchesNestedInput
    salesOrder?: SalesOrderUpdateOneRequiredWithoutDispatchesNestedInput
  }

  export type DispatchUncheckedUpdateInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchCreateManyInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    salesOrderId: bigint | number
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type DispatchUpdateManyMutationInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchUncheckedUpdateManyInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayCreateInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
    closer?: UserCreateNestedOneWithoutProductionDaysClosedInput
    creator?: UserCreateNestedOneWithoutProductionDaysCreatedInput
    finishedProduct: ItemCreateNestedOneWithoutProductionDaysInput
    reopener?: UserCreateNestedOneWithoutProductionDaysReopenedInput
  }

  export type ProductionDayUncheckedCreateInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ProductionDayUpdateInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closer?: UserUpdateOneWithoutProductionDaysClosedNestedInput
    creator?: UserUpdateOneWithoutProductionDaysCreatedNestedInput
    finishedProduct?: ItemUpdateOneRequiredWithoutProductionDaysNestedInput
    reopener?: UserUpdateOneWithoutProductionDaysReopenedNestedInput
  }

  export type ProductionDayUncheckedUpdateInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayCreateManyInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ProductionDayUpdateManyMutationInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUncheckedUpdateManyInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    notes?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutStockMovementsInput
    item: ItemCreateNestedOneWithoutStockMovementsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    itemId: bigint | number
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    purchaseId?: bigint | number | null
    notes?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutStockMovementsNestedInput
    item?: ItemUpdateOneRequiredWithoutStockMovementsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    itemId: bigint | number
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    purchaseId?: bigint | number | null
    notes?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockBalanceCreateInput = {
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutStockBalanceInput
  }

  export type StockBalanceUncheckedCreateInput = {
    itemId: bigint | number
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type StockBalanceUpdateInput = {
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutStockBalanceNestedInput
  }

  export type StockBalanceUncheckedUpdateInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockBalanceCreateManyInput = {
    itemId: bigint | number
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type StockBalanceUpdateManyMutationInput = {
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockBalanceUncheckedUpdateManyInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateInput = {
    invoiceLineId?: bigint | number
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
    item?: ItemCreateNestedOneWithoutInvoiceLinesInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    invoiceLineId?: bigint | number
    invoiceId: bigint | number
    itemId?: bigint | number | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUpdateInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneWithoutInvoiceLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineCreateManyInput = {
    invoiceLineId?: bigint | number
    invoiceId: bigint | number
    itemId?: bigint | number | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUpdateManyMutationInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateInput = {
    paymentId?: bigint | number
    paymentNo: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    receiver?: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    paymentId?: bigint | number
    paymentNo: string
    invoiceId: bigint | number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    receivedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    receiver?: UserUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    paymentId?: bigint | number
    paymentNo: string
    invoiceId: bigint | number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    receivedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutExpensesInput
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    supplierId?: bigint | number | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutExpensesNestedInput
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    supplierId?: bigint | number | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionCreateInput = {
    txId?: bigint | number
    txDate?: Date | string
    txType: $Enums.TxType
    sourceModule?: string | null
    refTable?: string | null
    refId?: bigint | number | null
    amountIn?: Decimal | DecimalJsLike | number | string
    amountOut?: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    note?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateInput = {
    txId?: bigint | number
    txDate?: Date | string
    txType: $Enums.TxType
    sourceModule?: string | null
    refTable?: string | null
    refId?: bigint | number | null
    amountIn?: Decimal | DecimalJsLike | number | string
    amountOut?: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    note?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type CashTransactionUpdateInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionCreateManyInput = {
    txId?: bigint | number
    txDate?: Date | string
    txType: $Enums.TxType
    sourceModule?: string | null
    refTable?: string | null
    refId?: bigint | number | null
    amountIn?: Decimal | DecimalJsLike | number | string
    amountOut?: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    note?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type CashTransactionUpdateManyMutationInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    idPrefix?: SortOrder
    description?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    idPrefix?: SortOrder
    description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    roleId?: SortOrder
    roleName?: SortOrder
    idPrefix?: SortOrder
    description?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AttendanceDailyListRelationFilter = {
    every?: AttendanceDailyWhereInput
    some?: AttendanceDailyWhereInput
    none?: AttendanceDailyWhereInput
  }

  export type CashTransactionListRelationFilter = {
    every?: CashTransactionWhereInput
    some?: CashTransactionWhereInput
    none?: CashTransactionWhereInput
  }

  export type DispatchListRelationFilter = {
    every?: DispatchWhereInput
    some?: DispatchWhereInput
    none?: DispatchWhereInput
  }

  export type EmployeeProfileNullableRelationFilter = {
    is?: EmployeeProfileWhereInput | null
    isNot?: EmployeeProfileWhereInput | null
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ProductionDayListRelationFilter = {
    every?: ProductionDayWhereInput
    some?: ProductionDayWhereInput
    none?: ProductionDayWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type SalaryPaymentListRelationFilter = {
    every?: SalaryPaymentWhereInput
    some?: SalaryPaymentWhereInput
    none?: SalaryPaymentWhereInput
  }

  export type SalaryRecordListRelationFilter = {
    every?: SalaryRecordWhereInput
    some?: SalaryRecordWhereInput
    none?: SalaryRecordWhereInput
  }

  export type SalesOrderListRelationFilter = {
    every?: SalesOrderWhereInput
    some?: SalesOrderWhereInput
    none?: SalesOrderWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type AttendanceDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    userId?: SortOrder
    userCode?: SortOrder
    roleId?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    userId?: SortOrder
    userCode?: SortOrder
    roleId?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    userId?: SortOrder
    userCode?: SortOrder
    roleId?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EmployeeProfileListRelationFilter = {
    every?: EmployeeProfileWhereInput
    some?: EmployeeProfileWhereInput
    none?: EmployeeProfileWhereInput
  }

  export type EmployeeProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryRangeCountOrderByAggregateInput = {
    salaryRangeId?: SortOrder
    rangeName?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryRangeAvgOrderByAggregateInput = {
    salaryRangeId?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
  }

  export type SalaryRangeMaxOrderByAggregateInput = {
    salaryRangeId?: SortOrder
    rangeName?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryRangeMinOrderByAggregateInput = {
    salaryRangeId?: SortOrder
    rangeName?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryRangeSumOrderByAggregateInput = {
    salaryRangeId?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type SalaryRangeNullableRelationFilter = {
    is?: SalaryRangeWhereInput | null
    isNot?: SalaryRangeWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    nic?: SortOrder
    address?: SortOrder
    joinedDate?: SortOrder
    designation?: SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrder
    otRate?: SortOrder
    notes?: SortOrder
  }

  export type EmployeeProfileAvgOrderByAggregateInput = {
    userId?: SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrder
    otRate?: SortOrder
  }

  export type EmployeeProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    nic?: SortOrder
    address?: SortOrder
    joinedDate?: SortOrder
    designation?: SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrder
    otRate?: SortOrder
    notes?: SortOrder
  }

  export type EmployeeProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    nic?: SortOrder
    address?: SortOrder
    joinedDate?: SortOrder
    designation?: SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrder
    otRate?: SortOrder
    notes?: SortOrder
  }

  export type EmployeeProfileSumOrderByAggregateInput = {
    userId?: SortOrder
    basicSalary?: SortOrder
    salaryRangeId?: SortOrder
    otRate?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AttendanceDailyUserIdWorkDateCompoundUniqueInput = {
    userId: bigint | number
    workDate: Date | string
  }

  export type AttendanceDailyCountOrderByAggregateInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    workDate?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    remarks?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceDailyAvgOrderByAggregateInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    recordedBy?: SortOrder
  }

  export type AttendanceDailyMaxOrderByAggregateInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    workDate?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    remarks?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceDailyMinOrderByAggregateInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    workDate?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    remarks?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceDailySumOrderByAggregateInput = {
    attendanceId?: SortOrder
    userId?: SortOrder
    systemHours?: SortOrder
    systemOtHours?: SortOrder
    manualOtHours?: SortOrder
    recordedBy?: SortOrder
  }

  export type SalaryPeriodYearMonthCompoundUniqueInput = {
    year: number
    month: number
  }

  export type SalaryPeriodCountOrderByAggregateInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type SalaryPeriodAvgOrderByAggregateInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
  }

  export type SalaryPeriodMaxOrderByAggregateInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type SalaryPeriodMinOrderByAggregateInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type SalaryPeriodSumOrderByAggregateInput = {
    periodId?: SortOrder
    year?: SortOrder
    month?: SortOrder
  }

  export type SalaryPeriodRelationFilter = {
    is?: SalaryPeriodWhereInput
    isNot?: SalaryPeriodWhereInput
  }

  export type SalaryRecordPeriodIdUserIdCompoundUniqueInput = {
    periodId: bigint | number
    userId: bigint | number
  }

  export type SalaryRecordCountOrderByAggregateInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
    status?: SortOrder
  }

  export type SalaryRecordAvgOrderByAggregateInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
  }

  export type SalaryRecordMaxOrderByAggregateInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
    status?: SortOrder
  }

  export type SalaryRecordMinOrderByAggregateInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
    status?: SortOrder
  }

  export type SalaryRecordSumOrderByAggregateInput = {
    salaryRecordId?: SortOrder
    periodId?: SortOrder
    userId?: SortOrder
    baseSalary?: SortOrder
    otHours?: SortOrder
    otAmount?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    totalPay?: SortOrder
  }

  export type EnumPayMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PayMethod | EnumPayMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayMethodFilter<$PrismaModel> | $Enums.PayMethod
  }

  export type SalaryRecordRelationFilter = {
    is?: SalaryRecordWhereInput
    isNot?: SalaryRecordWhereInput
  }

  export type SalaryPaymentCountOrderByAggregateInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    payDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrder
    paidBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryPaymentAvgOrderByAggregateInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    amount?: SortOrder
    paidBy?: SortOrder
  }

  export type SalaryPaymentMaxOrderByAggregateInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    payDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrder
    paidBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryPaymentMinOrderByAggregateInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    payDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrder
    paidBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SalaryPaymentSumOrderByAggregateInput = {
    salaryPaymentId?: SortOrder
    salaryRecordId?: SortOrder
    amount?: SortOrder
    paidBy?: SortOrder
  }

  export type EnumPayMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayMethod | EnumPayMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayMethodWithAggregatesFilter<$PrismaModel> | $Enums.PayMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayMethodFilter<$PrismaModel>
    _max?: NestedEnumPayMethodFilter<$PrismaModel>
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    unitId?: SortOrder
    unitName?: SortOrder
    symbol?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    unitId?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    unitId?: SortOrder
    unitName?: SortOrder
    symbol?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    unitId?: SortOrder
    unitName?: SortOrder
    symbol?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    unitId?: SortOrder
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    categoryId?: SortOrder
    categoryName?: SortOrder
  }

  export type ItemCategoryAvgOrderByAggregateInput = {
    categoryId?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    categoryId?: SortOrder
    categoryName?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    categoryId?: SortOrder
    categoryName?: SortOrder
  }

  export type ItemCategorySumOrderByAggregateInput = {
    categoryId?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerItemPriceListRelationFilter = {
    every?: CustomerItemPriceWhereInput
    some?: CustomerItemPriceWhereInput
    none?: CustomerItemPriceWhereInput
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type ItemCategoryNullableRelationFilter = {
    is?: ItemCategoryWhereInput | null
    isNot?: ItemCategoryWhereInput | null
  }

  export type UnitNullableRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type PurchaseOrderLineListRelationFilter = {
    every?: PurchaseOrderLineWhereInput
    some?: PurchaseOrderLineWhereInput
    none?: PurchaseOrderLineWhereInput
  }

  export type SalesOrderLineListRelationFilter = {
    every?: SalesOrderLineWhereInput
    some?: SalesOrderLineWhereInput
    none?: SalesOrderLineWhereInput
  }

  export type StockBalanceNullableRelationFilter = {
    is?: StockBalanceWhereInput | null
    isNot?: StockBalanceWhereInput | null
  }

  export type SupplierItemPriceListRelationFilter = {
    every?: SupplierItemPriceWhereInput
    some?: SupplierItemPriceWhereInput
    none?: SupplierItemPriceWhereInput
  }

  export type CustomerItemPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierItemPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemItemNameItemTypeCompoundUniqueInput = {
    itemName: string
    itemType: $Enums.ItemType
  }

  export type ItemCountOrderByAggregateInput = {
    itemId?: SortOrder
    itemCode?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    itemId?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    itemId?: SortOrder
    itemCode?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    itemId?: SortOrder
    itemCode?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    itemId?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SupplierCountOrderByAggregateInput = {
    supplierId?: SortOrder
    supplierCode?: SortOrder
    supplierName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    supplierId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    supplierId?: SortOrder
    supplierCode?: SortOrder
    supplierName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    supplierId?: SortOrder
    supplierCode?: SortOrder
    supplierName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    supplierId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    customerId?: SortOrder
    customerCode?: SortOrder
    customerName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    customerId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    customerId?: SortOrder
    customerCode?: SortOrder
    customerName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    customerId?: SortOrder
    customerCode?: SortOrder
    customerName?: SortOrder
    contactName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedAt?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    customerId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deactivatedBy?: SortOrder
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierItemPriceSupplierIdItemIdEffectiveFromCompoundUniqueInput = {
    supplierId: bigint | number
    itemId: bigint | number
    effectiveFrom: Date | string
  }

  export type SupplierItemPriceCountOrderByAggregateInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SupplierItemPriceAvgOrderByAggregateInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SupplierItemPriceMaxOrderByAggregateInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SupplierItemPriceMinOrderByAggregateInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type SupplierItemPriceSumOrderByAggregateInput = {
    supplierItemPriceId?: SortOrder
    supplierId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerItemPriceCustomerIdItemIdEffectiveFromCompoundUniqueInput = {
    customerId: bigint | number
    itemId: bigint | number
    effectiveFrom: Date | string
  }

  export type CustomerItemPriceCountOrderByAggregateInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomerItemPriceAvgOrderByAggregateInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomerItemPriceMaxOrderByAggregateInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomerItemPriceMinOrderByAggregateInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    effectiveFrom?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type CustomerItemPriceSumOrderByAggregateInput = {
    customerItemPriceId?: SortOrder
    customerId?: SortOrder
    itemId?: SortOrder
    unitPrice?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumDocStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusFilter<$PrismaModel> | $Enums.DocStatus
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    purchaseId?: SortOrder
    purchaseNo?: SortOrder
    supplierId?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
    receivedAt?: SortOrder
    receivedBy?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    cancelReason?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    purchaseId?: SortOrder
    supplierId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    confirmedBy?: SortOrder
    receivedBy?: SortOrder
    cancelledBy?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    purchaseId?: SortOrder
    purchaseNo?: SortOrder
    supplierId?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
    receivedAt?: SortOrder
    receivedBy?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    cancelReason?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    purchaseId?: SortOrder
    purchaseNo?: SortOrder
    supplierId?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
    receivedAt?: SortOrder
    receivedBy?: SortOrder
    cancelledAt?: SortOrder
    cancelledBy?: SortOrder
    cancelReason?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    purchaseId?: SortOrder
    supplierId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    confirmedBy?: SortOrder
    receivedBy?: SortOrder
    cancelledBy?: SortOrder
  }

  export type EnumDocStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocStatusFilter<$PrismaModel>
    _max?: NestedEnumDocStatusFilter<$PrismaModel>
  }

  export type PurchaseOrderRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderLineCountOrderByAggregateInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    priceSource?: SortOrder
    overrideReason?: SortOrder
    overriddenBy?: SortOrder
  }

  export type PurchaseOrderLineAvgOrderByAggregateInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    overriddenBy?: SortOrder
  }

  export type PurchaseOrderLineMaxOrderByAggregateInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    priceSource?: SortOrder
    overrideReason?: SortOrder
    overriddenBy?: SortOrder
  }

  export type PurchaseOrderLineMinOrderByAggregateInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    priceSource?: SortOrder
    overrideReason?: SortOrder
    overriddenBy?: SortOrder
  }

  export type PurchaseOrderLineSumOrderByAggregateInput = {
    purchaseLineId?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    overriddenBy?: SortOrder
  }

  export type SalesOrderCountOrderByAggregateInput = {
    salesOrderId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    isEditedAfterConfirm?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesOrderAvgOrderByAggregateInput = {
    salesOrderId?: SortOrder
    customerId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
  }

  export type SalesOrderMaxOrderByAggregateInput = {
    salesOrderId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    isEditedAfterConfirm?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesOrderMinOrderByAggregateInput = {
    salesOrderId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    isEditedAfterConfirm?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesOrderSumOrderByAggregateInput = {
    salesOrderId?: SortOrder
    customerId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    createdBy?: SortOrder
  }

  export type SalesOrderRelationFilter = {
    is?: SalesOrderWhereInput
    isNot?: SalesOrderWhereInput
  }

  export type SalesOrderLineCountOrderByAggregateInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineAvgOrderByAggregateInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineMaxOrderByAggregateInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineMinOrderByAggregateInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineSumOrderByAggregateInput = {
    salesOrderLineId?: SortOrder
    salesOrderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type DispatchCountOrderByAggregateInput = {
    dispatchId?: SortOrder
    dispatchNo?: SortOrder
    salesOrderId?: SortOrder
    dispatchDate?: SortOrder
    vehicleNo?: SortOrder
    driverName?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DispatchAvgOrderByAggregateInput = {
    dispatchId?: SortOrder
    salesOrderId?: SortOrder
    createdBy?: SortOrder
  }

  export type DispatchMaxOrderByAggregateInput = {
    dispatchId?: SortOrder
    dispatchNo?: SortOrder
    salesOrderId?: SortOrder
    dispatchDate?: SortOrder
    vehicleNo?: SortOrder
    driverName?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DispatchMinOrderByAggregateInput = {
    dispatchId?: SortOrder
    dispatchNo?: SortOrder
    salesOrderId?: SortOrder
    dispatchDate?: SortOrder
    vehicleNo?: SortOrder
    driverName?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DispatchSumOrderByAggregateInput = {
    dispatchId?: SortOrder
    salesOrderId?: SortOrder
    createdBy?: SortOrder
  }

  export type ProductionDayProductionDateFinishedProductIdCompoundUniqueInput = {
    productionDate: Date | string
    finishedProductId: bigint | number
  }

  export type ProductionDayCountOrderByAggregateInput = {
    productionDayId?: SortOrder
    productionDate?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    notes?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    reopenReason?: SortOrder
    reopenedBy?: SortOrder
    reopenedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionDayAvgOrderByAggregateInput = {
    productionDayId?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    closedBy?: SortOrder
    reopenedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type ProductionDayMaxOrderByAggregateInput = {
    productionDayId?: SortOrder
    productionDate?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    notes?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    reopenReason?: SortOrder
    reopenedBy?: SortOrder
    reopenedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionDayMinOrderByAggregateInput = {
    productionDayId?: SortOrder
    productionDate?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    notes?: SortOrder
    isClosed?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    reopenReason?: SortOrder
    reopenedBy?: SortOrder
    reopenedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionDaySumOrderByAggregateInput = {
    productionDayId?: SortOrder
    finishedProductId?: SortOrder
    quantity?: SortOrder
    scrapQuantity?: SortOrder
    closedBy?: SortOrder
    reopenedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type PurchaseOrderNullableRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type StockMovementCountOrderByAggregateInput = {
    stockMovementId?: SortOrder
    movementDate?: SortOrder
    movementType?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refTable?: SortOrder
    refId?: SortOrder
    purchaseId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    stockMovementId?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refId?: SortOrder
    purchaseId?: SortOrder
    createdBy?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    stockMovementId?: SortOrder
    movementDate?: SortOrder
    movementType?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refTable?: SortOrder
    refId?: SortOrder
    purchaseId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    stockMovementId?: SortOrder
    movementDate?: SortOrder
    movementType?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refTable?: SortOrder
    refId?: SortOrder
    purchaseId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    stockMovementId?: SortOrder
    itemId?: SortOrder
    qtyIn?: SortOrder
    qtyOut?: SortOrder
    unitCost?: SortOrder
    refId?: SortOrder
    purchaseId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type StockBalanceCountOrderByAggregateInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockBalanceAvgOrderByAggregateInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
  }

  export type StockBalanceMaxOrderByAggregateInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockBalanceMinOrderByAggregateInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockBalanceSumOrderByAggregateInput = {
    itemId?: SortOrder
    qtyOnHand?: SortOrder
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SalesOrderNullableRelationFilter = {
    is?: SalesOrderWhereInput | null
    isNot?: SalesOrderWhereInput | null
  }

  export type SupplierNullableRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    invoiceId?: SortOrder
    invoiceNo?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    salesOrderId?: SortOrder
    purchaseId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    printTemplate?: SortOrder
    vendorInvoiceNo?: SortOrder
    vendorInvoiceDate?: SortOrder
    vendorInvoiceTotal?: SortOrder
    matchStatus?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrder
    matchCheckedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    invoiceId?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    salesOrderId?: SortOrder
    purchaseId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    vendorInvoiceTotal?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    invoiceId?: SortOrder
    invoiceNo?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    salesOrderId?: SortOrder
    purchaseId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    printTemplate?: SortOrder
    vendorInvoiceNo?: SortOrder
    vendorInvoiceDate?: SortOrder
    vendorInvoiceTotal?: SortOrder
    matchStatus?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrder
    matchCheckedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    invoiceId?: SortOrder
    invoiceNo?: SortOrder
    invoiceType?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    salesOrderId?: SortOrder
    purchaseId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    status?: SortOrder
    printTemplate?: SortOrder
    vendorInvoiceNo?: SortOrder
    vendorInvoiceDate?: SortOrder
    vendorInvoiceTotal?: SortOrder
    matchStatus?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrder
    matchCheckedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    invoiceId?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    salesOrderId?: SortOrder
    purchaseId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    vendorInvoiceTotal?: SortOrder
    mismatchAmount?: SortOrder
    matchCheckedBy?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type ItemNullableRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    invoiceLineId?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    paymentId?: SortOrder
    paymentNo?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrder
    notes?: SortOrder
    receivedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    receivedBy?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    paymentId?: SortOrder
    paymentNo?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrder
    notes?: SortOrder
    receivedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    paymentId?: SortOrder
    paymentNo?: SortOrder
    invoiceId?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    referenceNo?: SortOrder
    notes?: SortOrder
    receivedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    paymentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    receivedBy?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    expenseId?: SortOrder
    expenseNo?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paidTo?: SortOrder
    supplierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    expenseId?: SortOrder
    amount?: SortOrder
    supplierId?: SortOrder
    createdBy?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    expenseId?: SortOrder
    expenseNo?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paidTo?: SortOrder
    supplierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    expenseId?: SortOrder
    expenseNo?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    paidTo?: SortOrder
    supplierId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    expenseId?: SortOrder
    amount?: SortOrder
    supplierId?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeFilter<$PrismaModel> | $Enums.TxType
  }

  export type CashTransactionCountOrderByAggregateInput = {
    txId?: SortOrder
    txDate?: SortOrder
    txType?: SortOrder
    sourceModule?: SortOrder
    refTable?: SortOrder
    refId?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    method?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CashTransactionAvgOrderByAggregateInput = {
    txId?: SortOrder
    refId?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    createdBy?: SortOrder
  }

  export type CashTransactionMaxOrderByAggregateInput = {
    txId?: SortOrder
    txDate?: SortOrder
    txType?: SortOrder
    sourceModule?: SortOrder
    refTable?: SortOrder
    refId?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    method?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CashTransactionMinOrderByAggregateInput = {
    txId?: SortOrder
    txDate?: SortOrder
    txType?: SortOrder
    sourceModule?: SortOrder
    refTable?: SortOrder
    refId?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    method?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CashTransactionSumOrderByAggregateInput = {
    txId?: SortOrder
    refId?: SortOrder
    amountIn?: SortOrder
    amountOut?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxTypeFilter<$PrismaModel>
    _max?: NestedEnumTxTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AttendanceDailyCreateNestedManyWithoutRecorderInput = {
    create?: XOR<AttendanceDailyCreateWithoutRecorderInput, AttendanceDailyUncheckedCreateWithoutRecorderInput> | AttendanceDailyCreateWithoutRecorderInput[] | AttendanceDailyUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutRecorderInput | AttendanceDailyCreateOrConnectWithoutRecorderInput[]
    createMany?: AttendanceDailyCreateManyRecorderInputEnvelope
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
  }

  export type AttendanceDailyCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceDailyCreateWithoutUserInput, AttendanceDailyUncheckedCreateWithoutUserInput> | AttendanceDailyCreateWithoutUserInput[] | AttendanceDailyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutUserInput | AttendanceDailyCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceDailyCreateManyUserInputEnvelope
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CashTransactionCreateWithoutCreatorInput, CashTransactionUncheckedCreateWithoutCreatorInput> | CashTransactionCreateWithoutCreatorInput[] | CashTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatorInput | CashTransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: CashTransactionCreateManyCreatorInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type DispatchCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DispatchCreateWithoutCreatorInput, DispatchUncheckedCreateWithoutCreatorInput> | DispatchCreateWithoutCreatorInput[] | DispatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutCreatorInput | DispatchCreateOrConnectWithoutCreatorInput[]
    createMany?: DispatchCreateManyCreatorInputEnvelope
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
  }

  export type EmployeeProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type ExpenseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutMatchCheckerInput = {
    create?: XOR<InvoiceCreateWithoutMatchCheckerInput, InvoiceUncheckedCreateWithoutMatchCheckerInput> | InvoiceCreateWithoutMatchCheckerInput[] | InvoiceUncheckedCreateWithoutMatchCheckerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMatchCheckerInput | InvoiceCreateOrConnectWithoutMatchCheckerInput[]
    createMany?: InvoiceCreateManyMatchCheckerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PaymentCreateWithoutReceiverInput, PaymentUncheckedCreateWithoutReceiverInput> | PaymentCreateWithoutReceiverInput[] | PaymentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiverInput | PaymentCreateOrConnectWithoutReceiverInput[]
    createMany?: PaymentCreateManyReceiverInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProductionDayCreateNestedManyWithoutCloserInput = {
    create?: XOR<ProductionDayCreateWithoutCloserInput, ProductionDayUncheckedCreateWithoutCloserInput> | ProductionDayCreateWithoutCloserInput[] | ProductionDayUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCloserInput | ProductionDayCreateOrConnectWithoutCloserInput[]
    createMany?: ProductionDayCreateManyCloserInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type ProductionDayCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductionDayCreateWithoutCreatorInput, ProductionDayUncheckedCreateWithoutCreatorInput> | ProductionDayCreateWithoutCreatorInput[] | ProductionDayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCreatorInput | ProductionDayCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductionDayCreateManyCreatorInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type ProductionDayCreateNestedManyWithoutReopenerInput = {
    create?: XOR<ProductionDayCreateWithoutReopenerInput, ProductionDayUncheckedCreateWithoutReopenerInput> | ProductionDayCreateWithoutReopenerInput[] | ProductionDayUncheckedCreateWithoutReopenerInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutReopenerInput | ProductionDayCreateOrConnectWithoutReopenerInput[]
    createMany?: ProductionDayCreateManyReopenerInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalaryPaymentCreateNestedManyWithoutPayerInput = {
    create?: XOR<SalaryPaymentCreateWithoutPayerInput, SalaryPaymentUncheckedCreateWithoutPayerInput> | SalaryPaymentCreateWithoutPayerInput[] | SalaryPaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutPayerInput | SalaryPaymentCreateOrConnectWithoutPayerInput[]
    createMany?: SalaryPaymentCreateManyPayerInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type SalaryRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SalesOrderCreateWithoutCreatorInput, SalesOrderUncheckedCreateWithoutCreatorInput> | SalesOrderCreateWithoutCreatorInput[] | SalesOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCreatorInput | SalesOrderCreateOrConnectWithoutCreatorInput[]
    createMany?: SalesOrderCreateManyCreatorInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput = {
    create?: XOR<AttendanceDailyCreateWithoutRecorderInput, AttendanceDailyUncheckedCreateWithoutRecorderInput> | AttendanceDailyCreateWithoutRecorderInput[] | AttendanceDailyUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutRecorderInput | AttendanceDailyCreateOrConnectWithoutRecorderInput[]
    createMany?: AttendanceDailyCreateManyRecorderInputEnvelope
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
  }

  export type AttendanceDailyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceDailyCreateWithoutUserInput, AttendanceDailyUncheckedCreateWithoutUserInput> | AttendanceDailyCreateWithoutUserInput[] | AttendanceDailyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutUserInput | AttendanceDailyCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceDailyCreateManyUserInputEnvelope
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CashTransactionCreateWithoutCreatorInput, CashTransactionUncheckedCreateWithoutCreatorInput> | CashTransactionCreateWithoutCreatorInput[] | CashTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatorInput | CashTransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: CashTransactionCreateManyCreatorInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type DispatchUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DispatchCreateWithoutCreatorInput, DispatchUncheckedCreateWithoutCreatorInput> | DispatchCreateWithoutCreatorInput[] | DispatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutCreatorInput | DispatchCreateOrConnectWithoutCreatorInput[]
    createMany?: DispatchCreateManyCreatorInputEnvelope
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput = {
    create?: XOR<InvoiceCreateWithoutMatchCheckerInput, InvoiceUncheckedCreateWithoutMatchCheckerInput> | InvoiceCreateWithoutMatchCheckerInput[] | InvoiceUncheckedCreateWithoutMatchCheckerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMatchCheckerInput | InvoiceCreateOrConnectWithoutMatchCheckerInput[]
    createMany?: InvoiceCreateManyMatchCheckerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<PaymentCreateWithoutReceiverInput, PaymentUncheckedCreateWithoutReceiverInput> | PaymentCreateWithoutReceiverInput[] | PaymentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiverInput | PaymentCreateOrConnectWithoutReceiverInput[]
    createMany?: PaymentCreateManyReceiverInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProductionDayUncheckedCreateNestedManyWithoutCloserInput = {
    create?: XOR<ProductionDayCreateWithoutCloserInput, ProductionDayUncheckedCreateWithoutCloserInput> | ProductionDayCreateWithoutCloserInput[] | ProductionDayUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCloserInput | ProductionDayCreateOrConnectWithoutCloserInput[]
    createMany?: ProductionDayCreateManyCloserInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type ProductionDayUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProductionDayCreateWithoutCreatorInput, ProductionDayUncheckedCreateWithoutCreatorInput> | ProductionDayCreateWithoutCreatorInput[] | ProductionDayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCreatorInput | ProductionDayCreateOrConnectWithoutCreatorInput[]
    createMany?: ProductionDayCreateManyCreatorInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type ProductionDayUncheckedCreateNestedManyWithoutReopenerInput = {
    create?: XOR<ProductionDayCreateWithoutReopenerInput, ProductionDayUncheckedCreateWithoutReopenerInput> | ProductionDayCreateWithoutReopenerInput[] | ProductionDayUncheckedCreateWithoutReopenerInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutReopenerInput | ProductionDayCreateOrConnectWithoutReopenerInput[]
    createMany?: ProductionDayCreateManyReopenerInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput = {
    create?: XOR<SalaryPaymentCreateWithoutPayerInput, SalaryPaymentUncheckedCreateWithoutPayerInput> | SalaryPaymentCreateWithoutPayerInput[] | SalaryPaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutPayerInput | SalaryPaymentCreateOrConnectWithoutPayerInput[]
    createMany?: SalaryPaymentCreateManyPayerInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type SalaryRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SalesOrderCreateWithoutCreatorInput, SalesOrderUncheckedCreateWithoutCreatorInput> | SalesOrderCreateWithoutCreatorInput[] | SalesOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCreatorInput | SalesOrderCreateOrConnectWithoutCreatorInput[]
    createMany?: SalesOrderCreateManyCreatorInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AttendanceDailyUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<AttendanceDailyCreateWithoutRecorderInput, AttendanceDailyUncheckedCreateWithoutRecorderInput> | AttendanceDailyCreateWithoutRecorderInput[] | AttendanceDailyUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutRecorderInput | AttendanceDailyCreateOrConnectWithoutRecorderInput[]
    upsert?: AttendanceDailyUpsertWithWhereUniqueWithoutRecorderInput | AttendanceDailyUpsertWithWhereUniqueWithoutRecorderInput[]
    createMany?: AttendanceDailyCreateManyRecorderInputEnvelope
    set?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    disconnect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    delete?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    update?: AttendanceDailyUpdateWithWhereUniqueWithoutRecorderInput | AttendanceDailyUpdateWithWhereUniqueWithoutRecorderInput[]
    updateMany?: AttendanceDailyUpdateManyWithWhereWithoutRecorderInput | AttendanceDailyUpdateManyWithWhereWithoutRecorderInput[]
    deleteMany?: AttendanceDailyScalarWhereInput | AttendanceDailyScalarWhereInput[]
  }

  export type AttendanceDailyUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceDailyCreateWithoutUserInput, AttendanceDailyUncheckedCreateWithoutUserInput> | AttendanceDailyCreateWithoutUserInput[] | AttendanceDailyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutUserInput | AttendanceDailyCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceDailyUpsertWithWhereUniqueWithoutUserInput | AttendanceDailyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceDailyCreateManyUserInputEnvelope
    set?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    disconnect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    delete?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    update?: AttendanceDailyUpdateWithWhereUniqueWithoutUserInput | AttendanceDailyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceDailyUpdateManyWithWhereWithoutUserInput | AttendanceDailyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceDailyScalarWhereInput | AttendanceDailyScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCreatorInput, CashTransactionUncheckedCreateWithoutCreatorInput> | CashTransactionCreateWithoutCreatorInput[] | CashTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatorInput | CashTransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCreatorInput | CashTransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CashTransactionCreateManyCreatorInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCreatorInput | CashTransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCreatorInput | CashTransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type DispatchUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DispatchCreateWithoutCreatorInput, DispatchUncheckedCreateWithoutCreatorInput> | DispatchCreateWithoutCreatorInput[] | DispatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutCreatorInput | DispatchCreateOrConnectWithoutCreatorInput[]
    upsert?: DispatchUpsertWithWhereUniqueWithoutCreatorInput | DispatchUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DispatchCreateManyCreatorInputEnvelope
    set?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    disconnect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    delete?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    update?: DispatchUpdateWithWhereUniqueWithoutCreatorInput | DispatchUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DispatchUpdateManyWithWhereWithoutCreatorInput | DispatchUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DispatchScalarWhereInput | DispatchScalarWhereInput[]
  }

  export type EmployeeProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCreatorInput | ExpenseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCreatorInput | ExpenseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCreatorInput | ExpenseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatorInput | InvoiceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatorInput | InvoiceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatorInput | InvoiceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutMatchCheckerNestedInput = {
    create?: XOR<InvoiceCreateWithoutMatchCheckerInput, InvoiceUncheckedCreateWithoutMatchCheckerInput> | InvoiceCreateWithoutMatchCheckerInput[] | InvoiceUncheckedCreateWithoutMatchCheckerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMatchCheckerInput | InvoiceCreateOrConnectWithoutMatchCheckerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutMatchCheckerInput | InvoiceUpsertWithWhereUniqueWithoutMatchCheckerInput[]
    createMany?: InvoiceCreateManyMatchCheckerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutMatchCheckerInput | InvoiceUpdateWithWhereUniqueWithoutMatchCheckerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutMatchCheckerInput | InvoiceUpdateManyWithWhereWithoutMatchCheckerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PaymentCreateWithoutReceiverInput, PaymentUncheckedCreateWithoutReceiverInput> | PaymentCreateWithoutReceiverInput[] | PaymentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiverInput | PaymentCreateOrConnectWithoutReceiverInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceiverInput | PaymentUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PaymentCreateManyReceiverInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceiverInput | PaymentUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceiverInput | PaymentUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProductionDayUpdateManyWithoutCloserNestedInput = {
    create?: XOR<ProductionDayCreateWithoutCloserInput, ProductionDayUncheckedCreateWithoutCloserInput> | ProductionDayCreateWithoutCloserInput[] | ProductionDayUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCloserInput | ProductionDayCreateOrConnectWithoutCloserInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutCloserInput | ProductionDayUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: ProductionDayCreateManyCloserInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutCloserInput | ProductionDayUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutCloserInput | ProductionDayUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type ProductionDayUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductionDayCreateWithoutCreatorInput, ProductionDayUncheckedCreateWithoutCreatorInput> | ProductionDayCreateWithoutCreatorInput[] | ProductionDayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCreatorInput | ProductionDayCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutCreatorInput | ProductionDayUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductionDayCreateManyCreatorInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutCreatorInput | ProductionDayUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutCreatorInput | ProductionDayUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type ProductionDayUpdateManyWithoutReopenerNestedInput = {
    create?: XOR<ProductionDayCreateWithoutReopenerInput, ProductionDayUncheckedCreateWithoutReopenerInput> | ProductionDayCreateWithoutReopenerInput[] | ProductionDayUncheckedCreateWithoutReopenerInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutReopenerInput | ProductionDayCreateOrConnectWithoutReopenerInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutReopenerInput | ProductionDayUpsertWithWhereUniqueWithoutReopenerInput[]
    createMany?: ProductionDayCreateManyReopenerInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutReopenerInput | ProductionDayUpdateWithWhereUniqueWithoutReopenerInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutReopenerInput | ProductionDayUpdateManyWithWhereWithoutReopenerInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCreatorInput | PurchaseOrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalaryPaymentUpdateManyWithoutPayerNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutPayerInput, SalaryPaymentUncheckedCreateWithoutPayerInput> | SalaryPaymentCreateWithoutPayerInput[] | SalaryPaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutPayerInput | SalaryPaymentCreateOrConnectWithoutPayerInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutPayerInput | SalaryPaymentUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: SalaryPaymentCreateManyPayerInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutPayerInput | SalaryPaymentUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutPayerInput | SalaryPaymentUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type SalaryRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    upsert?: SalaryRecordUpsertWithWhereUniqueWithoutUserInput | SalaryRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    set?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    disconnect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    delete?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    update?: SalaryRecordUpdateWithWhereUniqueWithoutUserInput | SalaryRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryRecordUpdateManyWithWhereWithoutUserInput | SalaryRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCreatorInput, SalesOrderUncheckedCreateWithoutCreatorInput> | SalesOrderCreateWithoutCreatorInput[] | SalesOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCreatorInput | SalesOrderCreateOrConnectWithoutCreatorInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCreatorInput | SalesOrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SalesOrderCreateManyCreatorInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCreatorInput | SalesOrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCreatorInput | SalesOrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutCreatorInput | StockMovementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutCreatorInput | StockMovementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutCreatorInput | StockMovementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput = {
    create?: XOR<AttendanceDailyCreateWithoutRecorderInput, AttendanceDailyUncheckedCreateWithoutRecorderInput> | AttendanceDailyCreateWithoutRecorderInput[] | AttendanceDailyUncheckedCreateWithoutRecorderInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutRecorderInput | AttendanceDailyCreateOrConnectWithoutRecorderInput[]
    upsert?: AttendanceDailyUpsertWithWhereUniqueWithoutRecorderInput | AttendanceDailyUpsertWithWhereUniqueWithoutRecorderInput[]
    createMany?: AttendanceDailyCreateManyRecorderInputEnvelope
    set?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    disconnect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    delete?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    update?: AttendanceDailyUpdateWithWhereUniqueWithoutRecorderInput | AttendanceDailyUpdateWithWhereUniqueWithoutRecorderInput[]
    updateMany?: AttendanceDailyUpdateManyWithWhereWithoutRecorderInput | AttendanceDailyUpdateManyWithWhereWithoutRecorderInput[]
    deleteMany?: AttendanceDailyScalarWhereInput | AttendanceDailyScalarWhereInput[]
  }

  export type AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceDailyCreateWithoutUserInput, AttendanceDailyUncheckedCreateWithoutUserInput> | AttendanceDailyCreateWithoutUserInput[] | AttendanceDailyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceDailyCreateOrConnectWithoutUserInput | AttendanceDailyCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceDailyUpsertWithWhereUniqueWithoutUserInput | AttendanceDailyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceDailyCreateManyUserInputEnvelope
    set?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    disconnect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    delete?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    connect?: AttendanceDailyWhereUniqueInput | AttendanceDailyWhereUniqueInput[]
    update?: AttendanceDailyUpdateWithWhereUniqueWithoutUserInput | AttendanceDailyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceDailyUpdateManyWithWhereWithoutUserInput | AttendanceDailyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceDailyScalarWhereInput | AttendanceDailyScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCreatorInput, CashTransactionUncheckedCreateWithoutCreatorInput> | CashTransactionCreateWithoutCreatorInput[] | CashTransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatorInput | CashTransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCreatorInput | CashTransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CashTransactionCreateManyCreatorInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCreatorInput | CashTransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCreatorInput | CashTransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type DispatchUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DispatchCreateWithoutCreatorInput, DispatchUncheckedCreateWithoutCreatorInput> | DispatchCreateWithoutCreatorInput[] | DispatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutCreatorInput | DispatchCreateOrConnectWithoutCreatorInput[]
    upsert?: DispatchUpsertWithWhereUniqueWithoutCreatorInput | DispatchUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DispatchCreateManyCreatorInputEnvelope
    set?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    disconnect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    delete?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    update?: DispatchUpdateWithWhereUniqueWithoutCreatorInput | DispatchUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DispatchUpdateManyWithWhereWithoutCreatorInput | DispatchUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DispatchScalarWhereInput | DispatchScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput> | ExpenseCreateWithoutCreatorInput[] | ExpenseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCreatorInput | ExpenseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCreatorInput | ExpenseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExpenseCreateManyCreatorInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCreatorInput | ExpenseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCreatorInput | ExpenseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput> | InvoiceCreateWithoutCreatorInput[] | InvoiceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatorInput | InvoiceCreateOrConnectWithoutCreatorInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatorInput | InvoiceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvoiceCreateManyCreatorInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatorInput | InvoiceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatorInput | InvoiceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput = {
    create?: XOR<InvoiceCreateWithoutMatchCheckerInput, InvoiceUncheckedCreateWithoutMatchCheckerInput> | InvoiceCreateWithoutMatchCheckerInput[] | InvoiceUncheckedCreateWithoutMatchCheckerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutMatchCheckerInput | InvoiceCreateOrConnectWithoutMatchCheckerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutMatchCheckerInput | InvoiceUpsertWithWhereUniqueWithoutMatchCheckerInput[]
    createMany?: InvoiceCreateManyMatchCheckerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutMatchCheckerInput | InvoiceUpdateWithWhereUniqueWithoutMatchCheckerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutMatchCheckerInput | InvoiceUpdateManyWithWhereWithoutMatchCheckerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<PaymentCreateWithoutReceiverInput, PaymentUncheckedCreateWithoutReceiverInput> | PaymentCreateWithoutReceiverInput[] | PaymentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiverInput | PaymentCreateOrConnectWithoutReceiverInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceiverInput | PaymentUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: PaymentCreateManyReceiverInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceiverInput | PaymentUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceiverInput | PaymentUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProductionDayUncheckedUpdateManyWithoutCloserNestedInput = {
    create?: XOR<ProductionDayCreateWithoutCloserInput, ProductionDayUncheckedCreateWithoutCloserInput> | ProductionDayCreateWithoutCloserInput[] | ProductionDayUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCloserInput | ProductionDayCreateOrConnectWithoutCloserInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutCloserInput | ProductionDayUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: ProductionDayCreateManyCloserInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutCloserInput | ProductionDayUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutCloserInput | ProductionDayUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProductionDayCreateWithoutCreatorInput, ProductionDayUncheckedCreateWithoutCreatorInput> | ProductionDayCreateWithoutCreatorInput[] | ProductionDayUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutCreatorInput | ProductionDayCreateOrConnectWithoutCreatorInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutCreatorInput | ProductionDayUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProductionDayCreateManyCreatorInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutCreatorInput | ProductionDayUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutCreatorInput | ProductionDayUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput = {
    create?: XOR<ProductionDayCreateWithoutReopenerInput, ProductionDayUncheckedCreateWithoutReopenerInput> | ProductionDayCreateWithoutReopenerInput[] | ProductionDayUncheckedCreateWithoutReopenerInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutReopenerInput | ProductionDayCreateOrConnectWithoutReopenerInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutReopenerInput | ProductionDayUpsertWithWhereUniqueWithoutReopenerInput[]
    createMany?: ProductionDayCreateManyReopenerInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutReopenerInput | ProductionDayUpdateWithWhereUniqueWithoutReopenerInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutReopenerInput | ProductionDayUpdateManyWithWhereWithoutReopenerInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCreatorInput | PurchaseOrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutPayerInput, SalaryPaymentUncheckedCreateWithoutPayerInput> | SalaryPaymentCreateWithoutPayerInput[] | SalaryPaymentUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutPayerInput | SalaryPaymentCreateOrConnectWithoutPayerInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutPayerInput | SalaryPaymentUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: SalaryPaymentCreateManyPayerInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutPayerInput | SalaryPaymentUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutPayerInput | SalaryPaymentUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type SalaryRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput> | SalaryRecordCreateWithoutUserInput[] | SalaryRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutUserInput | SalaryRecordCreateOrConnectWithoutUserInput[]
    upsert?: SalaryRecordUpsertWithWhereUniqueWithoutUserInput | SalaryRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryRecordCreateManyUserInputEnvelope
    set?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    disconnect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    delete?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    update?: SalaryRecordUpdateWithWhereUniqueWithoutUserInput | SalaryRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryRecordUpdateManyWithWhereWithoutUserInput | SalaryRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCreatorInput, SalesOrderUncheckedCreateWithoutCreatorInput> | SalesOrderCreateWithoutCreatorInput[] | SalesOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCreatorInput | SalesOrderCreateOrConnectWithoutCreatorInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCreatorInput | SalesOrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SalesOrderCreateManyCreatorInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCreatorInput | SalesOrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCreatorInput | SalesOrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput> | StockMovementCreateWithoutCreatorInput[] | StockMovementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutCreatorInput | StockMovementCreateOrConnectWithoutCreatorInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutCreatorInput | StockMovementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StockMovementCreateManyCreatorInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutCreatorInput | StockMovementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutCreatorInput | StockMovementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type EmployeeProfileCreateNestedManyWithoutSalaryRangeInput = {
    create?: XOR<EmployeeProfileCreateWithoutSalaryRangeInput, EmployeeProfileUncheckedCreateWithoutSalaryRangeInput> | EmployeeProfileCreateWithoutSalaryRangeInput[] | EmployeeProfileUncheckedCreateWithoutSalaryRangeInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutSalaryRangeInput | EmployeeProfileCreateOrConnectWithoutSalaryRangeInput[]
    createMany?: EmployeeProfileCreateManySalaryRangeInputEnvelope
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedManyWithoutSalaryRangeInput = {
    create?: XOR<EmployeeProfileCreateWithoutSalaryRangeInput, EmployeeProfileUncheckedCreateWithoutSalaryRangeInput> | EmployeeProfileCreateWithoutSalaryRangeInput[] | EmployeeProfileUncheckedCreateWithoutSalaryRangeInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutSalaryRangeInput | EmployeeProfileCreateOrConnectWithoutSalaryRangeInput[]
    createMany?: EmployeeProfileCreateManySalaryRangeInputEnvelope
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EmployeeProfileUpdateManyWithoutSalaryRangeNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutSalaryRangeInput, EmployeeProfileUncheckedCreateWithoutSalaryRangeInput> | EmployeeProfileCreateWithoutSalaryRangeInput[] | EmployeeProfileUncheckedCreateWithoutSalaryRangeInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutSalaryRangeInput | EmployeeProfileCreateOrConnectWithoutSalaryRangeInput[]
    upsert?: EmployeeProfileUpsertWithWhereUniqueWithoutSalaryRangeInput | EmployeeProfileUpsertWithWhereUniqueWithoutSalaryRangeInput[]
    createMany?: EmployeeProfileCreateManySalaryRangeInputEnvelope
    set?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    disconnect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    delete?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    update?: EmployeeProfileUpdateWithWhereUniqueWithoutSalaryRangeInput | EmployeeProfileUpdateWithWhereUniqueWithoutSalaryRangeInput[]
    updateMany?: EmployeeProfileUpdateManyWithWhereWithoutSalaryRangeInput | EmployeeProfileUpdateManyWithWhereWithoutSalaryRangeInput[]
    deleteMany?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateManyWithoutSalaryRangeNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutSalaryRangeInput, EmployeeProfileUncheckedCreateWithoutSalaryRangeInput> | EmployeeProfileCreateWithoutSalaryRangeInput[] | EmployeeProfileUncheckedCreateWithoutSalaryRangeInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutSalaryRangeInput | EmployeeProfileCreateOrConnectWithoutSalaryRangeInput[]
    upsert?: EmployeeProfileUpsertWithWhereUniqueWithoutSalaryRangeInput | EmployeeProfileUpsertWithWhereUniqueWithoutSalaryRangeInput[]
    createMany?: EmployeeProfileCreateManySalaryRangeInputEnvelope
    set?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    disconnect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    delete?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    update?: EmployeeProfileUpdateWithWhereUniqueWithoutSalaryRangeInput | EmployeeProfileUpdateWithWhereUniqueWithoutSalaryRangeInput[]
    updateMany?: EmployeeProfileUpdateManyWithWhereWithoutSalaryRangeInput | EmployeeProfileUpdateManyWithWhereWithoutSalaryRangeInput[]
    deleteMany?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
  }

  export type SalaryRangeCreateNestedOneWithoutEmployeeProfilesInput = {
    create?: XOR<SalaryRangeCreateWithoutEmployeeProfilesInput, SalaryRangeUncheckedCreateWithoutEmployeeProfilesInput>
    connectOrCreate?: SalaryRangeCreateOrConnectWithoutEmployeeProfilesInput
    connect?: SalaryRangeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeProfileInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SalaryRangeUpdateOneWithoutEmployeeProfilesNestedInput = {
    create?: XOR<SalaryRangeCreateWithoutEmployeeProfilesInput, SalaryRangeUncheckedCreateWithoutEmployeeProfilesInput>
    connectOrCreate?: SalaryRangeCreateOrConnectWithoutEmployeeProfilesInput
    upsert?: SalaryRangeUpsertWithoutEmployeeProfilesInput
    disconnect?: SalaryRangeWhereInput | boolean
    delete?: SalaryRangeWhereInput | boolean
    connect?: SalaryRangeWhereUniqueInput
    update?: XOR<XOR<SalaryRangeUpdateToOneWithWhereWithoutEmployeeProfilesInput, SalaryRangeUpdateWithoutEmployeeProfilesInput>, SalaryRangeUncheckedUpdateWithoutEmployeeProfilesInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeProfileNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    upsert?: UserUpsertWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeProfileInput, UserUpdateWithoutEmployeeProfileInput>, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserCreateNestedOneWithoutRecordedAttendancesInput = {
    create?: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutRecordedAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecordedAttendancesInput
    upsert?: UserUpsertWithoutRecordedAttendancesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecordedAttendancesInput, UserUpdateWithoutRecordedAttendancesInput>, UserUncheckedUpdateWithoutRecordedAttendancesInput>
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type SalaryRecordCreateNestedManyWithoutPeriodInput = {
    create?: XOR<SalaryRecordCreateWithoutPeriodInput, SalaryRecordUncheckedCreateWithoutPeriodInput> | SalaryRecordCreateWithoutPeriodInput[] | SalaryRecordUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutPeriodInput | SalaryRecordCreateOrConnectWithoutPeriodInput[]
    createMany?: SalaryRecordCreateManyPeriodInputEnvelope
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
  }

  export type SalaryRecordUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<SalaryRecordCreateWithoutPeriodInput, SalaryRecordUncheckedCreateWithoutPeriodInput> | SalaryRecordCreateWithoutPeriodInput[] | SalaryRecordUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutPeriodInput | SalaryRecordCreateOrConnectWithoutPeriodInput[]
    createMany?: SalaryRecordCreateManyPeriodInputEnvelope
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
  }

  export type SalaryRecordUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutPeriodInput, SalaryRecordUncheckedCreateWithoutPeriodInput> | SalaryRecordCreateWithoutPeriodInput[] | SalaryRecordUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutPeriodInput | SalaryRecordCreateOrConnectWithoutPeriodInput[]
    upsert?: SalaryRecordUpsertWithWhereUniqueWithoutPeriodInput | SalaryRecordUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: SalaryRecordCreateManyPeriodInputEnvelope
    set?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    disconnect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    delete?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    update?: SalaryRecordUpdateWithWhereUniqueWithoutPeriodInput | SalaryRecordUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: SalaryRecordUpdateManyWithWhereWithoutPeriodInput | SalaryRecordUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
  }

  export type SalaryRecordUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutPeriodInput, SalaryRecordUncheckedCreateWithoutPeriodInput> | SalaryRecordCreateWithoutPeriodInput[] | SalaryRecordUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutPeriodInput | SalaryRecordCreateOrConnectWithoutPeriodInput[]
    upsert?: SalaryRecordUpsertWithWhereUniqueWithoutPeriodInput | SalaryRecordUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: SalaryRecordCreateManyPeriodInputEnvelope
    set?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    disconnect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    delete?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    connect?: SalaryRecordWhereUniqueInput | SalaryRecordWhereUniqueInput[]
    update?: SalaryRecordUpdateWithWhereUniqueWithoutPeriodInput | SalaryRecordUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: SalaryRecordUpdateManyWithWhereWithoutPeriodInput | SalaryRecordUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
  }

  export type SalaryPaymentCreateNestedManyWithoutSalaryRecordInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryRecordInput, SalaryPaymentUncheckedCreateWithoutSalaryRecordInput> | SalaryPaymentCreateWithoutSalaryRecordInput[] | SalaryPaymentUncheckedCreateWithoutSalaryRecordInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryRecordInput | SalaryPaymentCreateOrConnectWithoutSalaryRecordInput[]
    createMany?: SalaryPaymentCreateManySalaryRecordInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type SalaryPeriodCreateNestedOneWithoutSalaryRecordsInput = {
    create?: XOR<SalaryPeriodCreateWithoutSalaryRecordsInput, SalaryPeriodUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: SalaryPeriodCreateOrConnectWithoutSalaryRecordsInput
    connect?: SalaryPeriodWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalaryRecordsInput = {
    create?: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type SalaryPaymentUncheckedCreateNestedManyWithoutSalaryRecordInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryRecordInput, SalaryPaymentUncheckedCreateWithoutSalaryRecordInput> | SalaryPaymentCreateWithoutSalaryRecordInput[] | SalaryPaymentUncheckedCreateWithoutSalaryRecordInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryRecordInput | SalaryPaymentCreateOrConnectWithoutSalaryRecordInput[]
    createMany?: SalaryPaymentCreateManySalaryRecordInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type SalaryPaymentUpdateManyWithoutSalaryRecordNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryRecordInput, SalaryPaymentUncheckedCreateWithoutSalaryRecordInput> | SalaryPaymentCreateWithoutSalaryRecordInput[] | SalaryPaymentUncheckedCreateWithoutSalaryRecordInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryRecordInput | SalaryPaymentCreateOrConnectWithoutSalaryRecordInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutSalaryRecordInput | SalaryPaymentUpsertWithWhereUniqueWithoutSalaryRecordInput[]
    createMany?: SalaryPaymentCreateManySalaryRecordInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutSalaryRecordInput | SalaryPaymentUpdateWithWhereUniqueWithoutSalaryRecordInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutSalaryRecordInput | SalaryPaymentUpdateManyWithWhereWithoutSalaryRecordInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type SalaryPeriodUpdateOneRequiredWithoutSalaryRecordsNestedInput = {
    create?: XOR<SalaryPeriodCreateWithoutSalaryRecordsInput, SalaryPeriodUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: SalaryPeriodCreateOrConnectWithoutSalaryRecordsInput
    upsert?: SalaryPeriodUpsertWithoutSalaryRecordsInput
    connect?: SalaryPeriodWhereUniqueInput
    update?: XOR<XOR<SalaryPeriodUpdateToOneWithWhereWithoutSalaryRecordsInput, SalaryPeriodUpdateWithoutSalaryRecordsInput>, SalaryPeriodUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type UserUpdateOneRequiredWithoutSalaryRecordsNestedInput = {
    create?: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryRecordsInput
    upsert?: UserUpsertWithoutSalaryRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryRecordsInput, UserUpdateWithoutSalaryRecordsInput>, UserUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutSalaryRecordNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutSalaryRecordInput, SalaryPaymentUncheckedCreateWithoutSalaryRecordInput> | SalaryPaymentCreateWithoutSalaryRecordInput[] | SalaryPaymentUncheckedCreateWithoutSalaryRecordInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutSalaryRecordInput | SalaryPaymentCreateOrConnectWithoutSalaryRecordInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutSalaryRecordInput | SalaryPaymentUpsertWithWhereUniqueWithoutSalaryRecordInput[]
    createMany?: SalaryPaymentCreateManySalaryRecordInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutSalaryRecordInput | SalaryPaymentUpdateWithWhereUniqueWithoutSalaryRecordInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutSalaryRecordInput | SalaryPaymentUpdateManyWithWhereWithoutSalaryRecordInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSalaryPaymentsPaidInput = {
    create?: XOR<UserCreateWithoutSalaryPaymentsPaidInput, UserUncheckedCreateWithoutSalaryPaymentsPaidInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryPaymentsPaidInput
    connect?: UserWhereUniqueInput
  }

  export type SalaryRecordCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SalaryRecordCreateWithoutPaymentsInput, SalaryRecordUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutPaymentsInput
    connect?: SalaryRecordWhereUniqueInput
  }

  export type EnumPayMethodFieldUpdateOperationsInput = {
    set?: $Enums.PayMethod
  }

  export type UserUpdateOneWithoutSalaryPaymentsPaidNestedInput = {
    create?: XOR<UserCreateWithoutSalaryPaymentsPaidInput, UserUncheckedCreateWithoutSalaryPaymentsPaidInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryPaymentsPaidInput
    upsert?: UserUpsertWithoutSalaryPaymentsPaidInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryPaymentsPaidInput, UserUpdateWithoutSalaryPaymentsPaidInput>, UserUncheckedUpdateWithoutSalaryPaymentsPaidInput>
  }

  export type SalaryRecordUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SalaryRecordCreateWithoutPaymentsInput, SalaryRecordUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SalaryRecordCreateOrConnectWithoutPaymentsInput
    upsert?: SalaryRecordUpsertWithoutPaymentsInput
    connect?: SalaryRecordWhereUniqueInput
    update?: XOR<XOR<SalaryRecordUpdateToOneWithWhereWithoutPaymentsInput, SalaryRecordUpdateWithoutPaymentsInput>, SalaryRecordUncheckedUpdateWithoutPaymentsInput>
  }

  export type ItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutUnitInput | ItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutUnitInput | ItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutUnitInput | ItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput> | ItemCreateWithoutUnitInput[] | ItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutUnitInput | ItemCreateOrConnectWithoutUnitInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutUnitInput | ItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutUnitInput | ItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutUnitInput | ItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CustomerItemPriceCreateNestedManyWithoutItemInput = {
    create?: XOR<CustomerItemPriceCreateWithoutItemInput, CustomerItemPriceUncheckedCreateWithoutItemInput> | CustomerItemPriceCreateWithoutItemInput[] | CustomerItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutItemInput | CustomerItemPriceCreateOrConnectWithoutItemInput[]
    createMany?: CustomerItemPriceCreateManyItemInputEnvelope
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
  }

  export type InvoiceLineCreateNestedManyWithoutItemInput = {
    create?: XOR<InvoiceLineCreateWithoutItemInput, InvoiceLineUncheckedCreateWithoutItemInput> | InvoiceLineCreateWithoutItemInput[] | InvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutItemInput | InvoiceLineCreateOrConnectWithoutItemInput[]
    createMany?: InvoiceLineCreateManyItemInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type ItemCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutItemsInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type ProductionDayCreateNestedManyWithoutFinishedProductInput = {
    create?: XOR<ProductionDayCreateWithoutFinishedProductInput, ProductionDayUncheckedCreateWithoutFinishedProductInput> | ProductionDayCreateWithoutFinishedProductInput[] | ProductionDayUncheckedCreateWithoutFinishedProductInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutFinishedProductInput | ProductionDayCreateOrConnectWithoutFinishedProductInput[]
    createMany?: ProductionDayCreateManyFinishedProductInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type PurchaseOrderLineCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type StockBalanceCreateNestedOneWithoutItemInput = {
    create?: XOR<StockBalanceCreateWithoutItemInput, StockBalanceUncheckedCreateWithoutItemInput>
    connectOrCreate?: StockBalanceCreateOrConnectWithoutItemInput
    connect?: StockBalanceWhereUniqueInput
  }

  export type StockMovementCreateNestedManyWithoutItemInput = {
    create?: XOR<StockMovementCreateWithoutItemInput, StockMovementUncheckedCreateWithoutItemInput> | StockMovementCreateWithoutItemInput[] | StockMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutItemInput | StockMovementCreateOrConnectWithoutItemInput[]
    createMany?: StockMovementCreateManyItemInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type SupplierItemPriceCreateNestedManyWithoutItemInput = {
    create?: XOR<SupplierItemPriceCreateWithoutItemInput, SupplierItemPriceUncheckedCreateWithoutItemInput> | SupplierItemPriceCreateWithoutItemInput[] | SupplierItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutItemInput | SupplierItemPriceCreateOrConnectWithoutItemInput[]
    createMany?: SupplierItemPriceCreateManyItemInputEnvelope
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
  }

  export type CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CustomerItemPriceCreateWithoutItemInput, CustomerItemPriceUncheckedCreateWithoutItemInput> | CustomerItemPriceCreateWithoutItemInput[] | CustomerItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutItemInput | CustomerItemPriceCreateOrConnectWithoutItemInput[]
    createMany?: CustomerItemPriceCreateManyItemInputEnvelope
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InvoiceLineCreateWithoutItemInput, InvoiceLineUncheckedCreateWithoutItemInput> | InvoiceLineCreateWithoutItemInput[] | InvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutItemInput | InvoiceLineCreateOrConnectWithoutItemInput[]
    createMany?: InvoiceLineCreateManyItemInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput = {
    create?: XOR<ProductionDayCreateWithoutFinishedProductInput, ProductionDayUncheckedCreateWithoutFinishedProductInput> | ProductionDayCreateWithoutFinishedProductInput[] | ProductionDayUncheckedCreateWithoutFinishedProductInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutFinishedProductInput | ProductionDayCreateOrConnectWithoutFinishedProductInput[]
    createMany?: ProductionDayCreateManyFinishedProductInputEnvelope
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type StockBalanceUncheckedCreateNestedOneWithoutItemInput = {
    create?: XOR<StockBalanceCreateWithoutItemInput, StockBalanceUncheckedCreateWithoutItemInput>
    connectOrCreate?: StockBalanceCreateOrConnectWithoutItemInput
    connect?: StockBalanceWhereUniqueInput
  }

  export type StockMovementUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<StockMovementCreateWithoutItemInput, StockMovementUncheckedCreateWithoutItemInput> | StockMovementCreateWithoutItemInput[] | StockMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutItemInput | StockMovementCreateOrConnectWithoutItemInput[]
    createMany?: StockMovementCreateManyItemInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SupplierItemPriceCreateWithoutItemInput, SupplierItemPriceUncheckedCreateWithoutItemInput> | SupplierItemPriceCreateWithoutItemInput[] | SupplierItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutItemInput | SupplierItemPriceCreateOrConnectWithoutItemInput[]
    createMany?: SupplierItemPriceCreateManyItemInputEnvelope
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type CustomerItemPriceUpdateManyWithoutItemNestedInput = {
    create?: XOR<CustomerItemPriceCreateWithoutItemInput, CustomerItemPriceUncheckedCreateWithoutItemInput> | CustomerItemPriceCreateWithoutItemInput[] | CustomerItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutItemInput | CustomerItemPriceCreateOrConnectWithoutItemInput[]
    upsert?: CustomerItemPriceUpsertWithWhereUniqueWithoutItemInput | CustomerItemPriceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CustomerItemPriceCreateManyItemInputEnvelope
    set?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    disconnect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    delete?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    update?: CustomerItemPriceUpdateWithWhereUniqueWithoutItemInput | CustomerItemPriceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CustomerItemPriceUpdateManyWithWhereWithoutItemInput | CustomerItemPriceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CustomerItemPriceScalarWhereInput | CustomerItemPriceScalarWhereInput[]
  }

  export type InvoiceLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutItemInput, InvoiceLineUncheckedCreateWithoutItemInput> | InvoiceLineCreateWithoutItemInput[] | InvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutItemInput | InvoiceLineCreateOrConnectWithoutItemInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutItemInput | InvoiceLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InvoiceLineCreateManyItemInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutItemInput | InvoiceLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutItemInput | InvoiceLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type ItemCategoryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    upsert?: ItemCategoryUpsertWithoutItemsInput
    disconnect?: ItemCategoryWhereInput | boolean
    delete?: ItemCategoryWhereInput | boolean
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutItemsInput, ItemCategoryUpdateWithoutItemsInput>, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type UnitUpdateOneWithoutItemsNestedInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    upsert?: UnitUpsertWithoutItemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutItemsInput, UnitUpdateWithoutItemsInput>, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type ProductionDayUpdateManyWithoutFinishedProductNestedInput = {
    create?: XOR<ProductionDayCreateWithoutFinishedProductInput, ProductionDayUncheckedCreateWithoutFinishedProductInput> | ProductionDayCreateWithoutFinishedProductInput[] | ProductionDayUncheckedCreateWithoutFinishedProductInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutFinishedProductInput | ProductionDayCreateOrConnectWithoutFinishedProductInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutFinishedProductInput | ProductionDayUpsertWithWhereUniqueWithoutFinishedProductInput[]
    createMany?: ProductionDayCreateManyFinishedProductInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutFinishedProductInput | ProductionDayUpdateWithWhereUniqueWithoutFinishedProductInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutFinishedProductInput | ProductionDayUpdateManyWithWhereWithoutFinishedProductInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type PurchaseOrderLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutItemInput | PurchaseOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutItemInput | SalesOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutItemInput | SalesOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutItemInput | SalesOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type StockBalanceUpdateOneWithoutItemNestedInput = {
    create?: XOR<StockBalanceCreateWithoutItemInput, StockBalanceUncheckedCreateWithoutItemInput>
    connectOrCreate?: StockBalanceCreateOrConnectWithoutItemInput
    upsert?: StockBalanceUpsertWithoutItemInput
    disconnect?: StockBalanceWhereInput | boolean
    delete?: StockBalanceWhereInput | boolean
    connect?: StockBalanceWhereUniqueInput
    update?: XOR<XOR<StockBalanceUpdateToOneWithWhereWithoutItemInput, StockBalanceUpdateWithoutItemInput>, StockBalanceUncheckedUpdateWithoutItemInput>
  }

  export type StockMovementUpdateManyWithoutItemNestedInput = {
    create?: XOR<StockMovementCreateWithoutItemInput, StockMovementUncheckedCreateWithoutItemInput> | StockMovementCreateWithoutItemInput[] | StockMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutItemInput | StockMovementCreateOrConnectWithoutItemInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutItemInput | StockMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StockMovementCreateManyItemInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutItemInput | StockMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutItemInput | StockMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type SupplierItemPriceUpdateManyWithoutItemNestedInput = {
    create?: XOR<SupplierItemPriceCreateWithoutItemInput, SupplierItemPriceUncheckedCreateWithoutItemInput> | SupplierItemPriceCreateWithoutItemInput[] | SupplierItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutItemInput | SupplierItemPriceCreateOrConnectWithoutItemInput[]
    upsert?: SupplierItemPriceUpsertWithWhereUniqueWithoutItemInput | SupplierItemPriceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SupplierItemPriceCreateManyItemInputEnvelope
    set?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    disconnect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    delete?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    update?: SupplierItemPriceUpdateWithWhereUniqueWithoutItemInput | SupplierItemPriceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SupplierItemPriceUpdateManyWithWhereWithoutItemInput | SupplierItemPriceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SupplierItemPriceScalarWhereInput | SupplierItemPriceScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CustomerItemPriceCreateWithoutItemInput, CustomerItemPriceUncheckedCreateWithoutItemInput> | CustomerItemPriceCreateWithoutItemInput[] | CustomerItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutItemInput | CustomerItemPriceCreateOrConnectWithoutItemInput[]
    upsert?: CustomerItemPriceUpsertWithWhereUniqueWithoutItemInput | CustomerItemPriceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CustomerItemPriceCreateManyItemInputEnvelope
    set?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    disconnect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    delete?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    update?: CustomerItemPriceUpdateWithWhereUniqueWithoutItemInput | CustomerItemPriceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CustomerItemPriceUpdateManyWithWhereWithoutItemInput | CustomerItemPriceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CustomerItemPriceScalarWhereInput | CustomerItemPriceScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutItemInput, InvoiceLineUncheckedCreateWithoutItemInput> | InvoiceLineCreateWithoutItemInput[] | InvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutItemInput | InvoiceLineCreateOrConnectWithoutItemInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutItemInput | InvoiceLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InvoiceLineCreateManyItemInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutItemInput | InvoiceLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutItemInput | InvoiceLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput = {
    create?: XOR<ProductionDayCreateWithoutFinishedProductInput, ProductionDayUncheckedCreateWithoutFinishedProductInput> | ProductionDayCreateWithoutFinishedProductInput[] | ProductionDayUncheckedCreateWithoutFinishedProductInput[]
    connectOrCreate?: ProductionDayCreateOrConnectWithoutFinishedProductInput | ProductionDayCreateOrConnectWithoutFinishedProductInput[]
    upsert?: ProductionDayUpsertWithWhereUniqueWithoutFinishedProductInput | ProductionDayUpsertWithWhereUniqueWithoutFinishedProductInput[]
    createMany?: ProductionDayCreateManyFinishedProductInputEnvelope
    set?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    disconnect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    delete?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    connect?: ProductionDayWhereUniqueInput | ProductionDayWhereUniqueInput[]
    update?: ProductionDayUpdateWithWhereUniqueWithoutFinishedProductInput | ProductionDayUpdateWithWhereUniqueWithoutFinishedProductInput[]
    updateMany?: ProductionDayUpdateManyWithWhereWithoutFinishedProductInput | ProductionDayUpdateManyWithWhereWithoutFinishedProductInput[]
    deleteMany?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutItemInput | PurchaseOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutItemInput | SalesOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutItemInput | SalesOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutItemInput | SalesOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type StockBalanceUncheckedUpdateOneWithoutItemNestedInput = {
    create?: XOR<StockBalanceCreateWithoutItemInput, StockBalanceUncheckedCreateWithoutItemInput>
    connectOrCreate?: StockBalanceCreateOrConnectWithoutItemInput
    upsert?: StockBalanceUpsertWithoutItemInput
    disconnect?: StockBalanceWhereInput | boolean
    delete?: StockBalanceWhereInput | boolean
    connect?: StockBalanceWhereUniqueInput
    update?: XOR<XOR<StockBalanceUpdateToOneWithWhereWithoutItemInput, StockBalanceUpdateWithoutItemInput>, StockBalanceUncheckedUpdateWithoutItemInput>
  }

  export type StockMovementUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<StockMovementCreateWithoutItemInput, StockMovementUncheckedCreateWithoutItemInput> | StockMovementCreateWithoutItemInput[] | StockMovementUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutItemInput | StockMovementCreateOrConnectWithoutItemInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutItemInput | StockMovementUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StockMovementCreateManyItemInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutItemInput | StockMovementUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutItemInput | StockMovementUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SupplierItemPriceCreateWithoutItemInput, SupplierItemPriceUncheckedCreateWithoutItemInput> | SupplierItemPriceCreateWithoutItemInput[] | SupplierItemPriceUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutItemInput | SupplierItemPriceCreateOrConnectWithoutItemInput[]
    upsert?: SupplierItemPriceUpsertWithWhereUniqueWithoutItemInput | SupplierItemPriceUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SupplierItemPriceCreateManyItemInputEnvelope
    set?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    disconnect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    delete?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    update?: SupplierItemPriceUpdateWithWhereUniqueWithoutItemInput | SupplierItemPriceUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SupplierItemPriceUpdateManyWithWhereWithoutItemInput | SupplierItemPriceUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SupplierItemPriceScalarWhereInput | SupplierItemPriceScalarWhereInput[]
  }

  export type ExpenseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierItemPriceCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierItemPriceCreateWithoutSupplierInput, SupplierItemPriceUncheckedCreateWithoutSupplierInput> | SupplierItemPriceCreateWithoutSupplierInput[] | SupplierItemPriceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutSupplierInput | SupplierItemPriceCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierItemPriceCreateManySupplierInputEnvelope
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierItemPriceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierItemPriceCreateWithoutSupplierInput, SupplierItemPriceUncheckedCreateWithoutSupplierInput> | SupplierItemPriceCreateWithoutSupplierInput[] | SupplierItemPriceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutSupplierInput | SupplierItemPriceCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierItemPriceCreateManySupplierInputEnvelope
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutSupplierInput | ExpenseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutSupplierInput | ExpenseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutSupplierInput | ExpenseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSupplierInput | InvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSupplierInput | InvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSupplierInput | InvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierItemPriceUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierItemPriceCreateWithoutSupplierInput, SupplierItemPriceUncheckedCreateWithoutSupplierInput> | SupplierItemPriceCreateWithoutSupplierInput[] | SupplierItemPriceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutSupplierInput | SupplierItemPriceCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierItemPriceUpsertWithWhereUniqueWithoutSupplierInput | SupplierItemPriceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierItemPriceCreateManySupplierInputEnvelope
    set?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    disconnect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    delete?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    update?: SupplierItemPriceUpdateWithWhereUniqueWithoutSupplierInput | SupplierItemPriceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierItemPriceUpdateManyWithWhereWithoutSupplierInput | SupplierItemPriceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierItemPriceScalarWhereInput | SupplierItemPriceScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutSupplierInput | ExpenseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutSupplierInput | ExpenseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutSupplierInput | ExpenseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSupplierInput | InvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSupplierInput | InvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSupplierInput | InvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierItemPriceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierItemPriceCreateWithoutSupplierInput, SupplierItemPriceUncheckedCreateWithoutSupplierInput> | SupplierItemPriceCreateWithoutSupplierInput[] | SupplierItemPriceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierItemPriceCreateOrConnectWithoutSupplierInput | SupplierItemPriceCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierItemPriceUpsertWithWhereUniqueWithoutSupplierInput | SupplierItemPriceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierItemPriceCreateManySupplierInputEnvelope
    set?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    disconnect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    delete?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    connect?: SupplierItemPriceWhereUniqueInput | SupplierItemPriceWhereUniqueInput[]
    update?: SupplierItemPriceUpdateWithWhereUniqueWithoutSupplierInput | SupplierItemPriceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierItemPriceUpdateManyWithWhereWithoutSupplierInput | SupplierItemPriceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierItemPriceScalarWhereInput | SupplierItemPriceScalarWhereInput[]
  }

  export type CustomerItemPriceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerItemPriceCreateWithoutCustomerInput, CustomerItemPriceUncheckedCreateWithoutCustomerInput> | CustomerItemPriceCreateWithoutCustomerInput[] | CustomerItemPriceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutCustomerInput | CustomerItemPriceCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerItemPriceCreateManyCustomerInputEnvelope
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type CustomerItemPriceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerItemPriceCreateWithoutCustomerInput, CustomerItemPriceUncheckedCreateWithoutCustomerInput> | CustomerItemPriceCreateWithoutCustomerInput[] | CustomerItemPriceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutCustomerInput | CustomerItemPriceCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerItemPriceCreateManyCustomerInputEnvelope
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type CustomerItemPriceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerItemPriceCreateWithoutCustomerInput, CustomerItemPriceUncheckedCreateWithoutCustomerInput> | CustomerItemPriceCreateWithoutCustomerInput[] | CustomerItemPriceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutCustomerInput | CustomerItemPriceCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerItemPriceUpsertWithWhereUniqueWithoutCustomerInput | CustomerItemPriceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerItemPriceCreateManyCustomerInputEnvelope
    set?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    disconnect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    delete?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    update?: CustomerItemPriceUpdateWithWhereUniqueWithoutCustomerInput | CustomerItemPriceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerItemPriceUpdateManyWithWhereWithoutCustomerInput | CustomerItemPriceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerItemPriceScalarWhereInput | CustomerItemPriceScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type CustomerItemPriceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerItemPriceCreateWithoutCustomerInput, CustomerItemPriceUncheckedCreateWithoutCustomerInput> | CustomerItemPriceCreateWithoutCustomerInput[] | CustomerItemPriceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerItemPriceCreateOrConnectWithoutCustomerInput | CustomerItemPriceCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerItemPriceUpsertWithWhereUniqueWithoutCustomerInput | CustomerItemPriceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerItemPriceCreateManyCustomerInputEnvelope
    set?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    disconnect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    delete?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    connect?: CustomerItemPriceWhereUniqueInput | CustomerItemPriceWhereUniqueInput[]
    update?: CustomerItemPriceUpdateWithWhereUniqueWithoutCustomerInput | CustomerItemPriceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerItemPriceUpdateManyWithWhereWithoutCustomerInput | CustomerItemPriceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerItemPriceScalarWhereInput | CustomerItemPriceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutSupplierPricesInput = {
    create?: XOR<ItemCreateWithoutSupplierPricesInput, ItemUncheckedCreateWithoutSupplierPricesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSupplierPricesInput
    connect?: ItemWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutItemPricesInput = {
    create?: XOR<SupplierCreateWithoutItemPricesInput, SupplierUncheckedCreateWithoutItemPricesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemPricesInput
    connect?: SupplierWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutSupplierPricesNestedInput = {
    create?: XOR<ItemCreateWithoutSupplierPricesInput, ItemUncheckedCreateWithoutSupplierPricesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSupplierPricesInput
    upsert?: ItemUpsertWithoutSupplierPricesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSupplierPricesInput, ItemUpdateWithoutSupplierPricesInput>, ItemUncheckedUpdateWithoutSupplierPricesInput>
  }

  export type SupplierUpdateOneRequiredWithoutItemPricesNestedInput = {
    create?: XOR<SupplierCreateWithoutItemPricesInput, SupplierUncheckedCreateWithoutItemPricesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutItemPricesInput
    upsert?: SupplierUpsertWithoutItemPricesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutItemPricesInput, SupplierUpdateWithoutItemPricesInput>, SupplierUncheckedUpdateWithoutItemPricesInput>
  }

  export type CustomerCreateNestedOneWithoutItemPricesInput = {
    create?: XOR<CustomerCreateWithoutItemPricesInput, CustomerUncheckedCreateWithoutItemPricesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutItemPricesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutCustomerPricesInput = {
    create?: XOR<ItemCreateWithoutCustomerPricesInput, ItemUncheckedCreateWithoutCustomerPricesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCustomerPricesInput
    connect?: ItemWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutItemPricesNestedInput = {
    create?: XOR<CustomerCreateWithoutItemPricesInput, CustomerUncheckedCreateWithoutItemPricesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutItemPricesInput
    upsert?: CustomerUpsertWithoutItemPricesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutItemPricesInput, CustomerUpdateWithoutItemPricesInput>, CustomerUncheckedUpdateWithoutItemPricesInput>
  }

  export type ItemUpdateOneRequiredWithoutCustomerPricesNestedInput = {
    create?: XOR<ItemCreateWithoutCustomerPricesInput, ItemUncheckedCreateWithoutCustomerPricesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCustomerPricesInput
    upsert?: ItemUpsertWithoutCustomerPricesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutCustomerPricesInput, ItemUpdateWithoutCustomerPricesInput>, ItemUncheckedUpdateWithoutCustomerPricesInput>
  }

  export type InvoiceCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseOrderInput, InvoiceUncheckedCreateWithoutPurchaseOrderInput> | InvoiceCreateWithoutPurchaseOrderInput[] | InvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseOrderInput | InvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: InvoiceCreateManyPurchaseOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type StockMovementCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<StockMovementCreateWithoutPurchaseOrderInput, StockMovementUncheckedCreateWithoutPurchaseOrderInput> | StockMovementCreateWithoutPurchaseOrderInput[] | StockMovementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutPurchaseOrderInput | StockMovementCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: StockMovementCreateManyPurchaseOrderInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseOrderInput, InvoiceUncheckedCreateWithoutPurchaseOrderInput> | InvoiceCreateWithoutPurchaseOrderInput[] | InvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseOrderInput | InvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: InvoiceCreateManyPurchaseOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<StockMovementCreateWithoutPurchaseOrderInput, StockMovementUncheckedCreateWithoutPurchaseOrderInput> | StockMovementCreateWithoutPurchaseOrderInput[] | StockMovementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutPurchaseOrderInput | StockMovementCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: StockMovementCreateManyPurchaseOrderInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type EnumDocStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocStatus
  }

  export type InvoiceUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseOrderInput, InvoiceUncheckedCreateWithoutPurchaseOrderInput> | InvoiceCreateWithoutPurchaseOrderInput[] | InvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseOrderInput | InvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput | InvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: InvoiceCreateManyPurchaseOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput | InvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPurchaseOrderInput | InvoiceUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: UserUpsertWithoutPurchaseOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseOrdersInput, UserUpdateWithoutPurchaseOrdersInput>, UserUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type StockMovementUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<StockMovementCreateWithoutPurchaseOrderInput, StockMovementUncheckedCreateWithoutPurchaseOrderInput> | StockMovementCreateWithoutPurchaseOrderInput[] | StockMovementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutPurchaseOrderInput | StockMovementCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutPurchaseOrderInput | StockMovementUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: StockMovementCreateManyPurchaseOrderInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutPurchaseOrderInput | StockMovementUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutPurchaseOrderInput | StockMovementUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutPurchaseOrderInput, InvoiceUncheckedCreateWithoutPurchaseOrderInput> | InvoiceCreateWithoutPurchaseOrderInput[] | InvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPurchaseOrderInput | InvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput | InvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: InvoiceCreateManyPurchaseOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput | InvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPurchaseOrderInput | InvoiceUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderLineCreateWithoutPurchaseOrderInput[] | PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<StockMovementCreateWithoutPurchaseOrderInput, StockMovementUncheckedCreateWithoutPurchaseOrderInput> | StockMovementCreateWithoutPurchaseOrderInput[] | StockMovementUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutPurchaseOrderInput | StockMovementCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutPurchaseOrderInput | StockMovementUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: StockMovementCreateManyPurchaseOrderInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutPurchaseOrderInput | StockMovementUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutPurchaseOrderInput | StockMovementUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutPurchaseOrderLinesInput = {
    create?: XOR<ItemCreateWithoutPurchaseOrderLinesInput, ItemUncheckedCreateWithoutPurchaseOrderLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseOrderLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutPurchaseOrderLinesNestedInput = {
    create?: XOR<ItemCreateWithoutPurchaseOrderLinesInput, ItemUncheckedCreateWithoutPurchaseOrderLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseOrderLinesInput
    upsert?: ItemUpsertWithoutPurchaseOrderLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPurchaseOrderLinesInput, ItemUpdateWithoutPurchaseOrderLinesInput>, ItemUncheckedUpdateWithoutPurchaseOrderLinesInput>
  }

  export type PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    upsert?: PurchaseOrderUpsertWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutLinesInput, PurchaseOrderUpdateWithoutLinesInput>, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type DispatchCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<DispatchCreateWithoutSalesOrderInput, DispatchUncheckedCreateWithoutSalesOrderInput> | DispatchCreateWithoutSalesOrderInput[] | DispatchUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutSalesOrderInput | DispatchCreateOrConnectWithoutSalesOrderInput[]
    createMany?: DispatchCreateManySalesOrderInputEnvelope
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<InvoiceCreateWithoutSalesOrderInput, InvoiceUncheckedCreateWithoutSalesOrderInput> | InvoiceCreateWithoutSalesOrderInput[] | InvoiceUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSalesOrderInput | InvoiceCreateOrConnectWithoutSalesOrderInput[]
    createMany?: InvoiceCreateManySalesOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SalesOrderLineCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSalesOrdersInput = {
    create?: XOR<UserCreateWithoutSalesOrdersInput, UserUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesOrdersInput = {
    create?: XOR<CustomerCreateWithoutSalesOrdersInput, CustomerUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type DispatchUncheckedCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<DispatchCreateWithoutSalesOrderInput, DispatchUncheckedCreateWithoutSalesOrderInput> | DispatchCreateWithoutSalesOrderInput[] | DispatchUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutSalesOrderInput | DispatchCreateOrConnectWithoutSalesOrderInput[]
    createMany?: DispatchCreateManySalesOrderInputEnvelope
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<InvoiceCreateWithoutSalesOrderInput, InvoiceUncheckedCreateWithoutSalesOrderInput> | InvoiceCreateWithoutSalesOrderInput[] | InvoiceUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSalesOrderInput | InvoiceCreateOrConnectWithoutSalesOrderInput[]
    createMany?: InvoiceCreateManySalesOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type DispatchUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<DispatchCreateWithoutSalesOrderInput, DispatchUncheckedCreateWithoutSalesOrderInput> | DispatchCreateWithoutSalesOrderInput[] | DispatchUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutSalesOrderInput | DispatchCreateOrConnectWithoutSalesOrderInput[]
    upsert?: DispatchUpsertWithWhereUniqueWithoutSalesOrderInput | DispatchUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: DispatchCreateManySalesOrderInputEnvelope
    set?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    disconnect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    delete?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    update?: DispatchUpdateWithWhereUniqueWithoutSalesOrderInput | DispatchUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: DispatchUpdateManyWithWhereWithoutSalesOrderInput | DispatchUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: DispatchScalarWhereInput | DispatchScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutSalesOrderInput, InvoiceUncheckedCreateWithoutSalesOrderInput> | InvoiceCreateWithoutSalesOrderInput[] | InvoiceUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSalesOrderInput | InvoiceCreateOrConnectWithoutSalesOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSalesOrderInput | InvoiceUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: InvoiceCreateManySalesOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSalesOrderInput | InvoiceUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSalesOrderInput | InvoiceUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SalesOrderLineUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput | SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type UserUpdateOneWithoutSalesOrdersNestedInput = {
    create?: XOR<UserCreateWithoutSalesOrdersInput, UserUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesOrdersInput
    upsert?: UserUpsertWithoutSalesOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesOrdersInput, UserUpdateWithoutSalesOrdersInput>, UserUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type CustomerUpdateOneRequiredWithoutSalesOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesOrdersInput, CustomerUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesOrdersInput
    upsert?: CustomerUpsertWithoutSalesOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesOrdersInput, CustomerUpdateWithoutSalesOrdersInput>, CustomerUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type DispatchUncheckedUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<DispatchCreateWithoutSalesOrderInput, DispatchUncheckedCreateWithoutSalesOrderInput> | DispatchCreateWithoutSalesOrderInput[] | DispatchUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: DispatchCreateOrConnectWithoutSalesOrderInput | DispatchCreateOrConnectWithoutSalesOrderInput[]
    upsert?: DispatchUpsertWithWhereUniqueWithoutSalesOrderInput | DispatchUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: DispatchCreateManySalesOrderInputEnvelope
    set?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    disconnect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    delete?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    connect?: DispatchWhereUniqueInput | DispatchWhereUniqueInput[]
    update?: DispatchUpdateWithWhereUniqueWithoutSalesOrderInput | DispatchUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: DispatchUpdateManyWithWhereWithoutSalesOrderInput | DispatchUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: DispatchScalarWhereInput | DispatchScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutSalesOrderInput, InvoiceUncheckedCreateWithoutSalesOrderInput> | InvoiceCreateWithoutSalesOrderInput[] | InvoiceUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSalesOrderInput | InvoiceCreateOrConnectWithoutSalesOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSalesOrderInput | InvoiceUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: InvoiceCreateManySalesOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSalesOrderInput | InvoiceUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSalesOrderInput | InvoiceUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput> | SalesOrderLineCreateWithoutSalesOrderInput[] | SalesOrderLineUncheckedCreateWithoutSalesOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutSalesOrderInput | SalesOrderLineCreateOrConnectWithoutSalesOrderInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput[]
    createMany?: SalesOrderLineCreateManySalesOrderInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput | SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput | SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutSalesOrderLinesInput = {
    create?: XOR<ItemCreateWithoutSalesOrderLinesInput, ItemUncheckedCreateWithoutSalesOrderLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSalesOrderLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLinesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutSalesOrderLinesNestedInput = {
    create?: XOR<ItemCreateWithoutSalesOrderLinesInput, ItemUncheckedCreateWithoutSalesOrderLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSalesOrderLinesInput
    upsert?: ItemUpsertWithoutSalesOrderLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSalesOrderLinesInput, ItemUpdateWithoutSalesOrderLinesInput>, ItemUncheckedUpdateWithoutSalesOrderLinesInput>
  }

  export type SalesOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLinesInput
    upsert?: SalesOrderUpsertWithoutLinesInput
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutLinesInput, SalesOrderUpdateWithoutLinesInput>, SalesOrderUncheckedUpdateWithoutLinesInput>
  }

  export type UserCreateNestedOneWithoutDispatchesInput = {
    create?: XOR<UserCreateWithoutDispatchesInput, UserUncheckedCreateWithoutDispatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispatchesInput
    connect?: UserWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutDispatchesInput = {
    create?: XOR<SalesOrderCreateWithoutDispatchesInput, SalesOrderUncheckedCreateWithoutDispatchesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutDispatchesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type UserUpdateOneWithoutDispatchesNestedInput = {
    create?: XOR<UserCreateWithoutDispatchesInput, UserUncheckedCreateWithoutDispatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDispatchesInput
    upsert?: UserUpsertWithoutDispatchesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDispatchesInput, UserUpdateWithoutDispatchesInput>, UserUncheckedUpdateWithoutDispatchesInput>
  }

  export type SalesOrderUpdateOneRequiredWithoutDispatchesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutDispatchesInput, SalesOrderUncheckedCreateWithoutDispatchesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutDispatchesInput
    upsert?: SalesOrderUpsertWithoutDispatchesInput
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutDispatchesInput, SalesOrderUpdateWithoutDispatchesInput>, SalesOrderUncheckedUpdateWithoutDispatchesInput>
  }

  export type UserCreateNestedOneWithoutProductionDaysClosedInput = {
    create?: XOR<UserCreateWithoutProductionDaysClosedInput, UserUncheckedCreateWithoutProductionDaysClosedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDaysClosedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductionDaysCreatedInput = {
    create?: XOR<UserCreateWithoutProductionDaysCreatedInput, UserUncheckedCreateWithoutProductionDaysCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDaysCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutProductionDaysInput = {
    create?: XOR<ItemCreateWithoutProductionDaysInput, ItemUncheckedCreateWithoutProductionDaysInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProductionDaysInput
    connect?: ItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductionDaysReopenedInput = {
    create?: XOR<UserCreateWithoutProductionDaysReopenedInput, UserUncheckedCreateWithoutProductionDaysReopenedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDaysReopenedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutProductionDaysClosedNestedInput = {
    create?: XOR<UserCreateWithoutProductionDaysClosedInput, UserUncheckedCreateWithoutProductionDaysClosedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDaysClosedInput
    upsert?: UserUpsertWithoutProductionDaysClosedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionDaysClosedInput, UserUpdateWithoutProductionDaysClosedInput>, UserUncheckedUpdateWithoutProductionDaysClosedInput>
  }

  export type UserUpdateOneWithoutProductionDaysCreatedNestedInput = {
    create?: XOR<UserCreateWithoutProductionDaysCreatedInput, UserUncheckedCreateWithoutProductionDaysCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDaysCreatedInput
    upsert?: UserUpsertWithoutProductionDaysCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionDaysCreatedInput, UserUpdateWithoutProductionDaysCreatedInput>, UserUncheckedUpdateWithoutProductionDaysCreatedInput>
  }

  export type ItemUpdateOneRequiredWithoutProductionDaysNestedInput = {
    create?: XOR<ItemCreateWithoutProductionDaysInput, ItemUncheckedCreateWithoutProductionDaysInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProductionDaysInput
    upsert?: ItemUpsertWithoutProductionDaysInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutProductionDaysInput, ItemUpdateWithoutProductionDaysInput>, ItemUncheckedUpdateWithoutProductionDaysInput>
  }

  export type UserUpdateOneWithoutProductionDaysReopenedNestedInput = {
    create?: XOR<UserCreateWithoutProductionDaysReopenedInput, UserUncheckedCreateWithoutProductionDaysReopenedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductionDaysReopenedInput
    upsert?: UserUpsertWithoutProductionDaysReopenedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductionDaysReopenedInput, UserUpdateWithoutProductionDaysReopenedInput>, UserUncheckedUpdateWithoutProductionDaysReopenedInput>
  }

  export type UserCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<ItemCreateWithoutStockMovementsInput, ItemUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStockMovementsInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<PurchaseOrderCreateWithoutStockMovementsInput, PurchaseOrderUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStockMovementsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type EnumMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.MovementType
  }

  export type UserUpdateOneWithoutStockMovementsNestedInput = {
    create?: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStockMovementsInput
    upsert?: UserUpsertWithoutStockMovementsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStockMovementsInput, UserUpdateWithoutStockMovementsInput>, UserUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ItemUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<ItemCreateWithoutStockMovementsInput, ItemUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStockMovementsInput
    upsert?: ItemUpsertWithoutStockMovementsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutStockMovementsInput, ItemUpdateWithoutStockMovementsInput>, ItemUncheckedUpdateWithoutStockMovementsInput>
  }

  export type PurchaseOrderUpdateOneWithoutStockMovementsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutStockMovementsInput, PurchaseOrderUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStockMovementsInput
    upsert?: PurchaseOrderUpsertWithoutStockMovementsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutStockMovementsInput, PurchaseOrderUpdateWithoutStockMovementsInput>, PurchaseOrderUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ItemCreateNestedOneWithoutStockBalanceInput = {
    create?: XOR<ItemCreateWithoutStockBalanceInput, ItemUncheckedCreateWithoutStockBalanceInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStockBalanceInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutStockBalanceNestedInput = {
    create?: XOR<ItemCreateWithoutStockBalanceInput, ItemUncheckedCreateWithoutStockBalanceInput>
    connectOrCreate?: ItemCreateOrConnectWithoutStockBalanceInput
    upsert?: ItemUpsertWithoutStockBalanceInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutStockBalanceInput, ItemUpdateWithoutStockBalanceInput>, ItemUncheckedUpdateWithoutStockBalanceInput>
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesCreatedInput = {
    create?: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoicesMatchedInput = {
    create?: XOR<UserCreateWithoutInvoicesMatchedInput, UserUncheckedCreateWithoutInvoicesMatchedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesMatchedInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutInvoicesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoicesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput
    connect?: SupplierWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type UserUpdateOneWithoutInvoicesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesCreatedInput
    upsert?: UserUpsertWithoutInvoicesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesCreatedInput, UserUpdateWithoutInvoicesCreatedInput>, UserUncheckedUpdateWithoutInvoicesCreatedInput>
  }

  export type CustomerUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneWithoutInvoicesMatchedNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesMatchedInput, UserUncheckedCreateWithoutInvoicesMatchedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesMatchedInput
    upsert?: UserUpsertWithoutInvoicesMatchedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesMatchedInput, UserUpdateWithoutInvoicesMatchedInput>, UserUncheckedUpdateWithoutInvoicesMatchedInput>
  }

  export type PurchaseOrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutInvoicesInput
    upsert?: PurchaseOrderUpsertWithoutInvoicesInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutInvoicesInput, PurchaseOrderUpdateWithoutInvoicesInput>, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type SalesOrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoicesInput
    upsert?: SalesOrderUpsertWithoutInvoicesInput
    disconnect?: SalesOrderWhereInput | boolean
    delete?: SalesOrderWhereInput | boolean
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutInvoicesInput, SalesOrderUpdateWithoutInvoicesInput>, SalesOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type SupplierUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput
    upsert?: SupplierUpsertWithoutInvoicesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutInvoicesInput, SupplierUpdateWithoutInvoicesInput>, SupplierUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInvoiceLinesInput = {
    create?: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvoiceLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    upsert?: InvoiceUpsertWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLinesInput, InvoiceUpdateWithoutLinesInput>, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneWithoutInvoiceLinesNestedInput = {
    create?: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvoiceLinesInput
    upsert?: ItemUpsertWithoutInvoiceLinesInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInvoiceLinesInput, ItemUpdateWithoutInvoiceLinesInput>, ItemUncheckedUpdateWithoutInvoiceLinesInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutExpensesInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutExpensesInput = {
    create?: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutExpensesInput
    connect?: SupplierWhereUniqueInput
  }

  export type UserUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesInput
    upsert?: UserUpsertWithoutExpensesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpensesInput, UserUpdateWithoutExpensesInput>, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type SupplierUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutExpensesInput
    upsert?: SupplierUpsertWithoutExpensesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutExpensesInput, SupplierUpdateWithoutExpensesInput>, SupplierUncheckedUpdateWithoutExpensesInput>
  }

  export type UserCreateNestedOneWithoutCashTransactionsInput = {
    create?: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTxTypeFieldUpdateOperationsInput = {
    set?: $Enums.TxType
  }

  export type UserUpdateOneWithoutCashTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashTransactionsInput
    upsert?: UserUpsertWithoutCashTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashTransactionsInput, UserUpdateWithoutCashTransactionsInput>, UserUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPayMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PayMethod | EnumPayMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayMethodFilter<$PrismaModel> | $Enums.PayMethod
  }

  export type NestedEnumPayMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayMethod | EnumPayMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayMethod[] | ListEnumPayMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayMethodWithAggregatesFilter<$PrismaModel> | $Enums.PayMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayMethodFilter<$PrismaModel>
    _max?: NestedEnumPayMethodFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusFilter<$PrismaModel> | $Enums.DocStatus
  }

  export type NestedEnumDocStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocStatus | EnumDocStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocStatus[] | ListEnumDocStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocStatusFilter<$PrismaModel>
    _max?: NestedEnumDocStatusFilter<$PrismaModel>
  }

  export type NestedEnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeFilter<$PrismaModel> | $Enums.TxType
  }

  export type NestedEnumTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxTypeFilter<$PrismaModel>
    _max?: NestedEnumTxTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutRoleInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    userId?: BigIntFilter<"User"> | bigint | number
    userCode?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type AttendanceDailyCreateWithoutRecorderInput = {
    attendanceId?: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceDailyUncheckedCreateWithoutRecorderInput = {
    attendanceId?: bigint | number
    userId: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type AttendanceDailyCreateOrConnectWithoutRecorderInput = {
    where: AttendanceDailyWhereUniqueInput
    create: XOR<AttendanceDailyCreateWithoutRecorderInput, AttendanceDailyUncheckedCreateWithoutRecorderInput>
  }

  export type AttendanceDailyCreateManyRecorderInputEnvelope = {
    data: AttendanceDailyCreateManyRecorderInput | AttendanceDailyCreateManyRecorderInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceDailyCreateWithoutUserInput = {
    attendanceId?: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    createdAt?: Date | string
    recorder?: UserCreateNestedOneWithoutRecordedAttendancesInput
  }

  export type AttendanceDailyUncheckedCreateWithoutUserInput = {
    attendanceId?: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    recordedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type AttendanceDailyCreateOrConnectWithoutUserInput = {
    where: AttendanceDailyWhereUniqueInput
    create: XOR<AttendanceDailyCreateWithoutUserInput, AttendanceDailyUncheckedCreateWithoutUserInput>
  }

  export type AttendanceDailyCreateManyUserInputEnvelope = {
    data: AttendanceDailyCreateManyUserInput | AttendanceDailyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutCreatorInput = {
    txId?: bigint | number
    txDate?: Date | string
    txType: $Enums.TxType
    sourceModule?: string | null
    refTable?: string | null
    refId?: bigint | number | null
    amountIn?: Decimal | DecimalJsLike | number | string
    amountOut?: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    note?: string | null
    createdAt?: Date | string
  }

  export type CashTransactionUncheckedCreateWithoutCreatorInput = {
    txId?: bigint | number
    txDate?: Date | string
    txType: $Enums.TxType
    sourceModule?: string | null
    refTable?: string | null
    refId?: bigint | number | null
    amountIn?: Decimal | DecimalJsLike | number | string
    amountOut?: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    note?: string | null
    createdAt?: Date | string
  }

  export type CashTransactionCreateOrConnectWithoutCreatorInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutCreatorInput, CashTransactionUncheckedCreateWithoutCreatorInput>
  }

  export type CashTransactionCreateManyCreatorInputEnvelope = {
    data: CashTransactionCreateManyCreatorInput | CashTransactionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DispatchCreateWithoutCreatorInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdAt?: Date | string
    salesOrder: SalesOrderCreateNestedOneWithoutDispatchesInput
  }

  export type DispatchUncheckedCreateWithoutCreatorInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    salesOrderId: bigint | number
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdAt?: Date | string
  }

  export type DispatchCreateOrConnectWithoutCreatorInput = {
    where: DispatchWhereUniqueInput
    create: XOR<DispatchCreateWithoutCreatorInput, DispatchUncheckedCreateWithoutCreatorInput>
  }

  export type DispatchCreateManyCreatorInputEnvelope = {
    data: DispatchCreateManyCreatorInput | DispatchCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeProfileCreateWithoutUserInput = {
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    salaryRange?: SalaryRangeCreateNestedOneWithoutEmployeeProfilesInput
  }

  export type EmployeeProfileUncheckedCreateWithoutUserInput = {
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    salaryRangeId?: bigint | number | null
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type EmployeeProfileCreateOrConnectWithoutUserInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
  }

  export type ExpenseCreateWithoutCreatorInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    createdAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutCreatorInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    supplierId?: bigint | number | null
    createdAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutCreatorInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput>
  }

  export type ExpenseCreateManyCreatorInputEnvelope = {
    data: ExpenseCreateManyCreatorInput | ExpenseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCreatorInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCreatorInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCreatorInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput>
  }

  export type InvoiceCreateManyCreatorInputEnvelope = {
    data: InvoiceCreateManyCreatorInput | InvoiceCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutMatchCheckerInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutMatchCheckerInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutMatchCheckerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutMatchCheckerInput, InvoiceUncheckedCreateWithoutMatchCheckerInput>
  }

  export type InvoiceCreateManyMatchCheckerInputEnvelope = {
    data: InvoiceCreateManyMatchCheckerInput | InvoiceCreateManyMatchCheckerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutReceiverInput = {
    paymentId?: bigint | number
    paymentNo: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutReceiverInput = {
    paymentId?: bigint | number
    paymentNo: string
    invoiceId: bigint | number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutReceiverInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReceiverInput, PaymentUncheckedCreateWithoutReceiverInput>
  }

  export type PaymentCreateManyReceiverInputEnvelope = {
    data: PaymentCreateManyReceiverInput | PaymentCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ProductionDayCreateWithoutCloserInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutProductionDaysCreatedInput
    finishedProduct: ItemCreateNestedOneWithoutProductionDaysInput
    reopener?: UserCreateNestedOneWithoutProductionDaysReopenedInput
  }

  export type ProductionDayUncheckedCreateWithoutCloserInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateOrConnectWithoutCloserInput = {
    where: ProductionDayWhereUniqueInput
    create: XOR<ProductionDayCreateWithoutCloserInput, ProductionDayUncheckedCreateWithoutCloserInput>
  }

  export type ProductionDayCreateManyCloserInputEnvelope = {
    data: ProductionDayCreateManyCloserInput | ProductionDayCreateManyCloserInput[]
    skipDuplicates?: boolean
  }

  export type ProductionDayCreateWithoutCreatorInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
    closer?: UserCreateNestedOneWithoutProductionDaysClosedInput
    finishedProduct: ItemCreateNestedOneWithoutProductionDaysInput
    reopener?: UserCreateNestedOneWithoutProductionDaysReopenedInput
  }

  export type ProductionDayUncheckedCreateWithoutCreatorInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateOrConnectWithoutCreatorInput = {
    where: ProductionDayWhereUniqueInput
    create: XOR<ProductionDayCreateWithoutCreatorInput, ProductionDayUncheckedCreateWithoutCreatorInput>
  }

  export type ProductionDayCreateManyCreatorInputEnvelope = {
    data: ProductionDayCreateManyCreatorInput | ProductionDayCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductionDayCreateWithoutReopenerInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
    closer?: UserCreateNestedOneWithoutProductionDaysClosedInput
    creator?: UserCreateNestedOneWithoutProductionDaysCreatedInput
    finishedProduct: ItemCreateNestedOneWithoutProductionDaysInput
  }

  export type ProductionDayUncheckedCreateWithoutReopenerInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateOrConnectWithoutReopenerInput = {
    where: ProductionDayWhereUniqueInput
    create: XOR<ProductionDayCreateWithoutReopenerInput, ProductionDayUncheckedCreateWithoutReopenerInput>
  }

  export type ProductionDayCreateManyReopenerInputEnvelope = {
    data: ProductionDayCreateManyReopenerInput | ProductionDayCreateManyReopenerInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutCreatorInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    stockMovements?: StockMovementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCreatorInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCreatorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput>
  }

  export type PurchaseOrderCreateManyCreatorInputEnvelope = {
    data: PurchaseOrderCreateManyCreatorInput | PurchaseOrderCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SalaryPaymentCreateWithoutPayerInput = {
    salaryPaymentId?: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    createdAt?: Date | string
    salaryRecord: SalaryRecordCreateNestedOneWithoutPaymentsInput
  }

  export type SalaryPaymentUncheckedCreateWithoutPayerInput = {
    salaryPaymentId?: bigint | number
    salaryRecordId: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    createdAt?: Date | string
  }

  export type SalaryPaymentCreateOrConnectWithoutPayerInput = {
    where: SalaryPaymentWhereUniqueInput
    create: XOR<SalaryPaymentCreateWithoutPayerInput, SalaryPaymentUncheckedCreateWithoutPayerInput>
  }

  export type SalaryPaymentCreateManyPayerInputEnvelope = {
    data: SalaryPaymentCreateManyPayerInput | SalaryPaymentCreateManyPayerInput[]
    skipDuplicates?: boolean
  }

  export type SalaryRecordCreateWithoutUserInput = {
    salaryRecordId?: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    payments?: SalaryPaymentCreateNestedManyWithoutSalaryRecordInput
    period: SalaryPeriodCreateNestedOneWithoutSalaryRecordsInput
  }

  export type SalaryRecordUncheckedCreateWithoutUserInput = {
    salaryRecordId?: bigint | number
    periodId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    payments?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryRecordInput
  }

  export type SalaryRecordCreateOrConnectWithoutUserInput = {
    where: SalaryRecordWhereUniqueInput
    create: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput>
  }

  export type SalaryRecordCreateManyUserInputEnvelope = {
    data: SalaryRecordCreateManyUserInput | SalaryRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutCreatorInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    dispatches?: DispatchCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    customer: CustomerCreateNestedOneWithoutSalesOrdersInput
  }

  export type SalesOrderUncheckedCreateWithoutCreatorInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    dispatches?: DispatchUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutCreatorInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCreatorInput, SalesOrderUncheckedCreateWithoutCreatorInput>
  }

  export type SalesOrderCreateManyCreatorInputEnvelope = {
    data: SalesOrderCreateManyCreatorInput | SalesOrderCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutCreatorInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    notes?: string | null
    createdAt?: Date | string
    item: ItemCreateNestedOneWithoutStockMovementsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutCreatorInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    itemId: bigint | number
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    purchaseId?: bigint | number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutCreatorInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput>
  }

  export type StockMovementCreateManyCreatorInputEnvelope = {
    data: StockMovementCreateManyCreatorInput | StockMovementCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    roleName: $Enums.RoleName
    idPrefix: string
    description?: string | null
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    roleId?: number
    roleName: $Enums.RoleName
    idPrefix: string
    description?: string | null
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type AttendanceDailyUpsertWithWhereUniqueWithoutRecorderInput = {
    where: AttendanceDailyWhereUniqueInput
    update: XOR<AttendanceDailyUpdateWithoutRecorderInput, AttendanceDailyUncheckedUpdateWithoutRecorderInput>
    create: XOR<AttendanceDailyCreateWithoutRecorderInput, AttendanceDailyUncheckedCreateWithoutRecorderInput>
  }

  export type AttendanceDailyUpdateWithWhereUniqueWithoutRecorderInput = {
    where: AttendanceDailyWhereUniqueInput
    data: XOR<AttendanceDailyUpdateWithoutRecorderInput, AttendanceDailyUncheckedUpdateWithoutRecorderInput>
  }

  export type AttendanceDailyUpdateManyWithWhereWithoutRecorderInput = {
    where: AttendanceDailyScalarWhereInput
    data: XOR<AttendanceDailyUpdateManyMutationInput, AttendanceDailyUncheckedUpdateManyWithoutRecorderInput>
  }

  export type AttendanceDailyScalarWhereInput = {
    AND?: AttendanceDailyScalarWhereInput | AttendanceDailyScalarWhereInput[]
    OR?: AttendanceDailyScalarWhereInput[]
    NOT?: AttendanceDailyScalarWhereInput | AttendanceDailyScalarWhereInput[]
    attendanceId?: BigIntFilter<"AttendanceDaily"> | bigint | number
    userId?: BigIntFilter<"AttendanceDaily"> | bigint | number
    workDate?: DateTimeFilter<"AttendanceDaily"> | Date | string
    timeIn?: DateTimeNullableFilter<"AttendanceDaily"> | Date | string | null
    timeOut?: DateTimeNullableFilter<"AttendanceDaily"> | Date | string | null
    systemHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFilter<"AttendanceDaily"> | Decimal | DecimalJsLike | number | string
    remarks?: StringNullableFilter<"AttendanceDaily"> | string | null
    recordedBy?: BigIntNullableFilter<"AttendanceDaily"> | bigint | number | null
    createdAt?: DateTimeFilter<"AttendanceDaily"> | Date | string
  }

  export type AttendanceDailyUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceDailyWhereUniqueInput
    update: XOR<AttendanceDailyUpdateWithoutUserInput, AttendanceDailyUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceDailyCreateWithoutUserInput, AttendanceDailyUncheckedCreateWithoutUserInput>
  }

  export type AttendanceDailyUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceDailyWhereUniqueInput
    data: XOR<AttendanceDailyUpdateWithoutUserInput, AttendanceDailyUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceDailyUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceDailyScalarWhereInput
    data: XOR<AttendanceDailyUpdateManyMutationInput, AttendanceDailyUncheckedUpdateManyWithoutUserInput>
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutCreatorInput, CashTransactionUncheckedUpdateWithoutCreatorInput>
    create: XOR<CashTransactionCreateWithoutCreatorInput, CashTransactionUncheckedCreateWithoutCreatorInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutCreatorInput, CashTransactionUncheckedUpdateWithoutCreatorInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutCreatorInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CashTransactionScalarWhereInput = {
    AND?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    OR?: CashTransactionScalarWhereInput[]
    NOT?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    txId?: BigIntFilter<"CashTransaction"> | bigint | number
    txDate?: DateTimeFilter<"CashTransaction"> | Date | string
    txType?: EnumTxTypeFilter<"CashTransaction"> | $Enums.TxType
    sourceModule?: StringNullableFilter<"CashTransaction"> | string | null
    refTable?: StringNullableFilter<"CashTransaction"> | string | null
    refId?: BigIntNullableFilter<"CashTransaction"> | bigint | number | null
    amountIn?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"CashTransaction"> | $Enums.PayMethod
    note?: StringNullableFilter<"CashTransaction"> | string | null
    createdBy?: BigIntNullableFilter<"CashTransaction"> | bigint | number | null
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
  }

  export type DispatchUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DispatchWhereUniqueInput
    update: XOR<DispatchUpdateWithoutCreatorInput, DispatchUncheckedUpdateWithoutCreatorInput>
    create: XOR<DispatchCreateWithoutCreatorInput, DispatchUncheckedCreateWithoutCreatorInput>
  }

  export type DispatchUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DispatchWhereUniqueInput
    data: XOR<DispatchUpdateWithoutCreatorInput, DispatchUncheckedUpdateWithoutCreatorInput>
  }

  export type DispatchUpdateManyWithWhereWithoutCreatorInput = {
    where: DispatchScalarWhereInput
    data: XOR<DispatchUpdateManyMutationInput, DispatchUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DispatchScalarWhereInput = {
    AND?: DispatchScalarWhereInput | DispatchScalarWhereInput[]
    OR?: DispatchScalarWhereInput[]
    NOT?: DispatchScalarWhereInput | DispatchScalarWhereInput[]
    dispatchId?: BigIntFilter<"Dispatch"> | bigint | number
    dispatchNo?: StringFilter<"Dispatch"> | string
    salesOrderId?: BigIntFilter<"Dispatch"> | bigint | number
    dispatchDate?: DateTimeFilter<"Dispatch"> | Date | string
    vehicleNo?: StringNullableFilter<"Dispatch"> | string | null
    driverName?: StringNullableFilter<"Dispatch"> | string | null
    status?: EnumDocStatusFilter<"Dispatch"> | $Enums.DocStatus
    remarks?: StringNullableFilter<"Dispatch"> | string | null
    createdBy?: BigIntNullableFilter<"Dispatch"> | bigint | number | null
    createdAt?: DateTimeFilter<"Dispatch"> | Date | string
  }

  export type EmployeeProfileUpsertWithoutUserInput = {
    update: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    where?: EmployeeProfileWhereInput
  }

  export type EmployeeProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeProfileWhereInput
    data: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeProfileUpdateWithoutUserInput = {
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    salaryRange?: SalaryRangeUpdateOneWithoutEmployeeProfilesNestedInput
  }

  export type EmployeeProfileUncheckedUpdateWithoutUserInput = {
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaryRangeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCreatorInput, ExpenseUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExpenseCreateWithoutCreatorInput, ExpenseUncheckedCreateWithoutCreatorInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCreatorInput, ExpenseUncheckedUpdateWithoutCreatorInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCreatorInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    expenseId?: BigIntFilter<"Expense"> | bigint | number
    expenseNo?: StringFilter<"Expense"> | string
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"Expense"> | $Enums.PayMethod
    paidTo?: StringNullableFilter<"Expense"> | string | null
    supplierId?: BigIntNullableFilter<"Expense"> | bigint | number | null
    createdBy?: BigIntNullableFilter<"Expense"> | bigint | number | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCreatorInput, InvoiceUncheckedUpdateWithoutCreatorInput>
    create: XOR<InvoiceCreateWithoutCreatorInput, InvoiceUncheckedCreateWithoutCreatorInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCreatorInput, InvoiceUncheckedUpdateWithoutCreatorInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCreatorInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    invoiceId?: BigIntFilter<"Invoice"> | bigint | number
    invoiceNo?: StringFilter<"Invoice"> | string
    invoiceType?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customerId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    supplierId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    salesOrderId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    purchaseId?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFilter<"Invoice"> | $Enums.DocStatus
    printTemplate?: StringFilter<"Invoice"> | string
    vendorInvoiceNo?: StringNullableFilter<"Invoice"> | string | null
    vendorInvoiceDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    vendorInvoiceTotal?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFilter<"Invoice"> | $Enums.MatchStatus
    mismatchAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    matchCheckedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdBy?: BigIntNullableFilter<"Invoice"> | bigint | number | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutMatchCheckerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutMatchCheckerInput, InvoiceUncheckedUpdateWithoutMatchCheckerInput>
    create: XOR<InvoiceCreateWithoutMatchCheckerInput, InvoiceUncheckedCreateWithoutMatchCheckerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutMatchCheckerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutMatchCheckerInput, InvoiceUncheckedUpdateWithoutMatchCheckerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutMatchCheckerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutMatchCheckerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutReceiverInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutReceiverInput, PaymentUncheckedUpdateWithoutReceiverInput>
    create: XOR<PaymentCreateWithoutReceiverInput, PaymentUncheckedCreateWithoutReceiverInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutReceiverInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutReceiverInput, PaymentUncheckedUpdateWithoutReceiverInput>
  }

  export type PaymentUpdateManyWithWhereWithoutReceiverInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutReceiverInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    paymentId?: BigIntFilter<"Payment"> | bigint | number
    paymentNo?: StringFilter<"Payment"> | string
    invoiceId?: BigIntFilter<"Payment"> | bigint | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"Payment"> | $Enums.PayMethod
    referenceNo?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    receivedBy?: BigIntNullableFilter<"Payment"> | bigint | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ProductionDayUpsertWithWhereUniqueWithoutCloserInput = {
    where: ProductionDayWhereUniqueInput
    update: XOR<ProductionDayUpdateWithoutCloserInput, ProductionDayUncheckedUpdateWithoutCloserInput>
    create: XOR<ProductionDayCreateWithoutCloserInput, ProductionDayUncheckedCreateWithoutCloserInput>
  }

  export type ProductionDayUpdateWithWhereUniqueWithoutCloserInput = {
    where: ProductionDayWhereUniqueInput
    data: XOR<ProductionDayUpdateWithoutCloserInput, ProductionDayUncheckedUpdateWithoutCloserInput>
  }

  export type ProductionDayUpdateManyWithWhereWithoutCloserInput = {
    where: ProductionDayScalarWhereInput
    data: XOR<ProductionDayUpdateManyMutationInput, ProductionDayUncheckedUpdateManyWithoutCloserInput>
  }

  export type ProductionDayScalarWhereInput = {
    AND?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
    OR?: ProductionDayScalarWhereInput[]
    NOT?: ProductionDayScalarWhereInput | ProductionDayScalarWhereInput[]
    productionDayId?: BigIntFilter<"ProductionDay"> | bigint | number
    productionDate?: DateTimeFilter<"ProductionDay"> | Date | string
    finishedProductId?: BigIntFilter<"ProductionDay"> | bigint | number
    quantity?: DecimalFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFilter<"ProductionDay"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ProductionDay"> | string | null
    isClosed?: BoolFilter<"ProductionDay"> | boolean
    closedAt?: DateTimeNullableFilter<"ProductionDay"> | Date | string | null
    closedBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    reopenReason?: StringNullableFilter<"ProductionDay"> | string | null
    reopenedBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    reopenedAt?: DateTimeNullableFilter<"ProductionDay"> | Date | string | null
    createdBy?: BigIntNullableFilter<"ProductionDay"> | bigint | number | null
    createdAt?: DateTimeFilter<"ProductionDay"> | Date | string
  }

  export type ProductionDayUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProductionDayWhereUniqueInput
    update: XOR<ProductionDayUpdateWithoutCreatorInput, ProductionDayUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProductionDayCreateWithoutCreatorInput, ProductionDayUncheckedCreateWithoutCreatorInput>
  }

  export type ProductionDayUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProductionDayWhereUniqueInput
    data: XOR<ProductionDayUpdateWithoutCreatorInput, ProductionDayUncheckedUpdateWithoutCreatorInput>
  }

  export type ProductionDayUpdateManyWithWhereWithoutCreatorInput = {
    where: ProductionDayScalarWhereInput
    data: XOR<ProductionDayUpdateManyMutationInput, ProductionDayUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProductionDayUpsertWithWhereUniqueWithoutReopenerInput = {
    where: ProductionDayWhereUniqueInput
    update: XOR<ProductionDayUpdateWithoutReopenerInput, ProductionDayUncheckedUpdateWithoutReopenerInput>
    create: XOR<ProductionDayCreateWithoutReopenerInput, ProductionDayUncheckedCreateWithoutReopenerInput>
  }

  export type ProductionDayUpdateWithWhereUniqueWithoutReopenerInput = {
    where: ProductionDayWhereUniqueInput
    data: XOR<ProductionDayUpdateWithoutReopenerInput, ProductionDayUncheckedUpdateWithoutReopenerInput>
  }

  export type ProductionDayUpdateManyWithWhereWithoutReopenerInput = {
    where: ProductionDayScalarWhereInput
    data: XOR<ProductionDayUpdateManyMutationInput, ProductionDayUncheckedUpdateManyWithoutReopenerInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCreatorInput, PurchaseOrderUncheckedUpdateWithoutCreatorInput>
    create: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCreatorInput, PurchaseOrderUncheckedUpdateWithoutCreatorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCreatorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    purchaseId?: BigIntFilter<"PurchaseOrder"> | bigint | number
    purchaseNo?: StringFilter<"PurchaseOrder"> | string
    supplierId?: BigIntFilter<"PurchaseOrder"> | bigint | number
    purchaseDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    status?: EnumDocStatusFilter<"PurchaseOrder"> | $Enums.DocStatus
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    subtotal?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    createdBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    confirmedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    receivedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    cancelledAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    cancelledBy?: BigIntNullableFilter<"PurchaseOrder"> | bigint | number | null
    cancelReason?: StringNullableFilter<"PurchaseOrder"> | string | null
  }

  export type SalaryPaymentUpsertWithWhereUniqueWithoutPayerInput = {
    where: SalaryPaymentWhereUniqueInput
    update: XOR<SalaryPaymentUpdateWithoutPayerInput, SalaryPaymentUncheckedUpdateWithoutPayerInput>
    create: XOR<SalaryPaymentCreateWithoutPayerInput, SalaryPaymentUncheckedCreateWithoutPayerInput>
  }

  export type SalaryPaymentUpdateWithWhereUniqueWithoutPayerInput = {
    where: SalaryPaymentWhereUniqueInput
    data: XOR<SalaryPaymentUpdateWithoutPayerInput, SalaryPaymentUncheckedUpdateWithoutPayerInput>
  }

  export type SalaryPaymentUpdateManyWithWhereWithoutPayerInput = {
    where: SalaryPaymentScalarWhereInput
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyWithoutPayerInput>
  }

  export type SalaryPaymentScalarWhereInput = {
    AND?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    OR?: SalaryPaymentScalarWhereInput[]
    NOT?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    salaryPaymentId?: BigIntFilter<"SalaryPayment"> | bigint | number
    salaryRecordId?: BigIntFilter<"SalaryPayment"> | bigint | number
    payDate?: DateTimeFilter<"SalaryPayment"> | Date | string
    amount?: DecimalFilter<"SalaryPayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFilter<"SalaryPayment"> | $Enums.PayMethod
    referenceNo?: StringNullableFilter<"SalaryPayment"> | string | null
    paidBy?: BigIntNullableFilter<"SalaryPayment"> | bigint | number | null
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
  }

  export type SalaryRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: SalaryRecordWhereUniqueInput
    update: XOR<SalaryRecordUpdateWithoutUserInput, SalaryRecordUncheckedUpdateWithoutUserInput>
    create: XOR<SalaryRecordCreateWithoutUserInput, SalaryRecordUncheckedCreateWithoutUserInput>
  }

  export type SalaryRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: SalaryRecordWhereUniqueInput
    data: XOR<SalaryRecordUpdateWithoutUserInput, SalaryRecordUncheckedUpdateWithoutUserInput>
  }

  export type SalaryRecordUpdateManyWithWhereWithoutUserInput = {
    where: SalaryRecordScalarWhereInput
    data: XOR<SalaryRecordUpdateManyMutationInput, SalaryRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type SalaryRecordScalarWhereInput = {
    AND?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
    OR?: SalaryRecordScalarWhereInput[]
    NOT?: SalaryRecordScalarWhereInput | SalaryRecordScalarWhereInput[]
    salaryRecordId?: BigIntFilter<"SalaryRecord"> | bigint | number
    periodId?: BigIntFilter<"SalaryRecord"> | bigint | number
    userId?: BigIntFilter<"SalaryRecord"> | bigint | number
    baseSalary?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFilter<"SalaryRecord"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SalaryRecord"> | string
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCreatorInput, SalesOrderUncheckedUpdateWithoutCreatorInput>
    create: XOR<SalesOrderCreateWithoutCreatorInput, SalesOrderUncheckedCreateWithoutCreatorInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCreatorInput, SalesOrderUncheckedUpdateWithoutCreatorInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCreatorInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SalesOrderScalarWhereInput = {
    AND?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    OR?: SalesOrderScalarWhereInput[]
    NOT?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    salesOrderId?: BigIntFilter<"SalesOrder"> | bigint | number
    orderNo?: StringFilter<"SalesOrder"> | string
    customerId?: BigIntFilter<"SalesOrder"> | bigint | number
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    status?: EnumDocStatusFilter<"SalesOrder"> | $Enums.DocStatus
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    subtotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFilter<"SalesOrder"> | boolean
    createdBy?: BigIntNullableFilter<"SalesOrder"> | bigint | number | null
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutCreatorInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutCreatorInput, StockMovementUncheckedUpdateWithoutCreatorInput>
    create: XOR<StockMovementCreateWithoutCreatorInput, StockMovementUncheckedCreateWithoutCreatorInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutCreatorInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutCreatorInput, StockMovementUncheckedUpdateWithoutCreatorInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutCreatorInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutCreatorInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    stockMovementId?: BigIntFilter<"StockMovement"> | bigint | number
    movementDate?: DateTimeFilter<"StockMovement"> | Date | string
    movementType?: EnumMovementTypeFilter<"StockMovement"> | $Enums.MovementType
    itemId?: BigIntFilter<"StockMovement"> | bigint | number
    qtyIn?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    refTable?: StringNullableFilter<"StockMovement"> | string | null
    refId?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    purchaseId?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    notes?: StringNullableFilter<"StockMovement"> | string | null
    createdBy?: BigIntNullableFilter<"StockMovement"> | bigint | number | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    idPrefix?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    idPrefix?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeProfileCreateWithoutSalaryRangeInput = {
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    user: UserCreateNestedOneWithoutEmployeeProfileInput
  }

  export type EmployeeProfileUncheckedCreateWithoutSalaryRangeInput = {
    userId: bigint | number
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type EmployeeProfileCreateOrConnectWithoutSalaryRangeInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutSalaryRangeInput, EmployeeProfileUncheckedCreateWithoutSalaryRangeInput>
  }

  export type EmployeeProfileCreateManySalaryRangeInputEnvelope = {
    data: EmployeeProfileCreateManySalaryRangeInput | EmployeeProfileCreateManySalaryRangeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeProfileUpsertWithWhereUniqueWithoutSalaryRangeInput = {
    where: EmployeeProfileWhereUniqueInput
    update: XOR<EmployeeProfileUpdateWithoutSalaryRangeInput, EmployeeProfileUncheckedUpdateWithoutSalaryRangeInput>
    create: XOR<EmployeeProfileCreateWithoutSalaryRangeInput, EmployeeProfileUncheckedCreateWithoutSalaryRangeInput>
  }

  export type EmployeeProfileUpdateWithWhereUniqueWithoutSalaryRangeInput = {
    where: EmployeeProfileWhereUniqueInput
    data: XOR<EmployeeProfileUpdateWithoutSalaryRangeInput, EmployeeProfileUncheckedUpdateWithoutSalaryRangeInput>
  }

  export type EmployeeProfileUpdateManyWithWhereWithoutSalaryRangeInput = {
    where: EmployeeProfileScalarWhereInput
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyWithoutSalaryRangeInput>
  }

  export type EmployeeProfileScalarWhereInput = {
    AND?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
    OR?: EmployeeProfileScalarWhereInput[]
    NOT?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
    userId?: BigIntFilter<"EmployeeProfile"> | bigint | number
    nic?: StringNullableFilter<"EmployeeProfile"> | string | null
    address?: StringNullableFilter<"EmployeeProfile"> | string | null
    joinedDate?: DateTimeNullableFilter<"EmployeeProfile"> | Date | string | null
    designation?: StringNullableFilter<"EmployeeProfile"> | string | null
    basicSalary?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    salaryRangeId?: BigIntNullableFilter<"EmployeeProfile"> | bigint | number | null
    otRate?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"EmployeeProfile"> | string | null
  }

  export type SalaryRangeCreateWithoutEmployeeProfilesInput = {
    salaryRangeId?: bigint | number
    rangeName: string
    minSalary?: Decimal | DecimalJsLike | number | string
    maxSalary?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SalaryRangeUncheckedCreateWithoutEmployeeProfilesInput = {
    salaryRangeId?: bigint | number
    rangeName: string
    minSalary?: Decimal | DecimalJsLike | number | string
    maxSalary?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SalaryRangeCreateOrConnectWithoutEmployeeProfilesInput = {
    where: SalaryRangeWhereUniqueInput
    create: XOR<SalaryRangeCreateWithoutEmployeeProfilesInput, SalaryRangeUncheckedCreateWithoutEmployeeProfilesInput>
  }

  export type UserCreateWithoutEmployeeProfileInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEmployeeProfileInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutEmployeeProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
  }

  export type SalaryRangeUpsertWithoutEmployeeProfilesInput = {
    update: XOR<SalaryRangeUpdateWithoutEmployeeProfilesInput, SalaryRangeUncheckedUpdateWithoutEmployeeProfilesInput>
    create: XOR<SalaryRangeCreateWithoutEmployeeProfilesInput, SalaryRangeUncheckedCreateWithoutEmployeeProfilesInput>
    where?: SalaryRangeWhereInput
  }

  export type SalaryRangeUpdateToOneWithWhereWithoutEmployeeProfilesInput = {
    where?: SalaryRangeWhereInput
    data: XOR<SalaryRangeUpdateWithoutEmployeeProfilesInput, SalaryRangeUncheckedUpdateWithoutEmployeeProfilesInput>
  }

  export type SalaryRangeUpdateWithoutEmployeeProfilesInput = {
    salaryRangeId?: BigIntFieldUpdateOperationsInput | bigint | number
    rangeName?: StringFieldUpdateOperationsInput | string
    minSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRangeUncheckedUpdateWithoutEmployeeProfilesInput = {
    salaryRangeId?: BigIntFieldUpdateOperationsInput | bigint | number
    rangeName?: StringFieldUpdateOperationsInput | string
    minSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEmployeeProfileInput = {
    update: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type UserUpdateWithoutEmployeeProfileInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeProfileInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutRecordedAttendancesInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRecordedAttendancesInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRecordedAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
  }

  export type UserCreateWithoutAttendancesInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type UserUpsertWithoutRecordedAttendancesInput = {
    update: XOR<UserUpdateWithoutRecordedAttendancesInput, UserUncheckedUpdateWithoutRecordedAttendancesInput>
    create: XOR<UserCreateWithoutRecordedAttendancesInput, UserUncheckedCreateWithoutRecordedAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecordedAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecordedAttendancesInput, UserUncheckedUpdateWithoutRecordedAttendancesInput>
  }

  export type UserUpdateWithoutRecordedAttendancesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRecordedAttendancesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SalaryRecordCreateWithoutPeriodInput = {
    salaryRecordId?: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    payments?: SalaryPaymentCreateNestedManyWithoutSalaryRecordInput
    user: UserCreateNestedOneWithoutSalaryRecordsInput
  }

  export type SalaryRecordUncheckedCreateWithoutPeriodInput = {
    salaryRecordId?: bigint | number
    userId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    payments?: SalaryPaymentUncheckedCreateNestedManyWithoutSalaryRecordInput
  }

  export type SalaryRecordCreateOrConnectWithoutPeriodInput = {
    where: SalaryRecordWhereUniqueInput
    create: XOR<SalaryRecordCreateWithoutPeriodInput, SalaryRecordUncheckedCreateWithoutPeriodInput>
  }

  export type SalaryRecordCreateManyPeriodInputEnvelope = {
    data: SalaryRecordCreateManyPeriodInput | SalaryRecordCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type SalaryRecordUpsertWithWhereUniqueWithoutPeriodInput = {
    where: SalaryRecordWhereUniqueInput
    update: XOR<SalaryRecordUpdateWithoutPeriodInput, SalaryRecordUncheckedUpdateWithoutPeriodInput>
    create: XOR<SalaryRecordCreateWithoutPeriodInput, SalaryRecordUncheckedCreateWithoutPeriodInput>
  }

  export type SalaryRecordUpdateWithWhereUniqueWithoutPeriodInput = {
    where: SalaryRecordWhereUniqueInput
    data: XOR<SalaryRecordUpdateWithoutPeriodInput, SalaryRecordUncheckedUpdateWithoutPeriodInput>
  }

  export type SalaryRecordUpdateManyWithWhereWithoutPeriodInput = {
    where: SalaryRecordScalarWhereInput
    data: XOR<SalaryRecordUpdateManyMutationInput, SalaryRecordUncheckedUpdateManyWithoutPeriodInput>
  }

  export type SalaryPaymentCreateWithoutSalaryRecordInput = {
    salaryPaymentId?: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    createdAt?: Date | string
    payer?: UserCreateNestedOneWithoutSalaryPaymentsPaidInput
  }

  export type SalaryPaymentUncheckedCreateWithoutSalaryRecordInput = {
    salaryPaymentId?: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    paidBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalaryPaymentCreateOrConnectWithoutSalaryRecordInput = {
    where: SalaryPaymentWhereUniqueInput
    create: XOR<SalaryPaymentCreateWithoutSalaryRecordInput, SalaryPaymentUncheckedCreateWithoutSalaryRecordInput>
  }

  export type SalaryPaymentCreateManySalaryRecordInputEnvelope = {
    data: SalaryPaymentCreateManySalaryRecordInput | SalaryPaymentCreateManySalaryRecordInput[]
    skipDuplicates?: boolean
  }

  export type SalaryPeriodCreateWithoutSalaryRecordsInput = {
    periodId?: bigint | number
    year: number
    month: number
    startDate: Date | string
    endDate: Date | string
    status?: string
  }

  export type SalaryPeriodUncheckedCreateWithoutSalaryRecordsInput = {
    periodId?: bigint | number
    year: number
    month: number
    startDate: Date | string
    endDate: Date | string
    status?: string
  }

  export type SalaryPeriodCreateOrConnectWithoutSalaryRecordsInput = {
    where: SalaryPeriodWhereUniqueInput
    create: XOR<SalaryPeriodCreateWithoutSalaryRecordsInput, SalaryPeriodUncheckedCreateWithoutSalaryRecordsInput>
  }

  export type UserCreateWithoutSalaryRecordsInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSalaryRecordsInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSalaryRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
  }

  export type SalaryPaymentUpsertWithWhereUniqueWithoutSalaryRecordInput = {
    where: SalaryPaymentWhereUniqueInput
    update: XOR<SalaryPaymentUpdateWithoutSalaryRecordInput, SalaryPaymentUncheckedUpdateWithoutSalaryRecordInput>
    create: XOR<SalaryPaymentCreateWithoutSalaryRecordInput, SalaryPaymentUncheckedCreateWithoutSalaryRecordInput>
  }

  export type SalaryPaymentUpdateWithWhereUniqueWithoutSalaryRecordInput = {
    where: SalaryPaymentWhereUniqueInput
    data: XOR<SalaryPaymentUpdateWithoutSalaryRecordInput, SalaryPaymentUncheckedUpdateWithoutSalaryRecordInput>
  }

  export type SalaryPaymentUpdateManyWithWhereWithoutSalaryRecordInput = {
    where: SalaryPaymentScalarWhereInput
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyWithoutSalaryRecordInput>
  }

  export type SalaryPeriodUpsertWithoutSalaryRecordsInput = {
    update: XOR<SalaryPeriodUpdateWithoutSalaryRecordsInput, SalaryPeriodUncheckedUpdateWithoutSalaryRecordsInput>
    create: XOR<SalaryPeriodCreateWithoutSalaryRecordsInput, SalaryPeriodUncheckedCreateWithoutSalaryRecordsInput>
    where?: SalaryPeriodWhereInput
  }

  export type SalaryPeriodUpdateToOneWithWhereWithoutSalaryRecordsInput = {
    where?: SalaryPeriodWhereInput
    data: XOR<SalaryPeriodUpdateWithoutSalaryRecordsInput, SalaryPeriodUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type SalaryPeriodUpdateWithoutSalaryRecordsInput = {
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPeriodUncheckedUpdateWithoutSalaryRecordsInput = {
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutSalaryRecordsInput = {
    update: XOR<UserUpdateWithoutSalaryRecordsInput, UserUncheckedUpdateWithoutSalaryRecordsInput>
    create: XOR<UserCreateWithoutSalaryRecordsInput, UserUncheckedCreateWithoutSalaryRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryRecordsInput, UserUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type UserUpdateWithoutSalaryRecordsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryRecordsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSalaryPaymentsPaidInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSalaryPaymentsPaidInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSalaryPaymentsPaidInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryPaymentsPaidInput, UserUncheckedCreateWithoutSalaryPaymentsPaidInput>
  }

  export type SalaryRecordCreateWithoutPaymentsInput = {
    salaryRecordId?: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
    period: SalaryPeriodCreateNestedOneWithoutSalaryRecordsInput
    user: UserCreateNestedOneWithoutSalaryRecordsInput
  }

  export type SalaryRecordUncheckedCreateWithoutPaymentsInput = {
    salaryRecordId?: bigint | number
    periodId: bigint | number
    userId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type SalaryRecordCreateOrConnectWithoutPaymentsInput = {
    where: SalaryRecordWhereUniqueInput
    create: XOR<SalaryRecordCreateWithoutPaymentsInput, SalaryRecordUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutSalaryPaymentsPaidInput = {
    update: XOR<UserUpdateWithoutSalaryPaymentsPaidInput, UserUncheckedUpdateWithoutSalaryPaymentsPaidInput>
    create: XOR<UserCreateWithoutSalaryPaymentsPaidInput, UserUncheckedCreateWithoutSalaryPaymentsPaidInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryPaymentsPaidInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryPaymentsPaidInput, UserUncheckedUpdateWithoutSalaryPaymentsPaidInput>
  }

  export type UserUpdateWithoutSalaryPaymentsPaidInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryPaymentsPaidInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SalaryRecordUpsertWithoutPaymentsInput = {
    update: XOR<SalaryRecordUpdateWithoutPaymentsInput, SalaryRecordUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SalaryRecordCreateWithoutPaymentsInput, SalaryRecordUncheckedCreateWithoutPaymentsInput>
    where?: SalaryRecordWhereInput
  }

  export type SalaryRecordUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SalaryRecordWhereInput
    data: XOR<SalaryRecordUpdateWithoutPaymentsInput, SalaryRecordUncheckedUpdateWithoutPaymentsInput>
  }

  export type SalaryRecordUpdateWithoutPaymentsInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    period?: SalaryPeriodUpdateOneRequiredWithoutSalaryRecordsNestedInput
    user?: UserUpdateOneRequiredWithoutSalaryRecordsNestedInput
  }

  export type SalaryRecordUncheckedUpdateWithoutPaymentsInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateWithoutUnitInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutUnitInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutUnitInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemCreateManyUnitInputEnvelope = {
    data: ItemCreateManyUnitInput | ItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
  }

  export type ItemUpdateManyWithWhereWithoutUnitInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    itemId?: BigIntFilter<"Item"> | bigint | number
    itemCode?: StringFilter<"Item"> | string
    itemName?: StringFilter<"Item"> | string
    itemType?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    categoryId?: IntNullableFilter<"Item"> | number | null
    unitId?: IntNullableFilter<"Item"> | number | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
  }

  export type ItemCreateWithoutCategoryInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCategoryInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCreateManyCategoryInputEnvelope = {
    data: ItemCreateManyCategoryInput | ItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CustomerItemPriceCreateWithoutItemInput = {
    customerItemPriceId?: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    customer: CustomerCreateNestedOneWithoutItemPricesInput
  }

  export type CustomerItemPriceUncheckedCreateWithoutItemInput = {
    customerItemPriceId?: bigint | number
    customerId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type CustomerItemPriceCreateOrConnectWithoutItemInput = {
    where: CustomerItemPriceWhereUniqueInput
    create: XOR<CustomerItemPriceCreateWithoutItemInput, CustomerItemPriceUncheckedCreateWithoutItemInput>
  }

  export type CustomerItemPriceCreateManyItemInputEnvelope = {
    data: CustomerItemPriceCreateManyItemInput | CustomerItemPriceCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineCreateWithoutItemInput = {
    invoiceLineId?: bigint | number
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
  }

  export type InvoiceLineUncheckedCreateWithoutItemInput = {
    invoiceLineId?: bigint | number
    invoiceId: bigint | number
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineCreateOrConnectWithoutItemInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutItemInput, InvoiceLineUncheckedCreateWithoutItemInput>
  }

  export type InvoiceLineCreateManyItemInputEnvelope = {
    data: InvoiceLineCreateManyItemInput | InvoiceLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemCategoryCreateWithoutItemsInput = {
    categoryName: string
  }

  export type ItemCategoryUncheckedCreateWithoutItemsInput = {
    categoryId?: number
    categoryName: string
  }

  export type ItemCategoryCreateOrConnectWithoutItemsInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
  }

  export type UnitCreateWithoutItemsInput = {
    unitName: string
    symbol?: string | null
  }

  export type UnitUncheckedCreateWithoutItemsInput = {
    unitId?: number
    unitName: string
    symbol?: string | null
  }

  export type UnitCreateOrConnectWithoutItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
  }

  export type ProductionDayCreateWithoutFinishedProductInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
    closer?: UserCreateNestedOneWithoutProductionDaysClosedInput
    creator?: UserCreateNestedOneWithoutProductionDaysCreatedInput
    reopener?: UserCreateNestedOneWithoutProductionDaysReopenedInput
  }

  export type ProductionDayUncheckedCreateWithoutFinishedProductInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateOrConnectWithoutFinishedProductInput = {
    where: ProductionDayWhereUniqueInput
    create: XOR<ProductionDayCreateWithoutFinishedProductInput, ProductionDayUncheckedCreateWithoutFinishedProductInput>
  }

  export type ProductionDayCreateManyFinishedProductInputEnvelope = {
    data: ProductionDayCreateManyFinishedProductInput | ProductionDayCreateManyFinishedProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderLineCreateWithoutItemInput = {
    purchaseLineId?: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutItemInput = {
    purchaseLineId?: bigint | number
    purchaseId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
  }

  export type PurchaseOrderLineCreateOrConnectWithoutItemInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseOrderLineCreateManyItemInputEnvelope = {
    data: PurchaseOrderLineCreateManyItemInput | PurchaseOrderLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderLineCreateWithoutItemInput = {
    salesOrderLineId?: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    salesOrder: SalesOrderCreateNestedOneWithoutLinesInput
  }

  export type SalesOrderLineUncheckedCreateWithoutItemInput = {
    salesOrderLineId?: bigint | number
    salesOrderId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutItemInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput>
  }

  export type SalesOrderLineCreateManyItemInputEnvelope = {
    data: SalesOrderLineCreateManyItemInput | SalesOrderLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type StockBalanceCreateWithoutItemInput = {
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type StockBalanceUncheckedCreateWithoutItemInput = {
    qtyOnHand?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type StockBalanceCreateOrConnectWithoutItemInput = {
    where: StockBalanceWhereUniqueInput
    create: XOR<StockBalanceCreateWithoutItemInput, StockBalanceUncheckedCreateWithoutItemInput>
  }

  export type StockMovementCreateWithoutItemInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    notes?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutStockMovementsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutItemInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    purchaseId?: bigint | number | null
    notes?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutItemInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutItemInput, StockMovementUncheckedCreateWithoutItemInput>
  }

  export type StockMovementCreateManyItemInputEnvelope = {
    data: StockMovementCreateManyItemInput | StockMovementCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SupplierItemPriceCreateWithoutItemInput = {
    supplierItemPriceId?: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    supplier: SupplierCreateNestedOneWithoutItemPricesInput
  }

  export type SupplierItemPriceUncheckedCreateWithoutItemInput = {
    supplierItemPriceId?: bigint | number
    supplierId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type SupplierItemPriceCreateOrConnectWithoutItemInput = {
    where: SupplierItemPriceWhereUniqueInput
    create: XOR<SupplierItemPriceCreateWithoutItemInput, SupplierItemPriceUncheckedCreateWithoutItemInput>
  }

  export type SupplierItemPriceCreateManyItemInputEnvelope = {
    data: SupplierItemPriceCreateManyItemInput | SupplierItemPriceCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type CustomerItemPriceUpsertWithWhereUniqueWithoutItemInput = {
    where: CustomerItemPriceWhereUniqueInput
    update: XOR<CustomerItemPriceUpdateWithoutItemInput, CustomerItemPriceUncheckedUpdateWithoutItemInput>
    create: XOR<CustomerItemPriceCreateWithoutItemInput, CustomerItemPriceUncheckedCreateWithoutItemInput>
  }

  export type CustomerItemPriceUpdateWithWhereUniqueWithoutItemInput = {
    where: CustomerItemPriceWhereUniqueInput
    data: XOR<CustomerItemPriceUpdateWithoutItemInput, CustomerItemPriceUncheckedUpdateWithoutItemInput>
  }

  export type CustomerItemPriceUpdateManyWithWhereWithoutItemInput = {
    where: CustomerItemPriceScalarWhereInput
    data: XOR<CustomerItemPriceUpdateManyMutationInput, CustomerItemPriceUncheckedUpdateManyWithoutItemInput>
  }

  export type CustomerItemPriceScalarWhereInput = {
    AND?: CustomerItemPriceScalarWhereInput | CustomerItemPriceScalarWhereInput[]
    OR?: CustomerItemPriceScalarWhereInput[]
    NOT?: CustomerItemPriceScalarWhereInput | CustomerItemPriceScalarWhereInput[]
    customerItemPriceId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    customerId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    itemId?: BigIntFilter<"CustomerItemPrice"> | bigint | number
    unitPrice?: DecimalFilter<"CustomerItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    endDate?: DateTimeNullableFilter<"CustomerItemPrice"> | Date | string | null
    isActive?: BoolFilter<"CustomerItemPrice"> | boolean
    createdAt?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerItemPrice"> | Date | string
    createdBy?: BigIntNullableFilter<"CustomerItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"CustomerItemPrice"> | bigint | number | null
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutItemInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutItemInput, InvoiceLineUncheckedUpdateWithoutItemInput>
    create: XOR<InvoiceLineCreateWithoutItemInput, InvoiceLineUncheckedCreateWithoutItemInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutItemInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutItemInput, InvoiceLineUncheckedUpdateWithoutItemInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutItemInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutItemInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    invoiceLineId?: BigIntFilter<"InvoiceLine"> | bigint | number
    invoiceId?: BigIntFilter<"InvoiceLine"> | bigint | number
    itemId?: BigIntNullableFilter<"InvoiceLine"> | bigint | number | null
    description?: StringNullableFilter<"InvoiceLine"> | string | null
    qty?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"InvoiceLine"> | Decimal | DecimalJsLike | number | string
  }

  export type ItemCategoryUpsertWithoutItemsInput = {
    update: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryUpdateWithoutItemsInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCategoryUncheckedUpdateWithoutItemsInput = {
    categoryId?: IntFieldUpdateOperationsInput | number
    categoryName?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUpsertWithoutItemsInput = {
    update: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type UnitUpdateWithoutItemsInput = {
    unitName?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitUncheckedUpdateWithoutItemsInput = {
    unitId?: IntFieldUpdateOperationsInput | number
    unitName?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductionDayUpsertWithWhereUniqueWithoutFinishedProductInput = {
    where: ProductionDayWhereUniqueInput
    update: XOR<ProductionDayUpdateWithoutFinishedProductInput, ProductionDayUncheckedUpdateWithoutFinishedProductInput>
    create: XOR<ProductionDayCreateWithoutFinishedProductInput, ProductionDayUncheckedCreateWithoutFinishedProductInput>
  }

  export type ProductionDayUpdateWithWhereUniqueWithoutFinishedProductInput = {
    where: ProductionDayWhereUniqueInput
    data: XOR<ProductionDayUpdateWithoutFinishedProductInput, ProductionDayUncheckedUpdateWithoutFinishedProductInput>
  }

  export type ProductionDayUpdateManyWithWhereWithoutFinishedProductInput = {
    where: ProductionDayScalarWhereInput
    data: XOR<ProductionDayUpdateManyMutationInput, ProductionDayUncheckedUpdateManyWithoutFinishedProductInput>
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutItemInput, PurchaseOrderLineUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutItemInput, PurchaseOrderLineUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseOrderLineScalarWhereInput = {
    AND?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    OR?: PurchaseOrderLineScalarWhereInput[]
    NOT?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    purchaseLineId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    purchaseId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    itemId?: BigIntFilter<"PurchaseOrderLine"> | bigint | number
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    priceSource?: StringFilter<"PurchaseOrderLine"> | string
    overrideReason?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    overriddenBy?: BigIntNullableFilter<"PurchaseOrderLine"> | bigint | number | null
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutItemInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutItemInput, SalesOrderLineUncheckedUpdateWithoutItemInput>
    create: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutItemInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutItemInput, SalesOrderLineUncheckedUpdateWithoutItemInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutItemInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutItemInput>
  }

  export type SalesOrderLineScalarWhereInput = {
    AND?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
    OR?: SalesOrderLineScalarWhereInput[]
    NOT?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
    salesOrderLineId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    salesOrderId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    itemId?: BigIntFilter<"SalesOrderLine"> | bigint | number
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type StockBalanceUpsertWithoutItemInput = {
    update: XOR<StockBalanceUpdateWithoutItemInput, StockBalanceUncheckedUpdateWithoutItemInput>
    create: XOR<StockBalanceCreateWithoutItemInput, StockBalanceUncheckedCreateWithoutItemInput>
    where?: StockBalanceWhereInput
  }

  export type StockBalanceUpdateToOneWithWhereWithoutItemInput = {
    where?: StockBalanceWhereInput
    data: XOR<StockBalanceUpdateWithoutItemInput, StockBalanceUncheckedUpdateWithoutItemInput>
  }

  export type StockBalanceUpdateWithoutItemInput = {
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockBalanceUncheckedUpdateWithoutItemInput = {
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutItemInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutItemInput, StockMovementUncheckedUpdateWithoutItemInput>
    create: XOR<StockMovementCreateWithoutItemInput, StockMovementUncheckedCreateWithoutItemInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutItemInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutItemInput, StockMovementUncheckedUpdateWithoutItemInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutItemInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutItemInput>
  }

  export type SupplierItemPriceUpsertWithWhereUniqueWithoutItemInput = {
    where: SupplierItemPriceWhereUniqueInput
    update: XOR<SupplierItemPriceUpdateWithoutItemInput, SupplierItemPriceUncheckedUpdateWithoutItemInput>
    create: XOR<SupplierItemPriceCreateWithoutItemInput, SupplierItemPriceUncheckedCreateWithoutItemInput>
  }

  export type SupplierItemPriceUpdateWithWhereUniqueWithoutItemInput = {
    where: SupplierItemPriceWhereUniqueInput
    data: XOR<SupplierItemPriceUpdateWithoutItemInput, SupplierItemPriceUncheckedUpdateWithoutItemInput>
  }

  export type SupplierItemPriceUpdateManyWithWhereWithoutItemInput = {
    where: SupplierItemPriceScalarWhereInput
    data: XOR<SupplierItemPriceUpdateManyMutationInput, SupplierItemPriceUncheckedUpdateManyWithoutItemInput>
  }

  export type SupplierItemPriceScalarWhereInput = {
    AND?: SupplierItemPriceScalarWhereInput | SupplierItemPriceScalarWhereInput[]
    OR?: SupplierItemPriceScalarWhereInput[]
    NOT?: SupplierItemPriceScalarWhereInput | SupplierItemPriceScalarWhereInput[]
    supplierItemPriceId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    supplierId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    itemId?: BigIntFilter<"SupplierItemPrice"> | bigint | number
    unitPrice?: DecimalFilter<"SupplierItemPrice"> | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierItemPrice"> | Date | string | null
    isActive?: BoolFilter<"SupplierItemPrice"> | boolean
    createdAt?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierItemPrice"> | Date | string
    createdBy?: BigIntNullableFilter<"SupplierItemPrice"> | bigint | number | null
    updatedBy?: BigIntNullableFilter<"SupplierItemPrice"> | bigint | number | null
  }

  export type ExpenseCreateWithoutSupplierInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutSupplierInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput>
  }

  export type ExpenseCreateManySupplierInputEnvelope = {
    data: ExpenseCreateManySupplierInput | ExpenseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutSupplierInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSupplierInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type InvoiceCreateManySupplierInputEnvelope = {
    data: InvoiceCreateManySupplierInput | InvoiceCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    creator?: UserCreateNestedOneWithoutPurchaseOrdersInput
    stockMovements?: StockMovementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierItemPriceCreateWithoutSupplierInput = {
    supplierItemPriceId?: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    item: ItemCreateNestedOneWithoutSupplierPricesInput
  }

  export type SupplierItemPriceUncheckedCreateWithoutSupplierInput = {
    supplierItemPriceId?: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type SupplierItemPriceCreateOrConnectWithoutSupplierInput = {
    where: SupplierItemPriceWhereUniqueInput
    create: XOR<SupplierItemPriceCreateWithoutSupplierInput, SupplierItemPriceUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierItemPriceCreateManySupplierInputEnvelope = {
    data: SupplierItemPriceCreateManySupplierInput | SupplierItemPriceCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutSupplierInput, ExpenseUncheckedUpdateWithoutSupplierInput>
    create: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutSupplierInput, ExpenseUncheckedUpdateWithoutSupplierInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutSupplierInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSupplierInput, InvoiceUncheckedUpdateWithoutSupplierInput>
    create: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSupplierInput, InvoiceUncheckedUpdateWithoutSupplierInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSupplierInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierItemPriceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierItemPriceWhereUniqueInput
    update: XOR<SupplierItemPriceUpdateWithoutSupplierInput, SupplierItemPriceUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierItemPriceCreateWithoutSupplierInput, SupplierItemPriceUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierItemPriceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierItemPriceWhereUniqueInput
    data: XOR<SupplierItemPriceUpdateWithoutSupplierInput, SupplierItemPriceUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierItemPriceUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierItemPriceScalarWhereInput
    data: XOR<SupplierItemPriceUpdateManyMutationInput, SupplierItemPriceUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CustomerItemPriceCreateWithoutCustomerInput = {
    customerItemPriceId?: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    item: ItemCreateNestedOneWithoutCustomerPricesInput
  }

  export type CustomerItemPriceUncheckedCreateWithoutCustomerInput = {
    customerItemPriceId?: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type CustomerItemPriceCreateOrConnectWithoutCustomerInput = {
    where: CustomerItemPriceWhereUniqueInput
    create: XOR<CustomerItemPriceCreateWithoutCustomerInput, CustomerItemPriceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerItemPriceCreateManyCustomerInputEnvelope = {
    data: CustomerItemPriceCreateManyCustomerInput | CustomerItemPriceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutCustomerInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    dispatches?: DispatchCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    creator?: UserCreateNestedOneWithoutSalesOrdersInput
  }

  export type SalesOrderUncheckedCreateWithoutCustomerInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
    dispatches?: DispatchUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderCreateManyCustomerInputEnvelope = {
    data: SalesOrderCreateManyCustomerInput | SalesOrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerItemPriceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerItemPriceWhereUniqueInput
    update: XOR<CustomerItemPriceUpdateWithoutCustomerInput, CustomerItemPriceUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerItemPriceCreateWithoutCustomerInput, CustomerItemPriceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerItemPriceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerItemPriceWhereUniqueInput
    data: XOR<CustomerItemPriceUpdateWithoutCustomerInput, CustomerItemPriceUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerItemPriceUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerItemPriceScalarWhereInput
    data: XOR<CustomerItemPriceUpdateManyMutationInput, CustomerItemPriceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ItemCreateWithoutSupplierPricesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSupplierPricesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSupplierPricesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSupplierPricesInput, ItemUncheckedCreateWithoutSupplierPricesInput>
  }

  export type SupplierCreateWithoutItemPricesInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutItemPricesInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutItemPricesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutItemPricesInput, SupplierUncheckedCreateWithoutItemPricesInput>
  }

  export type ItemUpsertWithoutSupplierPricesInput = {
    update: XOR<ItemUpdateWithoutSupplierPricesInput, ItemUncheckedUpdateWithoutSupplierPricesInput>
    create: XOR<ItemCreateWithoutSupplierPricesInput, ItemUncheckedCreateWithoutSupplierPricesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSupplierPricesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSupplierPricesInput, ItemUncheckedUpdateWithoutSupplierPricesInput>
  }

  export type ItemUpdateWithoutSupplierPricesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSupplierPricesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierUpsertWithoutItemPricesInput = {
    update: XOR<SupplierUpdateWithoutItemPricesInput, SupplierUncheckedUpdateWithoutItemPricesInput>
    create: XOR<SupplierCreateWithoutItemPricesInput, SupplierUncheckedCreateWithoutItemPricesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutItemPricesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutItemPricesInput, SupplierUncheckedUpdateWithoutItemPricesInput>
  }

  export type SupplierUpdateWithoutItemPricesInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutItemPricesInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type CustomerCreateWithoutItemPricesInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutItemPricesInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutItemPricesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutItemPricesInput, CustomerUncheckedCreateWithoutItemPricesInput>
  }

  export type ItemCreateWithoutCustomerPricesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCustomerPricesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCustomerPricesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCustomerPricesInput, ItemUncheckedCreateWithoutCustomerPricesInput>
  }

  export type CustomerUpsertWithoutItemPricesInput = {
    update: XOR<CustomerUpdateWithoutItemPricesInput, CustomerUncheckedUpdateWithoutItemPricesInput>
    create: XOR<CustomerCreateWithoutItemPricesInput, CustomerUncheckedCreateWithoutItemPricesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutItemPricesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutItemPricesInput, CustomerUncheckedUpdateWithoutItemPricesInput>
  }

  export type CustomerUpdateWithoutItemPricesInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutItemPricesInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ItemUpsertWithoutCustomerPricesInput = {
    update: XOR<ItemUpdateWithoutCustomerPricesInput, ItemUncheckedUpdateWithoutCustomerPricesInput>
    create: XOR<ItemCreateWithoutCustomerPricesInput, ItemUncheckedCreateWithoutCustomerPricesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutCustomerPricesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutCustomerPricesInput, ItemUncheckedUpdateWithoutCustomerPricesInput>
  }

  export type ItemUpdateWithoutCustomerPricesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCustomerPricesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InvoiceCreateWithoutPurchaseOrderInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPurchaseOrderInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPurchaseOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPurchaseOrderInput, InvoiceUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type InvoiceCreateManyPurchaseOrderInputEnvelope = {
    data: InvoiceCreateManyPurchaseOrderInput | InvoiceCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderLineCreateWithoutPurchaseOrderInput = {
    purchaseLineId?: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
    item: ItemCreateNestedOneWithoutPurchaseOrderLinesInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput = {
    purchaseLineId?: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
  }

  export type PurchaseOrderLineCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderLineCreateManyPurchaseOrderInput | PurchaseOrderLineCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPurchaseOrdersInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPurchaseOrdersInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPurchaseOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type StockMovementCreateWithoutPurchaseOrderInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    notes?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutStockMovementsInput
    item: ItemCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutPurchaseOrderInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    itemId: bigint | number
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    notes?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutPurchaseOrderInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutPurchaseOrderInput, StockMovementUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type StockMovementCreateManyPurchaseOrderInputEnvelope = {
    data: StockMovementCreateManyPurchaseOrderInput | StockMovementCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPurchaseOrderInput, InvoiceUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<InvoiceCreateWithoutPurchaseOrderInput, InvoiceUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPurchaseOrderInput, InvoiceUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderLineCreateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutPurchaseOrderInput, PurchaseOrderLineUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type UserUpsertWithoutPurchaseOrdersInput = {
    update: XOR<UserUpdateWithoutPurchaseOrdersInput, UserUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<UserCreateWithoutPurchaseOrdersInput, UserUncheckedCreateWithoutPurchaseOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseOrdersInput, UserUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateWithoutPurchaseOrdersInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseOrdersInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type StockMovementUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutPurchaseOrderInput, StockMovementUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<StockMovementCreateWithoutPurchaseOrderInput, StockMovementUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutPurchaseOrderInput, StockMovementUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type ItemCreateWithoutPurchaseOrderLinesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPurchaseOrderLinesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPurchaseOrderLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchaseOrderLinesInput, ItemUncheckedCreateWithoutPurchaseOrderLinesInput>
  }

  export type PurchaseOrderCreateWithoutLinesInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceCreateNestedManyWithoutPurchaseOrderInput
    creator?: UserCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    stockMovements?: StockMovementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutLinesInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutLinesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
  }

  export type ItemUpsertWithoutPurchaseOrderLinesInput = {
    update: XOR<ItemUpdateWithoutPurchaseOrderLinesInput, ItemUncheckedUpdateWithoutPurchaseOrderLinesInput>
    create: XOR<ItemCreateWithoutPurchaseOrderLinesInput, ItemUncheckedCreateWithoutPurchaseOrderLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPurchaseOrderLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPurchaseOrderLinesInput, ItemUncheckedUpdateWithoutPurchaseOrderLinesInput>
  }

  export type ItemUpdateWithoutPurchaseOrderLinesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPurchaseOrderLinesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type PurchaseOrderUpsertWithoutLinesInput = {
    update: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type PurchaseOrderUpdateWithoutLinesInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutPurchaseOrderNestedInput
    creator?: UserUpdateOneWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    stockMovements?: StockMovementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutLinesInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type DispatchCreateWithoutSalesOrderInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutDispatchesInput
  }

  export type DispatchUncheckedCreateWithoutSalesOrderInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type DispatchCreateOrConnectWithoutSalesOrderInput = {
    where: DispatchWhereUniqueInput
    create: XOR<DispatchCreateWithoutSalesOrderInput, DispatchUncheckedCreateWithoutSalesOrderInput>
  }

  export type DispatchCreateManySalesOrderInputEnvelope = {
    data: DispatchCreateManySalesOrderInput | DispatchCreateManySalesOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutSalesOrderInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSalesOrderInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSalesOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSalesOrderInput, InvoiceUncheckedCreateWithoutSalesOrderInput>
  }

  export type InvoiceCreateManySalesOrderInputEnvelope = {
    data: InvoiceCreateManySalesOrderInput | InvoiceCreateManySalesOrderInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderLineCreateWithoutSalesOrderInput = {
    salesOrderLineId?: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutSalesOrderLinesInput
  }

  export type SalesOrderLineUncheckedCreateWithoutSalesOrderInput = {
    salesOrderLineId?: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutSalesOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesOrderLineCreateManySalesOrderInputEnvelope = {
    data: SalesOrderLineCreateManySalesOrderInput | SalesOrderLineCreateManySalesOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSalesOrdersInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSalesOrdersInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSalesOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesOrdersInput, UserUncheckedCreateWithoutSalesOrdersInput>
  }

  export type CustomerCreateWithoutSalesOrdersInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    itemPrices?: CustomerItemPriceCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesOrdersInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    itemPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesOrdersInput, CustomerUncheckedCreateWithoutSalesOrdersInput>
  }

  export type DispatchUpsertWithWhereUniqueWithoutSalesOrderInput = {
    where: DispatchWhereUniqueInput
    update: XOR<DispatchUpdateWithoutSalesOrderInput, DispatchUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<DispatchCreateWithoutSalesOrderInput, DispatchUncheckedCreateWithoutSalesOrderInput>
  }

  export type DispatchUpdateWithWhereUniqueWithoutSalesOrderInput = {
    where: DispatchWhereUniqueInput
    data: XOR<DispatchUpdateWithoutSalesOrderInput, DispatchUncheckedUpdateWithoutSalesOrderInput>
  }

  export type DispatchUpdateManyWithWhereWithoutSalesOrderInput = {
    where: DispatchScalarWhereInput
    data: XOR<DispatchUpdateManyMutationInput, DispatchUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSalesOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSalesOrderInput, InvoiceUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<InvoiceCreateWithoutSalesOrderInput, InvoiceUncheckedCreateWithoutSalesOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSalesOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSalesOrderInput, InvoiceUncheckedUpdateWithoutSalesOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSalesOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutSalesOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutSalesOrderInput, SalesOrderLineUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<SalesOrderLineCreateWithoutSalesOrderInput, SalesOrderLineUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutSalesOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutSalesOrderInput, SalesOrderLineUncheckedUpdateWithoutSalesOrderInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutSalesOrderInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutSalesOrderInput>
  }

  export type UserUpsertWithoutSalesOrdersInput = {
    update: XOR<UserUpdateWithoutSalesOrdersInput, UserUncheckedUpdateWithoutSalesOrdersInput>
    create: XOR<UserCreateWithoutSalesOrdersInput, UserUncheckedCreateWithoutSalesOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesOrdersInput, UserUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type UserUpdateWithoutSalesOrdersInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesOrdersInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomerUpsertWithoutSalesOrdersInput = {
    update: XOR<CustomerUpdateWithoutSalesOrdersInput, CustomerUncheckedUpdateWithoutSalesOrdersInput>
    create: XOR<CustomerCreateWithoutSalesOrdersInput, CustomerUncheckedCreateWithoutSalesOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesOrdersInput, CustomerUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type CustomerUpdateWithoutSalesOrdersInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemPrices?: CustomerItemPriceUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesOrdersInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemPrices?: CustomerItemPriceUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ItemCreateWithoutSalesOrderLinesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSalesOrderLinesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSalesOrderLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSalesOrderLinesInput, ItemUncheckedCreateWithoutSalesOrderLinesInput>
  }

  export type SalesOrderCreateWithoutLinesInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    dispatches?: DispatchCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceCreateNestedManyWithoutSalesOrderInput
    creator?: UserCreateNestedOneWithoutSalesOrdersInput
    customer: CustomerCreateNestedOneWithoutSalesOrdersInput
  }

  export type SalesOrderUncheckedCreateWithoutLinesInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
    dispatches?: DispatchUncheckedCreateNestedManyWithoutSalesOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutLinesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
  }

  export type ItemUpsertWithoutSalesOrderLinesInput = {
    update: XOR<ItemUpdateWithoutSalesOrderLinesInput, ItemUncheckedUpdateWithoutSalesOrderLinesInput>
    create: XOR<ItemCreateWithoutSalesOrderLinesInput, ItemUncheckedCreateWithoutSalesOrderLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSalesOrderLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSalesOrderLinesInput, ItemUncheckedUpdateWithoutSalesOrderLinesInput>
  }

  export type ItemUpdateWithoutSalesOrderLinesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSalesOrderLinesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SalesOrderUpsertWithoutLinesInput = {
    update: XOR<SalesOrderUpdateWithoutLinesInput, SalesOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutLinesInput, SalesOrderUncheckedUpdateWithoutLinesInput>
  }

  export type SalesOrderUpdateWithoutLinesInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutSalesOrderNestedInput
    creator?: UserUpdateOneWithoutSalesOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutLinesInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type UserCreateWithoutDispatchesInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDispatchesInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDispatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDispatchesInput, UserUncheckedCreateWithoutDispatchesInput>
  }

  export type SalesOrderCreateWithoutDispatchesInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    creator?: UserCreateNestedOneWithoutSalesOrdersInput
    customer: CustomerCreateNestedOneWithoutSalesOrdersInput
  }

  export type SalesOrderUncheckedCreateWithoutDispatchesInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutDispatchesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutDispatchesInput, SalesOrderUncheckedCreateWithoutDispatchesInput>
  }

  export type UserUpsertWithoutDispatchesInput = {
    update: XOR<UserUpdateWithoutDispatchesInput, UserUncheckedUpdateWithoutDispatchesInput>
    create: XOR<UserCreateWithoutDispatchesInput, UserUncheckedCreateWithoutDispatchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDispatchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDispatchesInput, UserUncheckedUpdateWithoutDispatchesInput>
  }

  export type UserUpdateWithoutDispatchesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDispatchesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SalesOrderUpsertWithoutDispatchesInput = {
    update: XOR<SalesOrderUpdateWithoutDispatchesInput, SalesOrderUncheckedUpdateWithoutDispatchesInput>
    create: XOR<SalesOrderCreateWithoutDispatchesInput, SalesOrderUncheckedCreateWithoutDispatchesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutDispatchesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutDispatchesInput, SalesOrderUncheckedUpdateWithoutDispatchesInput>
  }

  export type SalesOrderUpdateWithoutDispatchesInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    creator?: UserUpdateOneWithoutSalesOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutDispatchesInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type UserCreateWithoutProductionDaysClosedInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutProductionDaysClosedInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProductionDaysClosedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionDaysClosedInput, UserUncheckedCreateWithoutProductionDaysClosedInput>
  }

  export type UserCreateWithoutProductionDaysCreatedInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutProductionDaysCreatedInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProductionDaysCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionDaysCreatedInput, UserUncheckedCreateWithoutProductionDaysCreatedInput>
  }

  export type ItemCreateWithoutProductionDaysInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutProductionDaysInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutProductionDaysInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutProductionDaysInput, ItemUncheckedCreateWithoutProductionDaysInput>
  }

  export type UserCreateWithoutProductionDaysReopenedInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutProductionDaysReopenedInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProductionDaysReopenedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductionDaysReopenedInput, UserUncheckedCreateWithoutProductionDaysReopenedInput>
  }

  export type UserUpsertWithoutProductionDaysClosedInput = {
    update: XOR<UserUpdateWithoutProductionDaysClosedInput, UserUncheckedUpdateWithoutProductionDaysClosedInput>
    create: XOR<UserCreateWithoutProductionDaysClosedInput, UserUncheckedCreateWithoutProductionDaysClosedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionDaysClosedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionDaysClosedInput, UserUncheckedUpdateWithoutProductionDaysClosedInput>
  }

  export type UserUpdateWithoutProductionDaysClosedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionDaysClosedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutProductionDaysCreatedInput = {
    update: XOR<UserUpdateWithoutProductionDaysCreatedInput, UserUncheckedUpdateWithoutProductionDaysCreatedInput>
    create: XOR<UserCreateWithoutProductionDaysCreatedInput, UserUncheckedCreateWithoutProductionDaysCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionDaysCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionDaysCreatedInput, UserUncheckedUpdateWithoutProductionDaysCreatedInput>
  }

  export type UserUpdateWithoutProductionDaysCreatedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionDaysCreatedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ItemUpsertWithoutProductionDaysInput = {
    update: XOR<ItemUpdateWithoutProductionDaysInput, ItemUncheckedUpdateWithoutProductionDaysInput>
    create: XOR<ItemCreateWithoutProductionDaysInput, ItemUncheckedCreateWithoutProductionDaysInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutProductionDaysInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutProductionDaysInput, ItemUncheckedUpdateWithoutProductionDaysInput>
  }

  export type ItemUpdateWithoutProductionDaysInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutProductionDaysInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UserUpsertWithoutProductionDaysReopenedInput = {
    update: XOR<UserUpdateWithoutProductionDaysReopenedInput, UserUncheckedUpdateWithoutProductionDaysReopenedInput>
    create: XOR<UserCreateWithoutProductionDaysReopenedInput, UserUncheckedCreateWithoutProductionDaysReopenedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductionDaysReopenedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductionDaysReopenedInput, UserUncheckedUpdateWithoutProductionDaysReopenedInput>
  }

  export type UserUpdateWithoutProductionDaysReopenedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutProductionDaysReopenedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutStockMovementsInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutStockMovementsInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutStockMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
  }

  export type ItemCreateWithoutStockMovementsInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutStockMovementsInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutStockMovementsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutStockMovementsInput, ItemUncheckedCreateWithoutStockMovementsInput>
  }

  export type PurchaseOrderCreateWithoutStockMovementsInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    creator?: UserCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutStockMovementsInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutStockMovementsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutStockMovementsInput, PurchaseOrderUncheckedCreateWithoutStockMovementsInput>
  }

  export type UserUpsertWithoutStockMovementsInput = {
    update: XOR<UserUpdateWithoutStockMovementsInput, UserUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<UserCreateWithoutStockMovementsInput, UserUncheckedCreateWithoutStockMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStockMovementsInput, UserUncheckedUpdateWithoutStockMovementsInput>
  }

  export type UserUpdateWithoutStockMovementsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutStockMovementsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ItemUpsertWithoutStockMovementsInput = {
    update: XOR<ItemUpdateWithoutStockMovementsInput, ItemUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<ItemCreateWithoutStockMovementsInput, ItemUncheckedCreateWithoutStockMovementsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutStockMovementsInput, ItemUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ItemUpdateWithoutStockMovementsInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutStockMovementsInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type PurchaseOrderUpsertWithoutStockMovementsInput = {
    update: XOR<PurchaseOrderUpdateWithoutStockMovementsInput, PurchaseOrderUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<PurchaseOrderCreateWithoutStockMovementsInput, PurchaseOrderUncheckedCreateWithoutStockMovementsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutStockMovementsInput, PurchaseOrderUncheckedUpdateWithoutStockMovementsInput>
  }

  export type PurchaseOrderUpdateWithoutStockMovementsInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    creator?: UserUpdateOneWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutStockMovementsInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ItemCreateWithoutStockBalanceInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutStockBalanceInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: InvoiceLineUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutStockBalanceInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutStockBalanceInput, ItemUncheckedCreateWithoutStockBalanceInput>
  }

  export type ItemUpsertWithoutStockBalanceInput = {
    update: XOR<ItemUpdateWithoutStockBalanceInput, ItemUncheckedUpdateWithoutStockBalanceInput>
    create: XOR<ItemCreateWithoutStockBalanceInput, ItemUncheckedCreateWithoutStockBalanceInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutStockBalanceInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutStockBalanceInput, ItemUncheckedUpdateWithoutStockBalanceInput>
  }

  export type ItemUpdateWithoutStockBalanceInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutStockBalanceInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    invoiceLineId?: bigint | number
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
    item?: ItemCreateNestedOneWithoutInvoiceLinesInput
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    invoiceLineId?: bigint | number
    itemId?: bigint | number | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutInvoicesCreatedInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutInvoicesCreatedInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInvoicesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
  }

  export type CustomerCreateWithoutInvoicesInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    itemPrices?: CustomerItemPriceCreateNestedManyWithoutCustomerInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    customerId?: bigint | number
    customerCode: string
    customerName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    itemPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutCustomerInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutInvoicesMatchedInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutInvoicesMatchedInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInvoicesMatchedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesMatchedInput, UserUncheckedCreateWithoutInvoicesMatchedInput>
  }

  export type PurchaseOrderCreateWithoutInvoicesInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    lines?: PurchaseOrderLineCreateNestedManyWithoutPurchaseOrderInput
    creator?: UserCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    stockMovements?: StockMovementCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutInvoicesInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPurchaseOrderInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutInvoicesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
  }

  export type SalesOrderCreateWithoutInvoicesInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
    dispatches?: DispatchCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutSalesOrderInput
    creator?: UserCreateNestedOneWithoutSalesOrdersInput
    customer: CustomerCreateNestedOneWithoutSalesOrdersInput
  }

  export type SalesOrderUncheckedCreateWithoutInvoicesInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
    dispatches?: DispatchUncheckedCreateNestedManyWithoutSalesOrderInput
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutSalesOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutInvoicesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
  }

  export type SupplierCreateWithoutInvoicesInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutInvoicesInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutInvoicesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    paymentId?: bigint | number
    paymentNo: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    createdAt?: Date | string
    receiver?: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    paymentId?: bigint | number
    paymentNo: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    receivedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type UserUpsertWithoutInvoicesCreatedInput = {
    update: XOR<UserUpdateWithoutInvoicesCreatedInput, UserUncheckedUpdateWithoutInvoicesCreatedInput>
    create: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesCreatedInput, UserUncheckedUpdateWithoutInvoicesCreatedInput>
  }

  export type UserUpdateWithoutInvoicesCreatedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesCreatedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemPrices?: CustomerItemPriceUpdateManyWithoutCustomerNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerCode?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    itemPrices?: CustomerItemPriceUncheckedUpdateManyWithoutCustomerNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutInvoicesMatchedInput = {
    update: XOR<UserUpdateWithoutInvoicesMatchedInput, UserUncheckedUpdateWithoutInvoicesMatchedInput>
    create: XOR<UserCreateWithoutInvoicesMatchedInput, UserUncheckedCreateWithoutInvoicesMatchedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesMatchedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesMatchedInput, UserUncheckedUpdateWithoutInvoicesMatchedInput>
  }

  export type UserUpdateWithoutInvoicesMatchedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesMatchedInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PurchaseOrderUpsertWithoutInvoicesInput = {
    update: XOR<PurchaseOrderUpdateWithoutInvoicesInput, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutInvoicesInput, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type PurchaseOrderUpdateWithoutInvoicesInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    creator?: UserUpdateOneWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    stockMovements?: StockMovementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutInvoicesInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type SalesOrderUpsertWithoutInvoicesInput = {
    update: XOR<SalesOrderUpdateWithoutInvoicesInput, SalesOrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutInvoicesInput, SalesOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type SalesOrderUpdateWithoutInvoicesInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    creator?: UserUpdateOneWithoutSalesOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutInvoicesInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUncheckedUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type SupplierUpsertWithoutInvoicesInput = {
    update: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>
  }

  export type SupplierUpdateWithoutInvoicesInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutInvoicesInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutLinesInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLinesInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLinesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutInvoiceLinesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceCreateNestedManyWithoutItemInput
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutItemsInput
    productionDays?: ProductionDayCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInvoiceLinesInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerPrices?: CustomerItemPriceUncheckedCreateNestedManyWithoutItemInput
    productionDays?: ProductionDayUncheckedCreateNestedManyWithoutFinishedProductInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    salesOrderLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    stockBalance?: StockBalanceUncheckedCreateNestedOneWithoutItemInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutItemInput
    supplierPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInvoiceLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
  }

  export type InvoiceUpsertWithoutLinesInput = {
    update: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceUpdateWithoutLinesInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLinesInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ItemUpsertWithoutInvoiceLinesInput = {
    update: XOR<ItemUpdateWithoutInvoiceLinesInput, ItemUncheckedUpdateWithoutInvoiceLinesInput>
    create: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInvoiceLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInvoiceLinesInput, ItemUncheckedUpdateWithoutInvoiceLinesInput>
  }

  export type ItemUpdateWithoutInvoiceLinesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInvoiceLinesInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    creator?: UserCreateNestedOneWithoutInvoicesCreatedInput
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    matchChecker?: UserCreateNestedOneWithoutInvoicesMatchedInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    salesOrder?: SalesOrderCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutExpensesInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutExpensesInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatorInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
  }

  export type SupplierCreateWithoutExpensesInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutExpensesInput = {
    supplierId?: bigint | number
    supplierCode: string
    supplierName: string
    contactName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
    deactivatedAt?: Date | string | null
    deactivatedBy?: bigint | number | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    itemPrices?: SupplierItemPriceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutExpensesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
  }

  export type UserUpsertWithoutExpensesInput = {
    update: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
    create: XOR<UserCreateWithoutExpensesInput, UserUncheckedCreateWithoutExpensesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpensesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpensesInput, UserUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateWithoutExpensesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutExpensesInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SupplierUpsertWithoutExpensesInput = {
    update: XOR<SupplierUpdateWithoutExpensesInput, SupplierUncheckedUpdateWithoutExpensesInput>
    create: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutExpensesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutExpensesInput, SupplierUncheckedUpdateWithoutExpensesInput>
  }

  export type SupplierUpdateWithoutExpensesInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutExpensesInput = {
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierCode?: StringFieldUpdateOperationsInput | string
    supplierName?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    itemPrices?: SupplierItemPriceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserCreateWithoutCashTransactionsInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyCreateNestedManyWithoutUserInput
    dispatches?: DispatchCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    expenses?: ExpenseCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementCreateNestedManyWithoutCreatorInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCashTransactionsInput = {
    userId?: bigint | number
    userCode: string
    roleId: number
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recordedAttendances?: AttendanceDailyUncheckedCreateNestedManyWithoutRecorderInput
    attendances?: AttendanceDailyUncheckedCreateNestedManyWithoutUserInput
    dispatches?: DispatchUncheckedCreateNestedManyWithoutCreatorInput
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCreatorInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatorInput
    invoicesMatched?: InvoiceUncheckedCreateNestedManyWithoutMatchCheckerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReceiverInput
    productionDaysClosed?: ProductionDayUncheckedCreateNestedManyWithoutCloserInput
    productionDaysCreated?: ProductionDayUncheckedCreateNestedManyWithoutCreatorInput
    productionDaysReopened?: ProductionDayUncheckedCreateNestedManyWithoutReopenerInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedCreateNestedManyWithoutPayerInput
    salaryRecords?: SalaryRecordUncheckedCreateNestedManyWithoutUserInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCreatorInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCashTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
  }

  export type UserUpsertWithoutCashTransactionsInput = {
    update: XOR<UserUpdateWithoutCashTransactionsInput, UserUncheckedUpdateWithoutCashTransactionsInput>
    create: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashTransactionsInput, UserUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type UserUpdateWithoutCashTransactionsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCashTransactionsInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyRoleInput = {
    userId?: bigint | number
    userCode: string
    fullName: string
    username?: string | null
    email?: string | null
    phone?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedAttendances?: AttendanceDailyUncheckedUpdateManyWithoutRecorderNestedInput
    attendances?: AttendanceDailyUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatorNestedInput
    dispatches?: DispatchUncheckedUpdateManyWithoutCreatorNestedInput
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatorNestedInput
    invoicesMatched?: InvoiceUncheckedUpdateManyWithoutMatchCheckerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReceiverNestedInput
    productionDaysClosed?: ProductionDayUncheckedUpdateManyWithoutCloserNestedInput
    productionDaysCreated?: ProductionDayUncheckedUpdateManyWithoutCreatorNestedInput
    productionDaysReopened?: ProductionDayUncheckedUpdateManyWithoutReopenerNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    salaryPaymentsPaid?: SalaryPaymentUncheckedUpdateManyWithoutPayerNestedInput
    salaryRecords?: SalaryRecordUncheckedUpdateManyWithoutUserNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCreatorNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    userCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailyCreateManyRecorderInput = {
    attendanceId?: bigint | number
    userId: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type AttendanceDailyCreateManyUserInput = {
    attendanceId?: bigint | number
    workDate: Date | string
    timeIn?: Date | string | null
    timeOut?: Date | string | null
    systemHours?: Decimal | DecimalJsLike | number | string
    systemOtHours?: Decimal | DecimalJsLike | number | string
    manualOtHours?: Decimal | DecimalJsLike | number | string
    remarks?: string | null
    recordedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type CashTransactionCreateManyCreatorInput = {
    txId?: bigint | number
    txDate?: Date | string
    txType: $Enums.TxType
    sourceModule?: string | null
    refTable?: string | null
    refId?: bigint | number | null
    amountIn?: Decimal | DecimalJsLike | number | string
    amountOut?: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    note?: string | null
    createdAt?: Date | string
  }

  export type DispatchCreateManyCreatorInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    salesOrderId: bigint | number
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdAt?: Date | string
  }

  export type ExpenseCreateManyCreatorInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    supplierId?: bigint | number | null
    createdAt?: Date | string
  }

  export type InvoiceCreateManyCreatorInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InvoiceCreateManyMatchCheckerInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PaymentCreateManyReceiverInput = {
    paymentId?: bigint | number
    paymentNo: string
    invoiceId: bigint | number
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateManyCloserInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateManyCreatorInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductionDayCreateManyReopenerInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    finishedProductId: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManyCreatorInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    supplierId: bigint | number
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
  }

  export type SalaryPaymentCreateManyPayerInput = {
    salaryPaymentId?: bigint | number
    salaryRecordId: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    createdAt?: Date | string
  }

  export type SalaryRecordCreateManyUserInput = {
    salaryRecordId?: bigint | number
    periodId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type SalesOrderCreateManyCreatorInput = {
    salesOrderId?: bigint | number
    orderNo: string
    customerId: bigint | number
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdAt?: Date | string
  }

  export type StockMovementCreateManyCreatorInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    itemId: bigint | number
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    purchaseId?: bigint | number | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AttendanceDailyUpdateWithoutRecorderInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceDailyUncheckedUpdateWithoutRecorderInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailyUncheckedUpdateManyWithoutRecorderInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailyUpdateWithoutUserInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recorder?: UserUpdateOneWithoutRecordedAttendancesNestedInput
  }

  export type AttendanceDailyUncheckedUpdateWithoutUserInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceDailyUncheckedUpdateManyWithoutUserInput = {
    attendanceId?: BigIntFieldUpdateOperationsInput | bigint | number
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timeOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    systemHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    manualOtHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUpdateWithoutCreatorInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateWithoutCreatorInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutCreatorInput = {
    txId?: BigIntFieldUpdateOperationsInput | bigint | number
    txDate?: DateTimeFieldUpdateOperationsInput | Date | string
    txType?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    sourceModule?: NullableStringFieldUpdateOperationsInput | string | null
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amountIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchUpdateWithoutCreatorInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutDispatchesNestedInput
  }

  export type DispatchUncheckedUpdateWithoutCreatorInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchUncheckedUpdateManyWithoutCreatorInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutCreatorInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutCreatorInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutCreatorInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCreatorInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCreatorInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatorInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutMatchCheckerInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutMatchCheckerInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutMatchCheckerInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutReceiverInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReceiverInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutReceiverInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUpdateWithoutCloserInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProductionDaysCreatedNestedInput
    finishedProduct?: ItemUpdateOneRequiredWithoutProductionDaysNestedInput
    reopener?: UserUpdateOneWithoutProductionDaysReopenedNestedInput
  }

  export type ProductionDayUncheckedUpdateWithoutCloserInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUncheckedUpdateManyWithoutCloserInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUpdateWithoutCreatorInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closer?: UserUpdateOneWithoutProductionDaysClosedNestedInput
    finishedProduct?: ItemUpdateOneRequiredWithoutProductionDaysNestedInput
    reopener?: UserUpdateOneWithoutProductionDaysReopenedNestedInput
  }

  export type ProductionDayUncheckedUpdateWithoutCreatorInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUncheckedUpdateManyWithoutCreatorInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUpdateWithoutReopenerInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closer?: UserUpdateOneWithoutProductionDaysClosedNestedInput
    creator?: UserUpdateOneWithoutProductionDaysCreatedNestedInput
    finishedProduct?: ItemUpdateOneRequiredWithoutProductionDaysNestedInput
  }

  export type ProductionDayUncheckedUpdateWithoutReopenerInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUncheckedUpdateManyWithoutReopenerInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedProductId?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutCreatorInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    stockMovements?: StockMovementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCreatorInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCreatorInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalaryPaymentUpdateWithoutPayerInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryRecord?: SalaryRecordUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SalaryPaymentUncheckedUpdateWithoutPayerInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutPayerInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryRecordUpdateWithoutUserInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: SalaryPaymentUpdateManyWithoutSalaryRecordNestedInput
    period?: SalaryPeriodUpdateOneRequiredWithoutSalaryRecordsNestedInput
  }

  export type SalaryRecordUncheckedUpdateWithoutUserInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: SalaryPaymentUncheckedUpdateManyWithoutSalaryRecordNestedInput
  }

  export type SalaryRecordUncheckedUpdateManyWithoutUserInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    periodId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalesOrderUpdateWithoutCreatorInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCreatorInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutCreatorInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutCreatorInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutStockMovementsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutCreatorInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutCreatorInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateManySalaryRangeInput = {
    userId: bigint | number
    nic?: string | null
    address?: string | null
    joinedDate?: Date | string | null
    designation?: string | null
    basicSalary?: Decimal | DecimalJsLike | number | string
    otRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
  }

  export type EmployeeProfileUpdateWithoutSalaryRangeInput = {
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
  }

  export type EmployeeProfileUncheckedUpdateWithoutSalaryRangeInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeProfileUncheckedUpdateManyWithoutSalaryRangeInput = {
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    basicSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalaryRecordCreateManyPeriodInput = {
    salaryRecordId?: bigint | number
    userId: bigint | number
    baseSalary?: Decimal | DecimalJsLike | number | string
    otHours?: Decimal | DecimalJsLike | number | string
    otAmount?: Decimal | DecimalJsLike | number | string
    allowances?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    totalPay?: Decimal | DecimalJsLike | number | string
    status?: string
  }

  export type SalaryRecordUpdateWithoutPeriodInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: SalaryPaymentUpdateManyWithoutSalaryRecordNestedInput
    user?: UserUpdateOneRequiredWithoutSalaryRecordsNestedInput
  }

  export type SalaryRecordUncheckedUpdateWithoutPeriodInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: SalaryPaymentUncheckedUpdateManyWithoutSalaryRecordNestedInput
  }

  export type SalaryRecordUncheckedUpdateManyWithoutPeriodInput = {
    salaryRecordId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allowances?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SalaryPaymentCreateManySalaryRecordInput = {
    salaryPaymentId?: bigint | number
    payDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    paidBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalaryPaymentUpdateWithoutSalaryRecordInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payer?: UserUpdateOneWithoutSalaryPaymentsPaidNestedInput
  }

  export type SalaryPaymentUncheckedUpdateWithoutSalaryRecordInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutSalaryRecordInput = {
    salaryPaymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    payDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    paidBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyUnitInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    categoryId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutUnitInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutUnitInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutUnitInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyCategoryInput = {
    itemId?: bigint | number
    itemCode: string
    itemName: string
    itemType: $Enums.ItemType
    unitId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutCategoryInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUpdateManyWithoutItemNestedInput
    unit?: UnitUpdateOneWithoutItemsNestedInput
    productionDays?: ProductionDayUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoryInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerPrices?: CustomerItemPriceUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: InvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    productionDays?: ProductionDayUncheckedUpdateManyWithoutFinishedProductNestedInput
    purchaseOrderLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    salesOrderLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    stockBalance?: StockBalanceUncheckedUpdateOneWithoutItemNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutItemNestedInput
    supplierPrices?: SupplierItemPriceUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutCategoryInput = {
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemCode?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerItemPriceCreateManyItemInput = {
    customerItemPriceId?: bigint | number
    customerId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type InvoiceLineCreateManyItemInput = {
    invoiceLineId?: bigint | number
    invoiceId: bigint | number
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type ProductionDayCreateManyFinishedProductInput = {
    productionDayId?: bigint | number
    productionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    scrapQuantity?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    isClosed?: boolean
    closedAt?: Date | string | null
    closedBy?: bigint | number | null
    reopenReason?: string | null
    reopenedBy?: bigint | number | null
    reopenedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PurchaseOrderLineCreateManyItemInput = {
    purchaseLineId?: bigint | number
    purchaseId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
  }

  export type SalesOrderLineCreateManyItemInput = {
    salesOrderLineId?: bigint | number
    salesOrderId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type StockMovementCreateManyItemInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    purchaseId?: bigint | number | null
    notes?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SupplierItemPriceCreateManyItemInput = {
    supplierItemPriceId?: bigint | number
    supplierId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type CustomerItemPriceUpdateWithoutItemInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    customer?: CustomerUpdateOneRequiredWithoutItemPricesNestedInput
  }

  export type CustomerItemPriceUncheckedUpdateWithoutItemInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerItemPriceUncheckedUpdateManyWithoutItemInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    customerId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type InvoiceLineUpdateWithoutItemInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutItemInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUncheckedUpdateManyWithoutItemInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductionDayUpdateWithoutFinishedProductInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closer?: UserUpdateOneWithoutProductionDaysClosedNestedInput
    creator?: UserUpdateOneWithoutProductionDaysCreatedNestedInput
    reopener?: UserUpdateOneWithoutProductionDaysReopenedNestedInput
  }

  export type ProductionDayUncheckedUpdateWithoutFinishedProductInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionDayUncheckedUpdateManyWithoutFinishedProductInput = {
    productionDayId?: BigIntFieldUpdateOperationsInput | bigint | number
    productionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenReason?: NullableStringFieldUpdateOperationsInput | string | null
    reopenedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reopenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineUpdateWithoutItemInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutItemInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutItemInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SalesOrderLineUpdateWithoutItemInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesOrder?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutItemInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutItemInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockMovementUpdateWithoutItemInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutStockMovementsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutItemInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutItemInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierItemPriceUpdateWithoutItemInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplier?: SupplierUpdateOneRequiredWithoutItemPricesNestedInput
  }

  export type SupplierItemPriceUncheckedUpdateWithoutItemInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SupplierItemPriceUncheckedUpdateManyWithoutItemInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    supplierId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ExpenseCreateManySupplierInput = {
    expenseId?: bigint | number
    expenseNo: string
    expenseDate?: Date | string
    category: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    paidTo?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type InvoiceCreateManySupplierInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    purchaseId?: bigint | number
    purchaseNo: string
    purchaseDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    createdBy?: bigint | number | null
    createdAt?: Date | string
    updatedBy?: bigint | number | null
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    confirmedBy?: bigint | number | null
    receivedAt?: Date | string | null
    receivedBy?: bigint | number | null
    cancelledAt?: Date | string | null
    cancelledBy?: bigint | number | null
    cancelReason?: string | null
  }

  export type SupplierItemPriceCreateManySupplierInput = {
    supplierItemPriceId?: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type ExpenseUpdateWithoutSupplierInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutSupplierInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutSupplierInput = {
    expenseId?: BigIntFieldUpdateOperationsInput | bigint | number
    expenseNo?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    paidTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutSupplierInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSupplierInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSupplierInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPurchaseOrderNestedInput
    creator?: UserUpdateOneWithoutPurchaseOrdersNestedInput
    stockMovements?: StockMovementUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    purchaseId?: BigIntFieldUpdateOperationsInput | bigint | number
    purchaseNo?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierItemPriceUpdateWithoutSupplierInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    item?: ItemUpdateOneRequiredWithoutSupplierPricesNestedInput
  }

  export type SupplierItemPriceUncheckedUpdateWithoutSupplierInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SupplierItemPriceUncheckedUpdateManyWithoutSupplierInput = {
    supplierItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerItemPriceCreateManyCustomerInput = {
    customerItemPriceId?: bigint | number
    itemId: bigint | number
    unitPrice: Decimal | DecimalJsLike | number | string
    effectiveFrom?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: bigint | number | null
    updatedBy?: bigint | number | null
  }

  export type InvoiceCreateManyCustomerInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalesOrderCreateManyCustomerInput = {
    salesOrderId?: bigint | number
    orderNo: string
    orderDate?: Date | string
    status?: $Enums.DocStatus
    notes?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: boolean
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type CustomerItemPriceUpdateWithoutCustomerInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    item?: ItemUpdateOneRequiredWithoutCustomerPricesNestedInput
  }

  export type CustomerItemPriceUncheckedUpdateWithoutCustomerInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type CustomerItemPriceUncheckedUpdateManyWithoutCustomerInput = {
    customerItemPriceId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    updatedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutCustomerInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutSalesOrderNestedInput
    creator?: UserUpdateOneWithoutSalesOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCustomerInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispatches?: DispatchUncheckedUpdateManyWithoutSalesOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUncheckedUpdateManyWithoutSalesOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerInput = {
    salesOrderId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isEditedAfterConfirm?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyPurchaseOrderInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    salesOrderId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type PurchaseOrderLineCreateManyPurchaseOrderInput = {
    purchaseLineId?: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    priceSource?: string
    overrideReason?: string | null
    overriddenBy?: bigint | number | null
  }

  export type StockMovementCreateManyPurchaseOrderInput = {
    stockMovementId?: bigint | number
    movementDate?: Date | string
    movementType: $Enums.MovementType
    itemId: bigint | number
    qtyIn?: Decimal | DecimalJsLike | number | string
    qtyOut?: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string
    refTable?: string | null
    refId?: bigint | number | null
    notes?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type InvoiceUpdateWithoutPurchaseOrderInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    salesOrder?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPurchaseOrderInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPurchaseOrderInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salesOrderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineUpdateWithoutPurchaseOrderInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    item?: ItemUpdateOneRequiredWithoutPurchaseOrderLinesNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutPurchaseOrderInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutPurchaseOrderInput = {
    purchaseLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceSource?: StringFieldUpdateOperationsInput | string
    overrideReason?: NullableStringFieldUpdateOperationsInput | string | null
    overriddenBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type StockMovementUpdateWithoutPurchaseOrderInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutStockMovementsNestedInput
    item?: ItemUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutPurchaseOrderInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutPurchaseOrderInput = {
    stockMovementId?: BigIntFieldUpdateOperationsInput | bigint | number
    movementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    movementType?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qtyIn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyOut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refTable?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchCreateManySalesOrderInput = {
    dispatchId?: bigint | number
    dispatchNo: string
    dispatchDate?: Date | string
    vehicleNo?: string | null
    driverName?: string | null
    status?: $Enums.DocStatus
    remarks?: string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type InvoiceCreateManySalesOrderInput = {
    invoiceId?: bigint | number
    invoiceNo: string
    invoiceType: $Enums.InvoiceType
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    customerId?: bigint | number | null
    supplierId?: bigint | number | null
    purchaseId?: bigint | number | null
    subtotal?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.DocStatus
    printTemplate?: string
    vendorInvoiceNo?: string | null
    vendorInvoiceDate?: Date | string | null
    vendorInvoiceTotal?: Decimal | DecimalJsLike | number | string | null
    matchStatus?: $Enums.MatchStatus
    mismatchAmount?: Decimal | DecimalJsLike | number | string
    matchCheckedBy?: bigint | number | null
    matchCheckedAt?: Date | string | null
    createdBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type SalesOrderLineCreateManySalesOrderInput = {
    salesOrderLineId?: bigint | number
    itemId: bigint | number
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type DispatchUpdateWithoutSalesOrderInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutDispatchesNestedInput
  }

  export type DispatchUncheckedUpdateWithoutSalesOrderInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispatchUncheckedUpdateManyWithoutSalesOrderInput = {
    dispatchId?: BigIntFieldUpdateOperationsInput | bigint | number
    dispatchNo?: StringFieldUpdateOperationsInput | string
    dispatchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNo?: NullableStringFieldUpdateOperationsInput | string | null
    driverName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutSalesOrderInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    creator?: UserUpdateOneWithoutInvoicesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    matchChecker?: UserUpdateOneWithoutInvoicesMatchedNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSalesOrderInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSalesOrderInput = {
    invoiceId?: BigIntFieldUpdateOperationsInput | bigint | number
    invoiceNo?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    supplierId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    purchaseId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumDocStatusFieldUpdateOperationsInput | $Enums.DocStatus
    printTemplate?: StringFieldUpdateOperationsInput | string
    vendorInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    vendorInvoiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vendorInvoiceTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    matchStatus?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    mismatchAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchCheckedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    matchCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderLineUpdateWithoutSalesOrderInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutSalesOrderLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutSalesOrderInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutSalesOrderInput = {
    salesOrderLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: BigIntFieldUpdateOperationsInput | bigint | number
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    invoiceLineId?: bigint | number
    itemId?: bigint | number | null
    description?: string | null
    qty?: Decimal | DecimalJsLike | number | string
    unitPrice?: Decimal | DecimalJsLike | number | string
    lineTotal?: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyInvoiceInput = {
    paymentId?: bigint | number
    paymentNo: string
    paymentDate?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PayMethod
    referenceNo?: string | null
    notes?: string | null
    receivedBy?: bigint | number | null
    createdAt?: Date | string
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneWithoutInvoiceLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    invoiceLineId?: BigIntFieldUpdateOperationsInput | bigint | number
    itemId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentNo?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPayMethodFieldUpdateOperationsInput | $Enums.PayMethod
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receivedBy?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryRangeCountOutputTypeDefaultArgs instead
     */
    export type SalaryRangeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryRangeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryPeriodCountOutputTypeDefaultArgs instead
     */
    export type SalaryPeriodCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryPeriodCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryRecordCountOutputTypeDefaultArgs instead
     */
    export type SalaryRecordCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryRecordCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCategoryCountOutputTypeDefaultArgs instead
     */
    export type ItemCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderCountOutputTypeDefaultArgs instead
     */
    export type PurchaseOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesOrderCountOutputTypeDefaultArgs instead
     */
    export type SalesOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryRangeDefaultArgs instead
     */
    export type SalaryRangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryRangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeProfileDefaultArgs instead
     */
    export type EmployeeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceDailyDefaultArgs instead
     */
    export type AttendanceDailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceDailyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryPeriodDefaultArgs instead
     */
    export type SalaryPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryPeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryRecordDefaultArgs instead
     */
    export type SalaryRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalaryPaymentDefaultArgs instead
     */
    export type SalaryPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalaryPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCategoryDefaultArgs instead
     */
    export type ItemCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierItemPriceDefaultArgs instead
     */
    export type SupplierItemPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierItemPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerItemPriceDefaultArgs instead
     */
    export type CustomerItemPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerItemPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderDefaultArgs instead
     */
    export type PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderLineDefaultArgs instead
     */
    export type PurchaseOrderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesOrderDefaultArgs instead
     */
    export type SalesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesOrderLineDefaultArgs instead
     */
    export type SalesOrderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesOrderLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DispatchDefaultArgs instead
     */
    export type DispatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DispatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionDayDefaultArgs instead
     */
    export type ProductionDayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionDayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMovementDefaultArgs instead
     */
    export type StockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockBalanceDefaultArgs instead
     */
    export type StockBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockBalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceLineDefaultArgs instead
     */
    export type InvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashTransactionDefaultArgs instead
     */
    export type CashTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashTransactionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}